1 Join https://postgrespro.ru/docs/postgresql/9.6/tutorial-join

найти все записи погоды, в которых температура лежит в диапазоне температур других записей.
Соединим таблицу с собой: 
SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,
    W2.city, W2.temp_lo AS low, W2.temp_hi AS high
    FROM weather W1, weather W2


получим 
     city      | low | high |     city      | low | high 
---------------+-----+------+---------------+-----+------
 San Francisco |  46 |   50 | San Francisco |  46 |   50
 San Francisco |  46 |   50 | San Francisco |  43 |   57
 San Francisco |  46 |   50 | Hayward       |  37 |   54
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 San Francisco |  43 |   57 | San Francisco |  43 |   57
 San Francisco |  43 |   57 | Hayward       |  37 |   54
 Hayward       |  37 |   54 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  43 |   57
 Hayward       |  37 |   54 | Hayward       |  37 |   54
(9 rows)


Для получения решения нужно добавить операторы сравнения в блок WHERE 

SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,
    W2.city, W2.temp_lo AS low, W2.temp_hi AS high
    FROM weather W1, weather W2
    WHERE W1.temp_lo < W2.temp_lo
    AND W1.temp_hi > W2.temp_hi;

получим 
     city      | low | high |     city      | low | high 
---------------+-----+------+---------------+-----+------
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
(2 rows)


в результате получили 2 записи, однако на ум приходит идея выполнить запрос:
select * from weather where temp_hi<(select max(temp_hi) as max from weather) and temp_lo>(select min(temp_lo) from weather as min);
     city      | temp_lo | temp_hi | prcp |    date    
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
(1 row)

который вернет всего одну строку, поскольку из таблицы выбрано максимальное, минимальное, а поскольку записей всего 3, а условия - строгие -
то выведется только одна запись. В примере выше вывелось 2 записи, поскольку "все записи сравниваются со всеми" и нашли решение немного другой задачи - 
"температура лежит в диапазоне температур других записей"



2 Агрегатные функции 
SELECT city FROM weather WHERE temp_lo = max(temp_lo);     НЕВЕРНО
но это не будет работать, так как агрегатную функцию max нельзя использовать в предложении WHERE. (Это ограничение объясняется тем, что предложение
WHERE должно определить, для каких строк вычислять агрегатную функцию, так что оно, очевидно, должно вычисляться до агрегатных функций.) Однако как часто
бывает, запрос можно перезапустить и получить желаемый результат, применив подзапрос:

SELECT city FROM weather
    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);


Однако можно использовать агрегатную функцию так:
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city
    HAVING max(temp_lo) < 40;


Важно понимать, как соотносятся агрегатные функции и SQL-предложения WHERE и HAVING. Основное отличие WHERE от HAVING заключается в том, что WHERE 
сначала выбирает строки, а затем группирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления агрегатов), тогда как 
HAVING отбирает строки групп после группировки и вычисления агрегатных функций. Как следствие, предложение WHERE не должно содержать агрегатных функций; 
не имеет смысла использовать агрегатные функции для определения строк для вычисления агрегатных функций. Предложение HAVING, напротив, всегда содержит 
агрегатные функции. (Строго говоря, вы можете написать предложение HAVING, не используя агрегаты, но это редко бывает полезно. То же самое условие может 
работать более эффективно на стадии WHERE.)


3 Внешние ключи
вы хотите добиться, чтобы никто не мог вставить в таблицу weather строки, для которых не находится соответствующая строка в таблице cities. 
Это называется обеспечением ссылочной целостности данных.

CREATE TABLE cities (
        name     varchar(80) primary key,
        location point
);

CREATE TABLE weather (
        city      varchar(80) references cities(name),      // внешний ключ
        temp_lo   int,
        temp_hi   int,
        prcp      real,
        date      date
);

Тогда
INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
Приведет к
ОШИБКА:  INSERT или UPDATE в таблице "weather" нарушает ограничение внешнего
  ключа "weather_city_fkey"


4 Транзакции
Транзакции — это фундаментальное понятие во всех СУБД. Суть транзакции в том, что она объединяет последовательность действий в одну 
операцию «всё или ничего». Промежуточные состояния внутри последовательности не видны другим транзакциям, и если что-то помешает успешно завершить 
транзакцию, ни один из результатов этих действий не сохранится в базе данных.

BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
-- ...
COMMIT;


5 Представления - это способ задать ИМЯ для запроса SELECT на выборку данных и по этому ИМЕНИ быстро получать нужную «собранную» таблицу.
То есть можно создать сложный запрос в базу данных и дать ему имя, чтобы каждый раз не расписывать полный SELECT.

CREATE VIEW myview AS
    SELECT name, temp_lo, temp_hi, prcp, date, location
        FROM weather, cities
        WHERE city = name;

SELECT * FROM myview;


6 Оконные функции (https://postgrespro.ru/docs/postgresql/9.6/tutorial-window)
Оконная функция выполняет вычисления для набора строк, некоторым образом связанных с текущей строкой. Можно сравнить её с агрегатной функцией, но, в отличие от обычной агрегатной функции, при использовании оконной функции несколько строк не группируются в одну, а продолжают существовать отдельно. Внутри же, оконная функция, как и агрегатная, может обращаться не только к текущей строке результата запроса.

Вот пример, показывающий, как сравнить зарплату каждого сотрудника со средней зарплатой его отдела:

SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname)
  FROM empsalary;

  depname  | empno | salary |          avg          
-----------+-------+--------+-----------------------
 develop   |    11 |   5200 | 5020.0000000000000000
 develop   |     7 |   4200 | 5020.0000000000000000
 develop   |     9 |   4500 | 5020.0000000000000000
 develop   |     8 |   6000 | 5020.0000000000000000
 develop   |    10 |   5200 | 5020.0000000000000000
 personnel |     5 |   3500 | 3700.0000000000000000
 personnel |     2 |   3900 | 3700.0000000000000000
 sales     |     3 |   4800 | 4866.6666666666666667
 sales     |     1 |   5000 | 4866.6666666666666667
 sales     |     4 |   4800 | 4866.6666666666666667
(10 rows)
