https://habr.com/ru/company/southbridge/blog/713884/

1 Какие компоненты мастер-узла (Control Plane) Kubernetes и каково их назначение?
Узлы Control Plane Kubernetes являются “мозгом” кластера k8s. Узлы Control Plane управляют pod’ами в кластере и рабочими узлами, 
которые участвуют в кластере.

- Kube-api-server — API-сервер Kubernetes проверяет и настраивает данные для API-объектов, включая pod’ы, сервисы, контроллеры репликации и другие.
API-сервер обслуживает REST-операции и предоставляет фронтэнд для общего состояния кластера, через которое взаимодействуют все остальные компоненты. 

- Kubernetes controller manager - демон, который реализует основные контуры управления, поставляемые с Kubernetes. В робототехнике и автоматизации 
контур управления - это непрерывный контур, регулирующий состояние системы. Примерами контроллеров, которые сегодня поставляются с Kubernetes, 
являются контроллеры replication, endpoints, namespace и serviceaccounts.

- Kube-scheduler — Планировщик Kubernetes - это процесс Control Plane, который назначает pod’ы узлам. Планировщик определяет, какие узлы являются 
допустимыми местами размещения для каждого pod’а в очереди планирования в соответствии с ограничениями и доступными ресурсами. Затем планировщик 
ранжирует каждый допустимый узел и привязывает pod к подходящему узлу. Планировщиков может быть несколько.

- Etcd — распределенное целостное хранилище ключей и данных с открытым исходным кодом, используемое для совместной конфигурации, обнаружения 
сервисов и координации планировщика распределенных систем или кластеров машин. В Control Plane Kubernetes Etcd используется для хранения и 
репликации всех состояний кластера k8s. 

- Cloud-controller-manager (используется в облачных провайдерах) — Cloud-controller-manager обеспечивает интерфейс между кластером Kubernetes 
и облачными API-сервисами. Диспетчер облачных контроллеров позволяет кластеру Kubernetes обеспечивать, отслеживать и удалять облачные ресурсы, 
необходимые для рабочих операций кластера. 


2 Каковы компоненты рабочего узла (worker node) и их назначение?

Рабочие узлы (worker nodes) отвечают за размещение прикладных pod’ов в кластере. Хотя прикладные pod’ы можно размещать в узлах Control Plane, 
наилучшей практикой является размещение pod’ов на рабочих узлах по соображениям безопасности.
Рабочие узлы содержат компоненты, которые позволяют им выполнять запросы Control Plane.

- Kube-proxy отвечает за поддержание сетевых правил на ваших узлах. Сетевые правила позволяют осуществлять сетевую связь с вашими pod’ами 
как внутри, так и за пределами вашего кластера

- Kubelet является агентом, который запускается на каждом узле. Он отвечает за создание pod’ов в соответствии с предоставленной 
спецификацией YAML, отправку на API-сервер состояния работоспособности pod’ов и предоставление информации о состоянии узла, такой как сеть, 
дисковое пространство и многое другое.


3 В чем разница между Init- и Sidecar-контейнерами?

-Init-контейнер — всегда запускается перед Sidecar-контейнером и основным контейнером приложения. Init-контейнер должен быть запущен до успешного 
завершения, прежде чем смогут начать работу остальные контейнеры. Причиной использования Init-контейнера могут быть разнообразные применения. 
Например, его можно использовать для проверки наличия зависимостей приложения, настройки основной среды или среды контейнера Sidecar-контейнера, 
а также многого другого.

-Sidecar-контейнер — запускается параллельно основному контейнеру приложения. Существуют различные причины для использования сайдкар контейнеров. 
Например, в Istio Sidecar-контейнер используется в качестве прокси-сервера для управления входящим трафиком на основной контейнер, его также можно 
использовать для логгирования, целей мониторинга и многого другого.


4 В чем разница между Deployment и StatefulSet?
Deployment — является самым простым и наиболее часто используемым ресурсом для развертывания приложений в кластере Kubernetes. Deployment обычно используются 
для приложений без состояния, что означает, что данные, находящиеся в pod’е, будут удалены вместе с pod’ом. Если мы используем постоянное хранилище с Deployment,
у нас будет одинPersistence volume claim для всех pod’ов, которые принимают участие в развертывании. Deployment порождает ресурс ReplicaSet, через который идут 
переключения между разными версиями нашего приложения. Pod’ы, принадлежащие Deployment всегда именуются по следующей схеме: <deployment-name>-<replicaset-id>-<pod-id>.

StatefulSet — ресурс, который стал стабильным в версии Kubernetes 1.9, поскольку сообщество запросило возможность размещения приложений с состоянием в кластере 
Kubernetes. StatefulSet не использует ReplicaSet в качестве вторичного контроллера, но он управляет pod’ами самостоятельно. Pod’ы StatefulSet’а именуются по следующему 
шаблону: <Statefulset-name>-0, <Statefulset-name>-1. Соглашение об именовании используется для сетевых идентификаторов и управления обновлением. StatefulSet требует 
headless-сервис, позволяя обеспечить идентифицкацию в сети и разрешение DNS имен для pod’ов, участвующих в StatefulSet. Каждая реплика в развертывании StatefulSet 
получает собственную persistent volume clain, так что каждый pod будет иметь свое собственное состояние.

Наконец, эмпирическое правило заключается в том, что приложения без состояния должны разворачиваться через Deployment. Deployment включают в себя другой контроллер,
 называемый ReplicaSet, для упрощения обновлений и откатов. StatefulSet был создан на основе потребностей сообщества и обычно используется для приложений с состоянием 
 таких как, например, баз данных, где определение других реплик в кластере имеет решающее значение, а обновления должны выполняться корректно.


5 Перечислите различные типы сервисов. Для чего они используются?

Сервис Kubernetes — это логическая абстракция группы pod’ов, выбранных селектором. Service используется для настройки политики, с помощью которой можно получить доступ
 к нижележащим pod’ам.

— ClusterIP является типом сервиса по умолчанию и наиболее распространенным сервисом в экосистеме Kubernetes. Сервис типа ClusterIP имеет внутрикластерный IP-адрес 
и доступен только в рамках кластера.

- LoadBalancer — тип сервиса LoadBalancer используется для обеспечения доступа внешнего трафика путем выделения loadbalancer. Чтобы использовать этот тип сервиса, 
необходима поддерживающая это платформа, которая сможет распределять loadbalancer. Loadbalancer будет создан асинхронно, и информация о балансировщике нагрузки 
будет доступна в сервисе только тогда, когда он будет доступен и присвоен сервису. Тип службы loadbalancer также имеет ClusterIP и выделяет NodePort для доступа к сервису.

- NodePort — тип сервиса NodePort обычно используется, когда сервису предоставляется доступ к внешнему трафику, а тип Service LoadBalancer недоступен. 
С типом Service NodePort вы выбираете порт (в пределах допустимого диапазона от 30000 до 32767), который каждый узел в кластере откроет для приема трафика и 
переадресации на сервис. Тип службы NodePort также имеет ClusterIP, который позволяет сервису быть доступным из кластера.

- Headless — тип сервиса Headless используется, когда требуется прямая связь с pod’ом. В приложениях с состоянием, например, баз данных вторичные pod’ы должны 
напрямую взаимодействовать с первичными pod’ами для репликации данных между репликами. Headless позволяет DNS разрешать pod’ы и получать к ним доступ по имени pod’а. 
Headless - это сервис, который настроен иным образом, чем ClusterIP и не имеет отдельного внутрикластерного IP адреса. Для доступа к pod’у через Headless-сервис необходимо 
будет воспользоваться следующим доменным именем: <pod-name>.<service-name>.<namespace>.svc.cluster.local.














kubectl get po --namespace <your-namespace>



kubectl api-resources
NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND
bindings                                       v1                                     true         Binding
componentstatuses                 cs           v1                                     false        ComponentStatus
configmaps                        cm           v1                                     true         ConfigMap
endpoints                         ep           v1                                     true         Endpoints
events                            ev           v1                                     true         Event
...


Kubernetes API — это HTTP REST API. Этот API — настоящий пользовательский интерфейс Kubernetes, через который он полностью контролируется. 
Это означает, что каждая операция Kubernetes представляется как конечная точка API и может быть выполнена HTTP-запросом к этой конечной точке.

Следовательно, основная задача kubectl — выполнять HTTP-запросы к API Kubernetes

# Custom

Паттерн "оператор" (документация кубера)

Концепция паттерна "оператор" Kubernetes позволяет расширять поведение кластера без изменения кода самого Kubernetes, связывая 
контроллеры с одним или несколькими пользовательскими ресурсами. 

Приложение Kubernetes — это приложение, которое развертывается в Kubernetes и управляется с помощью API Kubernetes и инструментов
kubectl (kubernetes) или oc (OKD). 
Пример приложения - Prometheus, Jaeger. Чтобы получить максимальную отдачу от Kubernetes, вам нужен набор согласованных API-интерфейсов 
для расширения, чтобы обслуживать и управлять вашими приложениями, работающими в Kubernetes.  Думайте об операторах как о среде 
выполнения, которая управляет этим типом приложений в Kubernetes.


https://www.jaegertracing.io/docs/1.13/operator/
Операторы — это части программного обеспечения, которые упрощают операционную сложность запуска другой части программного обеспечения.  
С технической точки зрения операторы — это метод упаковки, развертывания и управления приложением Kubernetes. 
Думайте об операторах как о среде выполнения, которая управляет этим типом приложений в Kubernetes.

https://habr.com/ru/company/vk/blog/515138/
CRD — просто таблица в Kubernetes. Вы можете создать новые таблицы с CRD и добавлять записи с CR. Также в CRD вы можете задать 
схему таблицы, определив названия и типы столбцов. Освоив команды CRD, CR и kubectl, вы можете загружать в Kubernetes любые данные.

Операторы — это программные расширения для Kubernetes, которые используют CR - настраиваемые (пользовательские) ресурсы для управления 
приложениями и их компонентами. Операторы следуют принципам Kubernetes, особенно циклу управления.

Настраиваемые (пользовательские) ресурсы — это расширения Kubernetes API. Ресурс — это эндпоинт API Kubernetes, в которой хранится
набор объектов API определенного типа. Пользовательский ресурс — это расширение API Kubernetes, которое не всегда доступно в 
стандартной установке Kubernetes.  Он представляет собой настройку конкретной установки Kubernetes.  Однако многие основные 
функции Kubernetes теперь создаются с использованием пользовательских ресурсов, что делает Kubernetes более модульным.

Пользовательские ресурсы могут появляться и исчезать в работающем кластере посредством динамической регистрации, а администраторы 
кластера могут обновлять пользовательские ресурсы независимо от самого кластера.  После установки пользовательского ресурса 
пользователи могут создавать и получать доступ к его объектам с помощью kubectl, как и для встроенных ресурсов, таких как Pods.

Сами по себе пользовательские ресурсы позволяют хранить и извлекать структурированные данные.  Когда вы объединяете настраиваемый 
ресурс с настраиваемым контроллером, настраиваемые ресурсы предоставляют настоящий декларативный API.

Пользовательский контроллер можно развернуть и обновить в работающем кластере независимо от жизненного цикла кластера


Операторы используютя для Stateful-приложений (https://www.youtube.com/watch?v=ha3LjlD6g7g)


Kubernetes предоставляет два способа добавления пользовательских ресурсов в ваш кластер:

     -Custom Resource Def (CRD) просты и могут быть созданы без какого-либо программирования.
     -API server aggregation требует программирования, но позволяет лучше контролировать поведение API, например, как хранятся данные и преобразование между версиями API.


CRD позволяют пользователям создавать новые типы ресурсов без добавления другого сервера API.  Вам не нужно разбираться в агрегации API, 
чтобы использовать CRD. Независимо от того, как они установлены, новые ресурсы называются пользовательскими ресурсами, чтобы отличать 
их от встроенных ресурсов Kubernetes (например, модулей).


Shared informers (https://habr.com/ru/company/ozontech/blog/679818/). 
Всё в Kubernetes представляет собой декларативное описание объектов, которое указывает желаемое для объекта состояние. И задача 
Kubernetes — следить за изменениями системы и поддерживать объекты в нужном состоянии. Текущее состояние объекта — это результат 
всех предшествующих ивентов.

Каждый объект в Kubernetes имеет версию ресурса (resourceVersion), которая изменяется при любом новом ивенте, который случается с объектом.
Давайте рассмотрим жизнь ивента в Kubernetes. Например, вы создали под. Что произойдёт? Сначала объект будет сохранён в etcd, который 
является хранилищем для Kubernetes. Затем объект из etcd попадёт в API Server, а после этого будет обработан в client-go. И уже client-go 
доставит объект всем заинтересованным пользователям (контроллерам, операторам, шедулерам).

etcd
Etcd предоставляет интерфейс, основанный на событиях. Если произойдёт изменение, то наблюдатели будут уведомлены о нём. Понятие ревизий 
в etcd соответствует версии ресурса в API Server: Revision(etcd)=resourceVersion(API Server).

Между etcd и клиентом поддерживается двунаправленный стрим. Таким образом, клиенты могут установить наблюдение за объектом и получать 
интересующие ивенты. Клиентом etcd в случае Kubernetes является API Server.

В API Server etcd watchers получают ивент, преобразовывают его из etcd-ивента в ивент API Server, а затем ивент попадает в watch_cache, 
который отвечает за Watсh- и List-интерфейсы. 

client-go — Kubernetes-пакет, который содержит множество клиентских библиотек (Dynamic Client, Clientset, REST Client, Informers и др.) 
и позволяет обращаться к кластеру Kubernetes.

Informers. 
Это решение разработано специально для использования контроллерами и пользовательскими операторами и является частью client-go. 
Informer представляет собой in-memory cache событий в Kubernetes. Между Informers и API Server устанавливается постоянное соединение.


RBAC - управление доступом на основе ролей

https://www.youtube.com/watch?v=JMrxPyv9nxQ
Операторы K8s - нужны для расширения кубера. Расширением является "Приложение кубернетеса". Позволяют используя kubectl управлять ресурсами, которые создали самостоятельно.
Для понимания кубернетесом этих расширений необходимо использовать CRDs. Применяя CRDs, кубернетес знает "общую" информацию о
новом ресурсе (аналог схемы БД - без ее наполнения - например - таблица "фрукты"). Наполнением является CR ("яблоко", "апельсин" и тд).
Но что делать куберу с этими ресурсами? Для их управления необходимо разработать контроллер. 

Оператор деплоит и управляет "Приложением кубернетеса" и наблюдает за кастомными ресурсами (CR):
- определяет текущее состояние ресурса
- анализирует переход от текущего стейта к желаемому
- содействует для перехода от текущего стейта к желаемому

Все это оператор делает через K8s API. Операторы пакуются как images (образы) и выполняются как поды.

Оператор - аналог кастомного control loop в k8s (позволяет следить за изменениями и обладает логикой - обновляет конфигурацию, следит за тем,
не упал ли под с приложением и тд)


https://www.youtube.com/watch?v=tFzM-2pwL8A



Среды выполнения контейнеров:
Docker, CRI-O и containerd


https://www.redhat.com/en/technologies/cloud-computing/openshift/what-are-openshift-operators#operator-framework
Пакет разработки программного обеспечения оператора (SDK) предоставляет инструменты для создания, 
тестирования и упаковки операторов.  SDK удаляет большую часть шаблонного кода, который обычно требуется для интеграции 
с Kubernetes API.  Он также предоставляет полезную основу, поэтому разработчики могут сосредоточиться на добавлении 
бизнес-логики (например, о том, как масштабировать, обновлять или создавать резервные копии управляемого им приложения). 
Передовые практики и шаблоны кода, которыми пользуются операторы, включены в SDK, чтобы предотвратить дублирование усилий. 
 SDK также поддерживает короткие итеративные циклы разработки и тестирования с инструментами, которые позволяют выполнять 
 базовую проверку оператора и автоматическую упаковку для развертывания с помощью диспетчера жизненного цикла оператора.


OLM - operator lifecicle manager 
Operator Lifecycle Manager (OLM) — это объединительная плата, облегчающая управление операторами в кластере Kubernetes
С помощью OLM администраторы могут контролировать, какие операторы доступны в каких пространствах имен и кто может взаимодействовать 
с запущенными операторами.  Разрешения оператора точно настраиваются автоматически, чтобы следовать подходу с наименьшими привилегиями. 
OLM управляет общим жизненным циклом операторов и их ресурсов, выполняя такие действия, как разрешение зависимостей от других операторов, 
запуск обновлений как для оператора, так и для приложения, которым он управляет, или предоставляя команде доступ к оператору для 
его фрагмента кластера.
https://github.com/operator-framework/operator-lifecycle-manager/blob/master/doc/install/install.md


https://www.redhat.com/en/topics/containers/what-is-a-kubernetes-operator
CR (custom resource) - Пользовательский ресурс — это механизм расширения API в Kubernetes. 
Пользовательское определение ресурса (CRD) определяет CR и перечисляет все конфигурации, доступные пользователям оператора.
Оператор Kubernetes наблюдает за типом CR и выполняет действия, специфичные для приложения, чтобы привести текущее состояние 
в соответствие с желаемым состоянием в этом ресурсе.

Операторы Kubernetes вводят новые типы объектов с помощью пользовательских определений ресурсов.  
Пользовательские определения ресурсов могут обрабатываться API Kubernetes так же, как и встроенные объекты, 
включая взаимодействие через kubectl и включение в политики управления доступом на основе ролей (RBAC).

Оператор Kubernetes продолжает следить за своим приложением во время его работы и может автоматически создавать резервные 
копии данных, восстанавливаться после сбоев и обновлять приложение с течением времени. 

Действия, которые выполняет оператор Kubernetes, могут включать практически все: масштабирование сложного приложения, 
 обновление версии приложения или даже управление модулями ядра для узлов в вычислительном кластере со специализированным оборудованием.

Kubernetes может управлять и масштабировать приложения без сохранения состояния (stateless), такие как веб-приложения, мобильные серверные части и 
 службы API, не требуя никаких дополнительных знаний о том, как эти приложения работают.  Встроенные функции Kubernetes созданы для того, 
 чтобы легко справляться с этими задачами.

Однако приложения с отслеживанием состояния (stateful), такие как базы данных и системы мониторинга, требуют дополнительных знаний в 
 предметной области, которых нет в Kubernetes.  Эти знания необходимы для масштабирования, обновления и перенастройки этих приложений.

Операторы Kubernetes кодируют эти конкретные знания предметной области в расширения Kubernetes, чтобы они могли управлять жизненным циклом приложения и автоматизировать его. 

Устраняя сложные ручные задачи по управлению приложениями, операторы Kubernetes делают эти процессы масштабируемыми, воспроизводимыми и 
стандартизированными.


The Operator Framework includes:
- Пакет SDK для операторов: позволяет разработчикам создавать операторов на основе их опыта, не требуя знаний о сложностях API Kubernetes.
- Управление жизненным циклом оператора: контролирует установку, обновления и управление жизненным циклом всех операторов, работающих в кластере 
Kubernetes.
- Измерение оператора: позволяет создавать отчеты об использовании для операторов, предоставляющих специализированные услуги.


WebHooks https://habr.com/ru/company/otus/blog/669806/
Reconciler выполняет изменение конфигурации в соответствии с разностью между текущим и ожидаемым состоянием. Кроме это для проверки 
корректности согласованности спецификации может быть добавлено использование webhook и здесь нужно сделать небольшое введение в Dynamic 
Admission Control. Динамическое управление позволяет зарегистрировать два вида дополнительных обработчиков во время операций над 
ресурсами - ValidatingWebhook (проверяет корректность схемы создаваемого ресурса, позволяет отменить операцию при нарушении схемы) 
и MutatingWebhook (допускает возможность внесения изменений в ресурс перед развертыванием)



Kubebuilder tutorial (cronJob) https://book.kubebuilder.io/cronjob-tutorial/gvks.html

Group - Группа API в Kubernetes — это просто набор связанных функций.  
Version - Каждая группа имеет одну или несколько версий, которые, как следует из названия, позволяют нам со временем изменять работу API. 
Kind - Каждая групповая версия API содержит один или несколько типов API, которые мы называем Kind
Ресурс — это просто использование типа в API.  Часто между типами и ресурсами существует однозначное соответствие.  
Например, ресурс pods соответствует Kind Pod. Ресурсы всегда пишутся строчными буквами


GroupVersionKind - Когда мы ссылаемся на вид в конкретной версии группы, мы будем называть его GroupVersionKind, или сокращенно GVK.  
То же самое с ресурсами и GVR.  Как мы вскоре увидим, каждый GVK соответствует данному корневому типу Go в пакете.







Смена контекстов:
 - kubectl config get-contexts - посмотреть доступные контексты
 - kubectl config use-context CONTEXT_NAME - изменить контекст

 - kubectl config view - инфо из кубконфига
 - minikube dashboard - открывает GUI дашборд
