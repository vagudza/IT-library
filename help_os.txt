Вопросы про ОС

Можно ли убить поток внутри определенного процесса командой kill?
    Потоки являются неотъемлемой частью процесса и не могут быть уничтожены вне его. Есть функция pthread_kill, но она применяется только в контексте самого
    потока. Обратите внимание, что pthread_kill() вызывает обработку сигнала только в контексте данного потока; действие сигнала (завершение или остановка)
    влияет на процесс в целом.


Linux - представители семейства Unix-подобных ОС на общем ядре.
    Unix-подобные - широкое дерево ОС.

    Слои Linux:
        - Hardware (железо)
        - Kernel (ядро ОС) - драйвера, высокоуровневые части, которые позволяют ОС абстрагироваться, как работает каждая конкрентная железяка
        - Userspace (рабочее окружение) - программы, которыми пользователи могут управлять

    Из чего состоит любой Linux:
        - Ядро (kernel) разных версий - позволяет подружить софт и железо
        - Дистрибутив (distribution) - готовый набор компонент (CentOS, Ubuntu, RedHat, Fedora, Suse, Debian) - десктопный/серверный
        - Среда рабочего стола (GUI, по необходимости - Gnome, KDE, Mate, XFCE, Budgie)

    LTS ядра - Long Time Support

    POSIX (portable) - Набор стандартов, описывающих интерфейсы между операционной системой и прикладной программой, 
        библиотеку языка C и набор приложений и их интерфейсов. Стандарт создан для обеспечения совместимости различных UNIX-подобных
        операционных систем и переносимости прикладных программ на уровне исходного кода, но может быть использован и для не-Unix систем.

    Окружения командной строки 
        -sh - самая базовая версия (POSIX-совместимая). Много чего не хватает, но есть везде
        -bash - самая популярная версия
        -zsh - самая удобная
        -fish - самая хиптерская
        -и другие

    Команды shell:
        - man <command> - информация о команде 
        - echo 'hello world' - вывод в stdout
        - echo 'hello world (err)' >&2 - вывод в stderr (знак "больше" - перенаправление вывода - в поток номер 2 - stderr)
        - echo 'some words' > file.txt - вывод в файл
        - echo ' and more words...' >> file.txt  - дописать в файл
        - echo $PATH - список директорий, в которых осуществляется поиск исполняемых файлов\утилит для запуска
        - cat filename - вывод информации из файла в stdout
        - chmod <permissions> <filename> - изменение прав доступа для filename - permissions-числовое значение, например, 644 (default value is 644)
        - chown <username>:<group> <filename> - изменение владельца файла на username из группы
        - ps aux - вывести все процессы
        - kill <signal> <pid> - отправляет сигнал процессу: принимает номера идентификаторов процессов в качестве аргумента и убивает только один 
            процесс за раз (если вы не укажете несколько идентификаторов процессов в своей команде) 
        - killall <processName> - позволяет нам убивать процессы по имени и завершать все процессы с совпадающим именем
        - htop - вывод на терминал списка запущенных процессов и информации о них
        - grep <substr> <filename> - поиск по тексту
        - find <dir> -name <filename> - поиск по имени файла. filename может быть и таким: "items.*"
            -type f - поиск только по файлам 
                

        работа с директориями:
            -pwd - показать текущую директорию
            -cd <dir> - изменить директорию
                .. - на уровень выше 
                - ("cd -") - возврат на предыдущую директорию
            -mkdir <folder> - создать директорию

        работа с файлами:
            -ls - выводит список файлов и директорий, в которой находимся
                <folder> - выводит список файлов и директорий по указанному пути
                .. - выводит список файлов и директорий от родительской директории
                -l - вывод подробной информации (файлы, владельцы, дата создания, права...)
                -lah - вывод подробной информации (права, пользователь:группа, дата)
            -touch <filename> - создает пустой файл
            -mv <filename1> <filename2> - переименовывает filename1 в filename2. Если указан путь - то перемещает файл из filename1 в filename2
                пример: переместить файл из родительской директории в текущую: "mv ../new-name.txt ."
                -r - двигает папку (recursive)
            -cp <filename> <newfilename> - копирует filename в newfilename
                -r - копирует папку
            -rm <filename> - удаление файла
                -r удаляет папку
                    никогда не выполняйте:
                        "rm -r /" - удалить весь диск
                        "rm -rf *" - удалить все, что находится в текущей директории и ниже
                        "rm -rf ." - удалить все, что находится в текущей директории и ниже
                        "rm -rf .." - удалить все, что находится в родительской директории и ниже
            -ln - создание ссылки на файл. Символические и жесткие ссылки - это особенность файловой системы Linux, которая позволяет размещать один 
                и тот же файл в нескольких директориях. Это очень похоже на ярлыки в Windows, так как файл на самом деле остается там же где и был, 
                но вы можете на него сослаться из любого другого места. Символические ссылки более всего похожи на обычные ярлыки. Они содержат адрес 
                нужного файла в вашей файловой системе. Когда вы пытаетесь открыть такую ссылку, то открывается целевой файл или папка. Главное ее отличие
                от жестких ссылок в том, что при удалении целевого файла ссылка останется, но она будет указывать в никуда, поскольку файла на самом деле 
                больше нет. А при удалении исходного файла, на который ссылается жесткая ссылка, она будет показывать содержимое исходного файла

                
    Потоки
        - stdin - стандартный поток для ввода информации
        - stdout - стандартный поток для вывода, используется для вывода общей информации
        - stderr - стандартный поток для ошибок

    Особые директории Linux:
        /bin - основные утилиты, необходимые в работе (rm, touch, copy ...и другие стандартные утилиты)
        /usr - пользовательские утилиты (доставляем собстенные утилиты)
        /tmp - временные утилиты
        /etc - файлы конфигурации системы (все конфиги)
        /home - файлы пользователя

    Система пользователей и групп - основа безопасности
        - groupadd newgroup - создаст группу newgroup
        - useradd -G newgroup -p password newuser - создаст нового пользователя newuser с паролем password в группе newgroup
        - groups - список групп на компьютере
        - users - список пользователей компьютера
        - id <username> - вывод информации о конкрентном пользователе


        "-" обозначает файл, "d" - директорию
        |
        V
         rwx    rwx     rwx         
        Owner  Group  Other_users

       r - read = 4
       w - write = 2
       x - execute (исполнение) = 1
       ________________
       total 7 bytes

        Пример: ls -l file.txt
            rw- rw- r--
            owner can read and write
            group can read and write
            anyone can read

        Пример:
            - rw- r-- r-- = 644
                "-" - обозначает файл, "d" - обозначает папку
                "rw-" - обозначает, что владелец может писать и читать = 6 (r=4 + w=2 = 6)
                "r--" - обозначает, что группа может читать = 4
                "r--" - обозначает, что другие пользователи могут читать = 4


    shebang
        #!/usr/bin/env sh - метаинформация, говорящая о том, как файл будет выполняться
            /usr/bin/env - используя env для получения пути к файлу интерпретатора
                Шебанг должен задавать абсолютный путь (или путь относительно текущего рабочего каталога) для выполняемых файлов. 
                Это может привести к проблемам для систем с нестандартной структурой файловой системы.
                Для лучшей переносимости используют /usr/bin/env, обладающий возможностью поиска программы в PATH
            sh - имя файла программы-интерпретатора
        
        пример:
            #!/bin/sh — выполнить файл с помощью sh (Bourne shell) или другой совместимой оболочки;
            #!/usr/bin/env python2 — выполнить файл как программу на Python, используя env для получения пути к файлу интерпретатора.


    Скрипты sh
        COLUMNS=1 ls - вывод списка файлов и директорий в одну колонку

        Формы обращения:
            $VAR - может быть опасным
            "$VAR" - правильный вариант, если ничего нет после VAR
            "${VAR}" - правильный вариант, если VAR внутри другой строки
            '$VAR' - просто строка
        
        Пример:
            #!/usr/bin/env sh
            #Declaring:
            MY_VARIABLE='Hi!'
            echo "$MY_VARIABLE"         # выведет Hi!
            echo $MY_VARIABLE           # выведет Hi!
            echo "${MY_VARIABLE}"       # выведет Hi!

        env - покажет переменные окружения

        Условия
            #!/usr/bin/env sh
            MY_VAR=1                # MY_VAR = 1 - Ошибка

            if [ "$MY_VAR" -eq 1 ]; then
                echo 'MY_VAR is 1'
            else
                echo 'MY_VAR is not 1'
            fi

        Сравнения
            s1 = s2 - идентичны ли две строки
            s1 != s2 - не идентичны строки? 
            s1 -eq s2 - идентичны ли два числа?
            s1 -ne s2 - не идентичны числа?

        Булевы операции
            e1 -a e2 - булево "И"
            e1 -o e2 - булево "ИЛИ"
            ! - отрицание

        Специальные условия
            [-f - существует ли файл
            [-d - существует ли директория
            [-n - не пустая ли строка
            [-z - пустая ли строка

        [] - в них указываются команды программы?
            Пример:
            MY_VAR=1
            [ "$MY_VAR" -eq 1 ] && echo 'MY_VAR is 1' || echo 'MY_VAR is not 1'
            т.е. если переменная $MY_VAR == 1, то выполнится левый echo, иначе - правый echo 

        аналог [] - это test
            Пример:
            MY_VAR=1
            test "$MY_VAR" -eq 1 \
                && echo 'MY_VAR is 1' \ 
                || echo 'MY_VAR is not 1'

        readonly
            Пример:
            readonly X=1
            X=2                     # ошибка: read-only variable: X


        Цикл while
            Пример:
            #!/usr/bin/env sh
            SUM_RESULT=0
            while [ "$SUM_RESULT" -le 5 ]; do                   # SUM_RESULT < 5
                echo "Welcome $SUM_RESULT times"
                SUM_RESULT=$(( SUM_RESULT + 1))
            done

            Пример с чтением строк из файла:
            while read -r line; do
                echo "line: $line"
            done < items.txt                                # подаем содержимое файла в цикл таким образом

        Цикл for 
            Пример:
            #!/usr/bin/env sh
            MY_ARRAY=(1 2 3)                                # массив - в POSIX массивы недоступны
            echo "Array size: ${#MY_ARRAY[*]}"              # размер массива

            for item in ${MY_ARRAY[*]}; do
                echo "item: $item"
            done

        Функции
            Пример:
            #!/usr/bin/env sh
            my_ls() {                           # объявление функции
                echo 'Listing files'
                ls
                echo 'done'
            }
            my_ls                               # вызов функции

            Пример 2:
            #!/usr/bin/env sh
            my_function() {
                local variable=1                        # локальная переменная
                OTHER_VARIABLE=2                        # глобальная область видимости переменной
            }
            my_function

            echo "OTHER_VARIABLE is $OTHER_VARIABLE"    # 2  
            echo "variable is $variable"                #  - ничего не выведет

        Аргументы функции
            Пример:
            #!/usr/bin/env sh
            sum_two_numbers() {
                local first
                local second

                first="$1"                              # подстановка 1го аргумента
                second="$2"                             # подстановка 2го аргумента
                third="${3:-root}"                      # подстановка 3го аргумента - установлено значение по умолчанию, если аргумент отсутствует
                                                        
                echo "$((first + second))"              # аналог команды echo "$(($1 + $2))" 
                echo "Hello, $user"                     # аналог команды  echo "Hello, ${3:-root}"   
            }
            sum_two_numbers 2 3                         # выведет 5, а потом "Hello, root"

            Пример вывода всех аргументов:
            #!/usr/bin/env sh
            echo_all_args() {
                echo "args: $*"                         # получение всех аргументов как строки
                echo "args is $@"
            }
            echo_all_args 'cat' 'dog' 'mouse'          # выведет: "args: cat dog mouse", а потом args is "cat dog mouse"

        Опции функции
            Пример:
            with_named() {
                local h
                local p
                local d

                OPTIND=1

                while getopts 'hd:p:' opt; do
                    case "$opt" in
                        h) h=$OPTARG;;
                        p) p=$OPTARG;;
                        d) d=$OPTARG;;

                        *) (echo 'invalid arg'; exit 1);;
                    esac
                done

                shift $((OPTIND-1))
                [ "$1" = '--' ] && shift

                echo "
                    ARGS:
                        -h: $h
                        -p: $p
                        -d: $d
                "
            }

        Возвращаемое значение функций
            Типы возвращаемых значений - статус код/значение
            Для возврата статус-кода используйте return, а для значения - echo
            
            Статус код выполенной операции: "$?"
                Пример:
                cat ex.sh               # выполняем команду - показать содержимое файла
                echo 'I do exist'       # вывод результата команды в stdout
                echo "$?"               # запрашиваем статус-код выполнения команды - выведет 0 - значит команда cat выполнена успешно

                Пример:
                #!/usr/bin/env sh
                can_fail() {
                    if [ "$1" -eq 5 ]; then
                        echo 'error'
                        return 1
                    fi

                    echo 'correct'
                    return 0
                }

                can_fail 1                      # вызываем функцию с параметром "1" - функция вернет статус код 0
                echo "status code is $?"        # 0
                
                can_fail 5                      # вызываем функцию с параметром "1" - функция вернет статус код 1
                echo "status code is $?"        # 1
            
        Subshell:
            Пример:
                #!/usr/bin/env sh
                can_fail() {
                    if [ "$1" -eq 5 ]; then
                        echo 'error'
                        return 1
                    else 
                        echo 'correct'
                        return 0
                    fi
                }

                first=$(can_fail 1)
                echo "returns: $first, code is $?"          # returns: correct, code is 0

                second=$(can_fail 5)
                echo "returns: $second, code is $?"         # returns: error, code is 1

        Подсказки:
            1 Группа команд:
                cd ~; pwd
            2 Группа команд, выполняемая в одном процессе:
                {cd ~; pwd}
            3 Выполнение команды и присваивание ее результата в переменную
                var=$(cat file.txt)
            4 ${var} - еще один способ определения перемекнной $var
            5 /usr/bin[ - это программа, которая оценивает утверждение
                if [...]  
            6 Более мощный bash синтаксис:
                if [[ ... ]]    
            7 "Расширение скобки" - расширяет до строки "a.png a.svg"
                a{.png,.svg}
            8 $(( )) - для вычисления арифметики
                $((2+2))
            
        Файлы скриптов:
            Запуск скрипта - команда source - выполнить скрипт в текущем процессе оболочки bash. По умолчанию для выполнения
                каждого скрипта запускается отдельная оболочка bash, хранящая все его переменные и функции. После завершения 
                скрипта всё это удаляется вместе с оболочкой. Команда source позволяет выполнить скрипт в текущем командном 
                интерпретаторе, а это значит, что всё переменные и функции, добавленные в этом скрипте, будут доступны также 
                и в оболочке после его завершения:
                    source shebang.sh
            Ранее такой команды не было, поэтому запускали так:
                . shebang.sh
            
        Экспорт переменных (source)
            #!/usr/bin/env sh
            MY_VAR='value'
            export $MY_VAR              # позволяет использовать переменные при выполнении source
    
        Настройка скрипта (set)
            Команда set - используют для более строгих правил (например, завершить работу скрипта, если переменная не определена) или для дебага:
            -o errexit или -e - падай на первой ошибке
            -x - покажи команды, которые выполняются
            -o nounset - падай на необъявленных переменных
            -o pipefail - падай на проблемах в pipes
    
    Пайпы (конвееры) - это однонаправленный канал межпроцессного взаимодействия:
        Пример:
        ps aux | grep zsh

        xargs - для композиции пайпов: агрументов программа берет данные из стандартного ввода или из файла, разбивает их 
            в соответствии с указанными параметрами, а затем передает другой программе в качестве аргумента.
        Пример:
        ls | sort -fd | xargs echo "sorted: $1"

    Shellcheck - утилита для проверки скриптов (хороший линтер)


make — утилита предназначенная для автоматизации преобразования файлов из одной формы в другую. Правила преобразования 
задаются в скрипте с именем Makefile, который должен находиться в корне рабочей директории проекта.

В общем виде синтаксис makefile можно представить так:

# Индентация осуществляется исключительно при помощи символов табуляции,
# каждой команде должен предшествовать отступ
<цели>: <реквизиты>
	<команда #1>
	...
	<команда #n>

{Из чего делаем? (реквизиты)} ---> [Как делаем? (команды)] ---> {Что делаем? (цели)}