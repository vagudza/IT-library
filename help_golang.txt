GOLANG



// Структура проекта (project-Layout):
    /project
        /cmd                                // Основные приложения проекта. Не стоит располагать в этой директории большие объёмы кода. 
            /project                        // Имя директорий для каждого приложения должно совпадать с именем исполняемого файла
                main.go
        /internal                           // вся бизнес-логика, детали реализации (Если же код не должен быть переиспользован где-то еще)
            /module1
            /module2
        /pkg                                // для экспорта (Если вы предполагает дальнейшее использование кода в других проектах)
            /project
    .Makefile



// .Makefile - запуск сложных команд в одном месте
    Содержимое:
        .PHONY: run
        run:
            go run cmd/project/main.go

        .PHONY: build
        build:
            go build cmd/project/main.cmd

    После чего выполняем команду в консоли и выполним содержимое файла:
        make run            (или make build)
    Для передачи переменной окружения:
        TOKEN=abc make run
    



// GO MOD
    // изначально подразумевается, что проект будет располагаться на гитхабе:
    go mod init github.com/vitalg93/project


// GO MOD TIDY
    установит недостающие зависимости в go.mod



// godotenv - библиотека для работы с переменными окружения



// HTML modules guide:
<!-- 
    {{ if gt .Var 10 }}      |    if Obj.Var>10
    ...
    {{ else }}
    ...
    {{ end }}

    lt <
    gt >
    ne !=
    eq =


    {{ range .Hobbies }}
    <p><b>{{ . }}</b><p>
    {{ end }}
-->

Компиляция:

https://metanit.com/go/tutorial/5.1.php
Данный файл также принадлежит пакету main. Файлов может и быть и больше. 
Теперь скомпилируем из этих файлов программу. Для этого перейдем в консоли к папке проекта и выполним команду:
go build -o main.exe factorial.go main.go
Флаг -o указывает, как будет называться выходной файл - в данном случае main.exe. 
Затем идут все компилируемые файлы. После выполнения этой команды будет создан файл main.exe

Теперь рассмотрим другую ситуацию, когда файлы нашей программы разделены по разным пакетам.
Определим в папке проекта каталог computation. 
Затем в каталог computation добавим следующий файл factorial.go:
	
package computation
 
func Factorial(n int) int {
     
    var result = 1
    for i:=1; i <= n; i++{
        result *= i
    }
    return result
}

Код файла factorial.go принадлежит пакету computation. 
Важно отметить, что название функции начинается с заглавной буквы. 
Благодаря этому данная функция будет видна в других пакетах.


Импорт пакетов в Go
И чтобы использовать функцию factorial, надо импортировать этот пакет в файле main.go:
package main
import (
    "fmt"
    "./computation"
)
 
func main() {
     
    fmt.Println(computation.Factorial(4))
    fmt.Println(computation.Factorial(5))
}

Компиляция и выполнение программы осуществляется также как и ранее без необходимости указания всех файлов из других пакетов:
>go run main.go








.................................................................
.................................................................
............................DATABASE.............................
.................................................................
.................................................................
// example of row adding
result, err := db.Exec("insert into productdb.Products (model, company, price) values (?, ?, ?)", 
        "iPhone X", "Apple", 72000)
if err != nil{
    panic(err)
}
fmt.Println(result.LastInsertId())  // id добавленного объекта
fmt.Println(result.RowsAffected())  // количество затронутых строк






.................................................................
.................................................................
...........................GO TUTORIAL...........................
.................................................................
.................................................................
// ПЕРЕМЕННЫЕ
    // Принятый стиль - camelCase

    // значение по умолчанию
    var num0 int

    // значение при инициализации
    var num1 int = 1

    // пропуск типа
    var num2 = 20

    // короткое объявление переменной (возможно только внутри функции)
    num3 := 0
    num3 += 1
    num3++                      // НО ++num3 - НЕТ В GO

    //объявление нескольких переменных и их инициализация
    var a,b,c = 10, 20, 30

    //  В данном коде объявлено две разные переменные с именем a - одна в глобальной области видимости, и другая - в области видимости функции main.
        Мы определяем и выводим значение переменной, объявленной на уровне функции main
        package main

        import (
            "fmt"
        )

        var a = 3               // OK определяем переменную вне тела функции
        b := 3                  // FAIL - Конструкцию := можно использовать только для объявления переменных в локальной области видимости. 
                                // В глобальной области видимости переменную можно объявить только через var

        func main() {
            a := 4
            fmt.Println(a)      // 4
        }

    // Если инициализатор присутствует, тип можно не указывать;  переменная примет тип инициализатора
    var c, python, java = true, 3.6, "no!"

    // краткое объявление для нескольких переменных возможно, если хотя бы одна из этих переменных - новая
    a, newVAR := 2, 34

    Общая форма объявления переменной в Go
    // var name type = expression
    указанное выше объявление создает переменную определенного типа, 
    придает ему имя и устанавливает его начальное значение. 
    Либо type, либо = expression могут быть опущены, но не оба. Например:
    var x int = 1
    var a int
    var b, c, d = 3.14, "stackoverflow", true

    var i int
    var U, V, W float64
    var k = 0
    var x, y float32 = -1, -2
    var (
        i       int
        u, v, s = 2.0, 3.0, "bar"
    )
    var re, im = complexSqrt(-1)

    := называется short variable declaration, который принимает форму
    name := expression
    Обратите внимание: 
    := является объявлением, тогда как = является присваиванием
    В отличие от обычных объявлений переменных, краткое объявление переменных может
    повторно объявлять переменные при условии, что они были изначально объявлены ранее
    в том же блоке (или списках параметров, если блок является телом функции) с тем же типом 
    и по крайней мере одной из непустых переменных.
    Как следствие, повторное объявление может появиться только в кратком объявлении с 
    несколькими переменными.  Повторное объявление не вводит новую переменную;
    он просто присваивает новое значение оригиналу.

    Краткие объявления переменных могут появляться только внутри функций.  
    В некоторых контекстах, таких как инициализаторы для операторов «if», «for» или «switch»,
    они могут использоваться для объявления локальных временных переменных.

    Правильно:
    func main() {
        c := 0              // аналог   var c = 0     или     var с int = 0
        i, j := 0, 10       // аналог   var c, d = 0, 1
    }

    // 50 оттенков (habr): Неиспользуемые переменные
    package main
    import "fmt"

    var gvar int // not an error

    func main() {  
        var one int   // ошибка, неиспользуемая переменная
        two := 2      // ошибка, неиспользуемая переменная
        var three int // ошибка UNUSED, даже несмотря на присваивание значения 3 в следующей строке
        three = 3

        func(unused string) {	// не ошибка - объявили и не используем
            fmt.Println("Unused arg. No compile error")
        }("what?")
    }

    // 50 оттенков (habr): Случайное сокрытие переменных
    func main() {  
        x := 1
        fmt.Println(x)     // выводит 1
        {
            fmt.Println(x) // выводит 1
            x := 2
            fmt.Println(x) // выводит 2
        }
        fmt.Println(x)     // выводит 1 (плохо, если нужно было 2)
    }

    !!! При делении стоит быть внимательным, так как если в операции участвуют два целых числа,
    то результат деления будет округляться до целого числа, даже если результат присваивается переменной типа float32/float64:
    var m float32 = 10 / 4          // 2
    var m float32 = 10 / 4.0        // 2.5

    math.Trunc(math.Pi)         // 3 - отбрасываем дробную часть



// ТИПЫ ДАННЫХ
    // int - платформозависимый тип, 32/64
    var i int = 10

    // оператор смещения влево — перемещает бит влево на ко-во позиций, заданное в правом операнде
    var bigInt uint64 = 1<<64-1     // 18446744073709551615


    GOLANG                                                   POSTGRES
    uint8  : 0 to 255 
    uint16 : 0 to 65535 
    uint32 : 0 to 4294967295 
    uint64 : 0 to 18446744073709551615 
    int8   : -128 to 127 
    int16  : -32768 to 32767                                 smallserial (2 байта): 1..32767,   smallint=int2 (2 байта): -32768..32767                                    
    int32  : -2147483648 to 2147483647                       serial (4 байта, автоинкр.): 1..2147483647,    integer=int=int4 (4 байта): -2147483648..2147483647
    int64  : -9223372036854775808 to 9223372036854775807     bigserial (8 байта, автоинкр.): 1..9223372036854775807     bigint=int8 (8 байт) -9223372036854775808..9223372036854775807


    bool, int8/uint8 take 1 byte
    int16, uint16 - 2 bytes
    int32, uint32, float32 - 4 bytes
    int64, uint64, float64, pointer - 8 bytes
    string - 16 bytes (2 alignments of 8 bytes)
    any slice takes 24 bytes (3 alignments of 8 bytes). So []bool, [][][]string are the same (do not forget to reread the citation I added in the beginning)
    array of length n takes n * type it takes of bytes.

    // int
    При делении целочисленных типов в Go результат также будет целым числом, а модуль, или остаток, отбрасывается:
        a := 5 / 2
        fmt.Println(a)          // 2

    // float32, float64
        var pi float32 = 3.14
        var e = 2.423
    
    Если при делении используются числовые типы с плавающей точкой, тогда все остальные типы будут автоматически объявляться как 
    числа с плавающей точкой:
        a := 5.0 / 2
        fmt.Println(a)`


    // bool
    var b bool      // false - по умолчанию
    
    // complex64, complex128
    var c complex128 = 1.1 + 7.12i

    // пустая строка по умолчанию
    var str string

    // со спец. символами
    var hello string = "Hi, world \n\t"

    // без спец. символов
    var hello string = `Hi, world \n\t`

    // UTF-8 поддерживается из коробки, можно писать китайские иероглифы
    hi := '钱'

    // одинарные кавычки используются для символов байт (байт - алиас для uint8)
    var rawBinary byte = '\x27'

    // rune (uint32) для utf-8 символов
    var someRune rune = '钱'

    // конкатенация строк (СТРОКИ НЕИЗМЕНЯЕМЫ)
    helloWorld := "Привет, мир"
    andGoodMorning := helloWorld + " и доброе утро"

    // длина строки:
    byteLen := len(andGoodMorning)                      // 45 байт
    // если строка содержит символы UTF-8, то один символ может занимать более одного байта. Тогда для подсчета количества символов:
    symbols := utf8.RuneCountInString(andGoodMorning)   // 25 символов - длина строки в рунах

    // Константы
    const pi = 3.14
    
    const (
        hello = "привет"
        e = 2.7
    )
    
    const (
        zero = iota         // iota - автоинкремент для констант
        _                   // пустая константа 2, пропуск iota
        three               // 3
    )

    const (
        _   = iota                              // пропускаем первое значение
        KB uint64 = 1 << (10 * iota)            // 1024
        MB                                      // 1048576
    )

    const (
        a = iota                // 0
        b = iota * 2            // 2
        c                       // 4
        d                       // 6
    )

    // iota - Счетчик, начинающийся с нуля, Увеличивается на 1 после каждой строки, Используется только с постоянным
    
    const (
        // нетипизированная константа
        year = 2017
        // типизированная константа
        yearTyped int = 2017
    )

    func main(){
        var month int32 = 13
        fmt.Println(month + year)       // ok
        fmt.Println(month + year)       // разные типы - int32 и int - ошибка
    }


    // Определение собственного типа
    type UserID int
    
    func main(){
        idx := 1
        var uid UserID = 42
        
        uid = idx   // Ошибка!! - cannot use idx (type int) as type UserID in assignment
        
        myID := UserID(idx)     // Приведение типов
        
        // разные типы не совместимы idx - int, 
    }

    // Указатели - тип данных
    d := new(int)       // *d == 0 - заполнит нулем

    !! Была такая ошибка: s.sortByMonth - всегда false (значение по умолчанию).
        s.sortByMonth = *flag.Bool("M", false, "Makes sort by month")
        flag.Parse()
    // Дело в том, что в s.sortByMonth сразу разыменовали значение адреса памяти flag.Bool, которое всегда false до выполнения
    // flag.Parse(), который может поменять значение bool по адресу на true. Вывод: не разыменовывать указатели, если они могут 
    // меняться в рантайме!!!

    все указатели имеют одинаковый размер памяти и представление, которое составляет 4 или 8 байт, представляющих адрес. 
    На 32-битных архитектурах указателям требуется 4 байта памяти, 
    а на 64-битных архитектурах им требуется 8 байт памяти.


            // FAQ task21 WB-L1:
            /*
                // определяем сущности: кардридер, карта памяти и компьютер
                MyCardReader := CardReader{}
                // определяем объем карты в "конструкторе"
                MyMemoryCard := NewMemoryCard(64)
                MyComputer := Computer{}

                // подключаем к компьютеру кардридер через USB
                MyComputer.ConnectUSBDevice(MyCardReader)           // тут ошибка, нужен указатель на MyCardReader
                // вставляем карту памяти в кардридер
                MyCardReader.InsertMemoryCard(MyMemoryCard)
                // передаем данные на карту памяти
                MyComputer.SendDataToUSBDevice()

                Важное замечание по багу (исправлен):
                1 шаг: инициализация ПК, карты памяти и кардридера (объекты)
                подключаем к компьютеру кардридер (передаем как значение, а не как указатель !!!)
                    MyComputer.ConnectUSBDevice(MyCardReader)

                2 шаг: подключение карты памяти в кардридер. Здесь передается по ссылке на созданный объект
                    MyCardReader.InsertMemoryCard(&MyMemoryCard)

                3 шаг: отправляем данные с компьютера: тогда при передаче данных на карту памяти произойдет ошибка.
                Это так, потому что на шаге 1 передали копию КардРидера, без подключения карты памяти. Соответственно,
                при записи произойдет паника. Решение: необходимо передавать КардРидер по ссылке, поскольку
                внешнее изменение его состояния отразится в объекте Компьютер
            */

    // указатели: Указатель содержит адрес памяти значения. Тип * T - это указатель на значение T.
    var p *int
    // Оператор & генерирует указатель на свой операнд.
    i := 42
    p = &i
    fmt.Println(*p)     // 42, а само значение p может быть, например, 0xc000018030
    *p = 21             // set i through the pointer - *p привязано по адресу к i,
    fmt.Println(i)      // see the new value of i - соответственно, i равно 21

    s := make([]int, 20) // Выделение единого блока памяти под 20 int-ов.
    s[3] = 7             // Присвоить значение одному из них.

    answer := 42
    fmt.Println(&answer)        // 0xc000001232 - указатель (оператор адреса)

    // adress - Указатель типа *int
    address := &answer
    fmt.Println(*address)       // 42

    fmt.Printf("address это %T\n", address)

    // Звездочка в *int значит, что это тип указателя. В данном случае он может указать на другую переменную типа int.
    canada := "Canada"
    
    var home *string
    fmt.Printf("home is a %T\n", home) // Выводит:  home is a *string
    
    home = &canada
    // Звездочка перед типом обозначает тип указателя,
    // а звездочка перед названием переменной нужна для указания на значение, к которому отсылается указатель.
    fmt.Println(*home) // Выводит: Canada

    Example:
        result = new(int)

    is equivalent to:
        var temp int   // declare an int type variable
        var result *int //  declare a pointer to int
        result = &temp 

    
    // Конвертация типов данных
        var index int8 = 15
        var bigIndex int32
        bigIndex = int32(index)

        Обратите внимание, что при преобразовании целых чисел может быть превышено максимальное значение для данного типа данных и выполняется перенос:
        var big int64 = 129
        var little = int8(big)
        fmt.Println(little)             // -127

        var x int64 = 57
        var y float64 = float64(x)

        var f float64 = 390.8
        var i int = int(f)

        Строки в Go хранятся как срезы байтов. В Go вы можете преобразовывать срезы байтов в строки и обратно, используя соответствующую 
        конвертацию в []byte() и string()
            a := "my string"
            b := []byte(a)
            c := string(b)


        (!) Конвертация структур
            type Point struct {
                X, Y int
            }

            type AnotherPoint struct {
                X, Y int
            }

            func main() {
                var p Point

                if p == (AnotherPoint{}) {          // ошибка компиляции - сравнение разных типов
                                                    // решение: преобразовать тип и сравнить их
                                                    //  if p == Point(AnotherPoint{}) { ... }
                    fmt.Println("true")
                } else {
                    fmt.Println("false")
                }
            }





// ПЕРЕМЕННЫЕ, СОСТАВНЫЕ ТИПЫ ДАННЫХ

    // Нулевые значения (по умолчанию для всех типов Go) (ZERO VALUES)
        Переменные, объявленные без начального значения, устанавливаются в их нулевые значения:
            0 - для всех целочисленных типов,
            0.0 - для чисел с плавающей запятой,
            false - для логических значений (bool),
            "" - для строк,
            nil - для интерфейсов, срезов, каналов, карт, указателей и функций.
            для структуры нулевое значение - структура со значением полей по умолчанию для вышеперечисленных типов



    // МАССИВ - набор данных одного типа. Массивы разной длины имеют разные типы (Например, [1]int и [2]int - разные типы)
        // Объявление
            var a [0]int            // [0]int{},        с nil сравнивать нельзя, len=cap=0
	        a := new([2]int)        // &[2]int{0, 0},   с nil сравнивать нельзя, len=cap=0
            
        (!) можно ссылаться на элемент массива (как и на элемент слайса, но не на элемент МАПЫ)
            l := &a[0]          // при условии, что index > len(a)
        
        // Инициализация значениями по умолчанию
        var a [3]int    // [0,0,0] - нулевое значение массива - массив нулей
        fmt.Printf("a short %v\n", a)
        fmt.Printf("a full %#v\n", a)

        len(a) = cap(a) = длина массива

        (!) массив нельзя сравнивать с nil
            a := [2]int{0, 0}

            if a == nil {                           // ошибка! код не скомпилируется. Нельзя сравнивать массивы с nil
                fmt.Println("true")
            } else {
                fmt.Println("false")
            }

        (!!!) массивы копируются во время присваивания к новым переменным или передачи к функциям или методам. 
        То же самое верное в отношении примитивных типов вроде int или float64.
        В Go нет такой вещи, как передача по ссылке, вместо этого все передается по значению. Если вы хотите передать 
        лишь «ссылку» на массив, используйте указатели.

        Массив хранится в виде последовательности из n блоков определенного типа.

        // В Go Программа может получить доступ к отдельным символам, но не может редактировать саму строку.
        hugeString := "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
        justString := hugeString[0:10]                                    // s = Lorem ipsu
        fmt.Printf("type s is %T, len=%d\n", justString, len(justString)) // type s is string, len=10
        hugeString = "New value of string"                                // изменим исходную строку
        fmt.Println(justString)                                           // s - не изменится, s = "Lorem ipsu"
        
        const size = 2
        var a1[2] string
        var a2[2 * size] bool
        
        var sizeNew := 3
        var a3[sizeNew] string  // ошибка - sizeNew - переменная! А должна быть константа или числовой литерал
        
        // определение размера при объявлении
        a4 := [...]int{1,3,65,7}

        // отличие массива от среза
        a := [...]int{1,2,3,4,5,6,7,8}     // массив
        b := [8]int{1,2,3,4,5,6,7,8}       // массив
        c := []int{1,2,3,4,5,6,7,8}        // срез


        (!) Что выведет код?
            a := [2]int{0, 0}                   // заполнение нулями в данном случае эквивалентно записи a := [2]int{} или a := [2]int{0} 

            if a == [2]int{} {
                fmt.Println("true")             // ответ: true, т.к. Массивы сравниваются по значению.  (!)
                                                // В конструкции [2]int{} необъявленные элементы заполняются нулями. 
                                                // Т.е. [2]int{0}, [2]int{0, 0} и [2]int{} - это одно и то же.
            } else {
                fmt.Println("false")
            }

        (!) Массив может иметь нулевой размер. Это вполне допустимая ситуация:
            a := [0]int{}
            fmt.Println(a)          // []






    // СРЕЗЫ (СЛАЙСЫ): подмножество массива (Срезы можно рассматривать как расширенную реализацию массивов.). 
        Слайс = ссылка! на исходные данные (можно изменять, передавая в функции)
        Слайс - это дескриптор сегмента массива (содержат однородные данные, под капотом - ссылаются на массив). 
        Слайс состоит из: 
            -указателя на базовый массив (на последовательность данных), 
            -длины сегмента (сколько сейчас элементов в срезе) 
            -его емкости (максимальной длины сегмента, общее количество представленных ячеек памяти).

        Из этого следует, что срезы разной длины можно присваивать друг другу. 
        Они имеют один и тот же тип, а указатель, длина и объем могут меняться.

        Слайсы расширяются через append, при расширении может произойти реаллокация - создание нового базового массива
        с удвоенной емкостью относительно расширяемого.
        Оценка сложности при добавлении элемента с реаллокацией - линейная, при добавлении элемента без реаллокации - константная.

        Срез, в отличии от массива, не выделяет память во время инициализации.
        Фактически, срезы инициализируется с нулевым (nil) значением.
        
        (!) Что выведет код?
            a := []int{}

            if a == nil {
                fmt.Println("true")
            } else {
                fmt.Println("false")                // ответ - false: Слайс (в отличие от массивов) можно сравнить с nil. (!!!!!!!!!!!!!) 
                                                    // СЛАЙСЫ (как и мапы) МОЖНО СРАВНИВАТЬ ТОЛЬКО С nil
                                                    // Однако []int{} - это не nil-слайс, а просто пустой слайс. Поэтому он не равен nil,
                                                    // хотя в остальном он ведет себя абсолютно аналогично.
            }

        (!) Что выведет код?
            func main() {
                a := []int{}
                a = append(a, 1)
                a = append(a, 2)
                a = append(a, 3)
                add(a)                  // Вместимость слайса при передаче в функцию add равна 4 при длине 3.
                fmt.Println(a)          // 1 2 3
            }

            func add(a []int) {
                a = append(a, 4)        // При попытке добавления в конец слайса не происходит реаллокации слайса. 
                                        // Поэтому мы записываем 4 в конец массива, на который ссылается исходный слайс a.
            
                // НО! слайс состоит из ссылки на адрес памяти, а также len и cap. После выхода из функции add уничтожается 
                // копия слайса a с длиной 4.
            }
        
        Как итог, в значении a остается слайс с длиной 3 и вместимостью 4. Несмотря на то, что функция add поменяла 
        четвертый элемент массива, на который ссылается слайс a, на 4, будут выведены только первый три значения

        (!) Пример с изменением исходного массива
        func main() {
            arr := [3]int{1, 2, 3}      // массив из 3х элементов
            a := arr[:2]                // слайс [1 2] длины 2, емкость 3
            add(a)
            fmt.Println(a, len(a), cap(a))          // a - не изменился, т.к. в функцию передали копию a, которая изменилась и удалилась.
                                                    // len(a), cap(a) - не изменились.
            fmt.Println(arr, len(arr), cap(arr))    // arr - изменился [1 2 4], поскольку копия a ссылается на ту же область памяти (arr)
                                                    // переаллокации arr не произошло - хватило вместимости, следовательно значение
                                                    // arr[3] изменилось с 3 на 4. Переаллоакция привела бы к тому, что arr - не изменился бы,
                                                    // поскольку в функции выделился новый базовый массив для слайса после append()
        }

        func add(a []int) {
            a = append(a, 4)
        }

        (!) можно ссылаться на элемент слайса (как и на элемент массива, но не на элемент МАПЫ)
            l := &a[0]          // при условии, что index > len(a)

        (!) Слайсы можно сравнивать ТОЛЬКО с nil:
            func main() {
                a := []int{}

                if a == []int{} {                       // Сравнивать слайсы друг с другом - недопустимая операция (!!!!!!!!)
                    fmt.Println("true")
                } else {
                    fmt.Println("false")
                }
            }


        (!) var s []int - длина 0, емкость 0. В него можно добавлять элементы сразу, не используя make()
            
            var a []int                 // zero-value для слайса []int является nil.
            a = append(a, 1)            // nil ведет себя ровно так же, как и слайс нулевой длины. В частности, к нему можно без ошибок добавлять элементы функцией append
            fmt.Println(a)  


            var a []int             //  []int(nil)  == nil !!! len==cap==0
            a := []int{}            //  []int{}     != nil !!! len==cap==0
            a := &[]int{}           //  &[]int{}    != nil !!! len==cap==0
            a := new([]int)         //  &[]int(nil) != nil !!! len==cap==0
            a := make([]int, 0)     //  []int{}     != nil !!! len==cap==0          - через make - обязательно нужно указать параметр len

        Длина нулевого среза, карты или канала равна 0. Емкость нулевого среза или канала равна 0.

        (!) В чем преимущество создания среза через make?
            Предварительное выделение через make может установить начальную вместимость, тем самым можно избежать дополнительных перемещений и копий 
            для увеличения базового массива.

        (!) Возвращаемый из функции срез []byte указывает на массив, содержащий файл целиком. 
            Так как слайс ссылается на исходный массив, пока слайс есть в памяти, сборщик мусора не сможет очистить массив; несколько важных 
            байтов файла держат всё содержимое в памяти. Чтобы исправить это, можно скопировать интересующие нас данные в новый слайс до того,
            как вернуть значение.

                func CopyDigits(filename string) []byte {
                    b, _ := ioutil.ReadFile(filename)
                    b = digitRegexp.Find(b)
                    c := make([]byte, len(b))
                    copy(c, b)
                    return c
                }

        (!) Нулевое значение для среза не совпадает с инициализированным, но пустым срезом (аналогично для карты):   
            p1 := &[]int{}    // p1 points to an initialized, empty slice with value []int{} and length 0
            p2 := new([]int)  // p2 points to an uninitialized slice with value nil and length 0

        (!) Удвоение размера слайса, если исходный массив, на который ссылается слайс, переполнен
            s := make([]int, 0, 3)
            for i := 0; i < 5; i++ {
                s = append(s, i)
                fmt.Printf("cap %v, len %v, %p\n", cap(s), len(s), s)
            }

            cap 3, len 1, 0xc000016018
            cap 3, len 2, 0xc000016018
            cap 3, len 3, 0xc000016018      // заполнили полностью
            cap 6, len 4, 0xc000078030      // увеличение capacity (объема) массива в два раза (выделение новой области памяти)
            cap 6, len 5, 0xc000078030

        (!) Искусственная переаллокация памяти среза при добавлении нового элемента - уменьшение capacity до длины среза:
                бывает, что срез необходимо дополнить новым элементом, не потерев ячейку памяти массива, на который ссылается срез.
                чтобы создать срез, который нужно дополнить, и не затереть элемент массива, необходимо использовать третий параметр 
                max при создании среза, равный параметру high. 


            numbers  := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}               // для массива cap(array)=len(array)
            Слайс s1 := numbers[low:high:max]
                low - индекс элемента базового массива, с которого начинать срез
                high - индекс элемента базового массива, которым заканчивать срез (не включается в новый слайс)
                max - устанавливает новую емкость результата - максимальный индекс слайса, из которого рассчитывается capacity нового слайса

            Когда опущено значение low в синтаксисе слайса, вместо него берется 0.
            Когда опущено значение high в синтаксисе слайса, вместо него берется длина массива/слайса.

            len(slice) = high - low
            cap(slice) = max - low                        !!!!
            low <= high <= max <= cap(array_or_slice)     // т.е. можно создать пустой срез так s := numbers[4:4:4] - (длина = 0, емкость = 0)

            третий параметр в слайсе (max) - определяет элемент, с которого рассчитывать capacity. Необходим для уменьшения вместимости исходного массива
            s := []int{1, 2, 3, 4}          // [0 0 0 0] - длина 4 и capacity 4
            s1 := s[:2]                     // [1 2] - длина 2 и capacity 4 (capacity как и у базового массива)   
            s2 := s[:2:2]                   // [1 2] - длина 2 и capacity 2 (урезанная capacity) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        

        primes := [6]int{2, 3, 5, 7, 11, 13}    // МАССИВ
        var s []int = primes[1:4]               // СРЕЗ МАССИВА [3 5 7]
        s[0] = 1234

        primes := [6]int{2, 3, 5, 7, 11, 13} // МАССИВ
        var s1 []int = primes[1:4]           // СРЕЗ МАССИВА [3 5 7]
        s1[0] = 1234                         // Изменяем значение среза - изменяем значение массива (!)
        fmt.Println(primes)                  // primes = [2 1234 5 7 11 13]

        primes[2] = 99
        fmt.Println(s1)       // s1 = [1234 99 7] - изменяем значение массива - изменяем значение среза от этого массива
        
        var s2 []int = s1[:2] //
        fmt.Println(s2)       // s2 =[1234 99] - срез от среза
        s2[0] = 1             // изменяя срез от среза, изменения отразятся на исходном срезе и массиве
        fmt.Println(primes)   // primes = [2 1 99 7 11 13]
        fmt.Println(s1)       // s1 = [1 99 7]
        fmt.Println(s2)       // s2 = [1 99]

        (!) Что выведет код?
            func main() {
                a := []int{}
                a = append(a, 1)
                a = append(a, 2)
                a = append(a, 3)
                add(a)
                fmt.Println(a)             // Ответ: [1 2 3]
            }

            func add(a []int) {
                a = append(a, 4)
            }

            // Вместимость слайса при передаче в функцию add равна 4 при длине 3. При попытке добавления в конец слайса не происходит 
            реаллокации слайса. Поэтому мы записываем 4 в конец массива, на который ссылается исходный слайс a. Но как мы помним, слайс 
            состоит из ссылки на адрес памяти, а также len и cap. После выхода из функции add уничтожается копия слайса a с длиной 4.
            Как итог, в значении a остается слайс с длиной 3 и вместимостью 4. Несмотря на то, что функция add поменяла четвертый элемент 
            массива, на который ссылается слайс a, на 4, будут выведены только первый три значения
            
            Но, в следующем примере функция add добавит значение к слайсу, которое сохранится в базовом массиве:
                func main() {
                    aa := [4]int{1, 2, 3}           // массив, не слайс
                    add(aa[:3])                     // передаем слайс, ссылающийся на базовый массив аа 
                    fmt.Println(aa)                 // [1 2 3 4]
                }

                func add(a []int) {
                    a = append(a, 4)
                }


                // 50 оттенков (habr): можем менять в функции, передавая слайс как параметр.
                func main() {  
                    x := []int{1,2,3}

                    func(arr []int) {
                        arr[0] = 7
                        fmt.Println(arr) // выводит [7 2 3]
                    }(x)

                    fmt.Println(x) // выводит [7 2 3]
                }

                Срез можно рассматривать как ссылку на массив. В Go размер каждого массива фиксирован, и размер не может быть изменен
                произвольно. Срезы могут обеспечивать требования к динамическому росту и сжатию для массивов, но они не хранят никаких данных.

                /*
                * Это объявление массива
                */
                var a [5]int                // Указываем только длину, массив инициализируется значением по умолчанию 0
                var a [5]int{1,2,3,4,5}
                
                /* 
                * Это объявление среза: объявить массив без длины
                */
                // Метод 1: прямая инициализация
                var s []int                // Объявить нулевой срез с длиной и емкостью 0
                var s []int {1,2,3,4,5}    // Создаем массив длиной 5 одновременно

                // Метод 2: Используйте функцию make () для создания среза: var имя переменной = make ([] тип переменной, длина, емкость)
                var s = make([]int, 0, 5)

                // Разделение массива: var имя переменной [] тип переменной = arr [low, high], low и high - это индексы массива.
                var arr = [5]int{1,2,3,4,5}
                var slice []int = arr[1:4] // [2,3,4]

                Длина среза - это количество содержащихся в нем элементов.
                Емкость среза - это число от его первого элемента до конца нижележащего элемента массива.
                Длина и емкость среза s могут быть выражены какlen(s) с участием cap(s) Чтобы получить это.


                // Срез не хранит никаких данных, он просто описывает раздел базового массива.
                // Другие срезы, которые используют тот же базовый массив, увидят эти изменения.
                // Изменение элементов среза изменяет соответствующие элементы его базового массива!!!


                s1 := []int{1,2,3,4,5,6}
                // цикл по слайсу - вариант 1 (не удобный)
                idx := 0
                for idx < len(s1) {
                    fmt.Println(idx, s1[idx])
                    idx++
                }

                // цикл по слайсу - вариант 2 (цикл с инициализацией и условием - объявляем индекс, условие и автоинкремент)
                for i:=0; i<len(s1); i++ {
                    fmt.Println(s1[i])
                }

                // цикл по слайсу c range - вариант 3.1
                for idx := range(s1) {
                    fmt.Println(s1[idx])
                }

                // цикл по слайсу c range - вариант 3.2
                for idx, val := range(s1) {
                    fmt.Println(val, idx)
                }

                var a [10]int
                // срезы, эквивалентные a:
                a[0:10]
                a[:10]
                a[0:]
                a[:]

                a = a[:4]       // len 4, cap 10 - срез 
                len(a)          // 10  Длина среза - это количество содержащихся в нем элементов. 
                cap(a)          // 10 Емкость среза - это количество элементов в базовом массиве, считая от первого элемента в срезе.

                buf := []int{1,2,3,4,5}
                newBuf := buf[:]
                
                // при добавлении в newBuf еще одного элемента СЛАЙС ДОЛЖЕН РАСШИРИТЬСЯ ВДВОЕ (capacity - удвоится)
                newBuf = append(newBuf, 6)      // len(newBuf) == 6, cap(newBuf) == 10 (5*2=10)
                
                // тогда создастся другая область памяти и туда скопируется срез newBuf (БУДЕТ ССЫЛАТЬСЯ НА ДРУГУЮ ОБЛАСТЬ ПАМЯТИ)
                // ТАКИМ ОБРАЗОМ, ПРИ ИЗМЕНЕНИИ newBuf:
                newBuf[0] = 1000    // !!!ИЗМЕНЕНИЯ В БАЗОВОМ МАССИВЕ buf НЕ ПРОИЗОЙДУТ: buf == [1,2,3,4,5], newBuf = [1000,2,3,4,5,6]
                
                // добавление другого слайса
                otherBuf := make([]int, 3)      // Функция make выделяет обнуленный массив и возвращает slice, который ссылается на этот массив.
                buf = append(buf, otherBuf...)
                
                // Копирование
                buf := []int{1, 2, 3, 4, 5, 6}
                var emptyBuf []int              // len 0, cap 0
                
                // НЕПРАВИЛЬНОЕ КОПИРОВАНИЕ
                copied := copy(emptyBuf, buf)   // при копированиии в слайс длины 0 - ничего не скопируется
                fmt.Println(copied, emptyBuf)   // 0 []
                
                // ПРАВИЛЬНОЕ КОПИРОВАНИЕ
                newBuf := make([]int, len(buf))
                copied1 := copy(newBuf, buf)
                fmt.Println(copied1, newBuf)    // 6 [1 2 3 4 5 6]

                // можно копировать в часть существующего слайса
                ints = []int{1,2,3,4}
                copy(ints[1:3], []int{5,6})     // ints = [1,5,6,4]

                !! Нулевое значение среза равно nil
                var s []int
                fmt.Println(s, len(s), cap(s))      // [] 0 0 
                if s == nil {
                    fmt.Println("nil!")             // напечатает nil
                }

                // Создание матрицы:
                    package main

                    import "fmt"

                    func main() {  
                        x := 2
                        y := 4

                        table := make([][]int,x)
                        for i:= range table {
                            table[i] = make([]int,y)
                        }
                        fmt.Println(table)              // [[0 0 0 0] [0 0 0 0]]
                    }












    // MAP (КАРТЫ) - хеш-таблица, отображение, ассоциативный массив. Map позволяет по ключу быстро получить значение
        В качестве ключа может выступать любая сравниваемая структура данных.
        Ключи в Мапе лежат В СЛУЧАЙНОМ ПОРЯДКЕ
        Если ключа в Мапе нет - вернет значение по умолчанию (например, для map[string]int вернет 0)
        
        Ключами в мапе могут быть любые сравниваемые типы — все простые скалярные типы, каналы, массивы.
        Несравниваемые типы — срезы, мапы, функции.

        Ключи и значения мапы будут храниться в выделенном участке памяти, последовательно. Для получения адресов 
        ячеек конкретных ключей и значений, удобно использовать хэширующую функцию.

        Для применения в данной задаче, к хэш-функциям есть следующие требования:
            -Детерминированность — функция должна вернуть одно и то же значение от одного и того же ключа;
            -Равномерность — должны выдавать значения которые можно было каким-либо образом равномерно распределить в некотором множестве;
            -Скорость — вычисляться быстро, т.к. используются часто;

        Одним из полей структуры мапы является
            unsafe.Pointer — указатель на данные любого типа
            это способ разработчиков GO уйти от проблемы джереников (реализовать функционал мапы с различными типами ключей и значений).

    (!) Для карт make принимает один или два параметра. Второй предварительно обозначает место для количества ключей, что напоминает вместимость срезов. 
        При использовании make начальная длина карты всегда будет нулевой:
            temperature := make(map[float64]int, 8)             // пустая карта длины 0, map[float64]int{} != nil

    (!) Нулевая карта и пустая карта
        	m := &map[string]int{}              // пустая карта, &map[string]int{} != nil

            m1 := new(map[string]int)           // nil карта, &map[string]int(nil) != nil

            ff := map[string]int{}              // пустая карта, map[string]int{} != nil

            b := make(map[int]bool, 0)          // пустая карта, map[int]bool{} != nil

            var d map[string]int                // nil карта, map[string]int(nil) == nil !!!!!!!!!!

            // срез для примера
            var dd []int                        // nil срез, []int(nil) == nil !!!!!!!!!!


    (!) Нулевая карта (nil map) ведет себя как пустая карта при чтении, но попытки записи в нулевую карту вызовут панику во время выполнения (runtime panic):
        var d map[string]int                    // OK - объявили, но не инициализировали
        fmt.Printf("%#v\n", d)                  // map[string]int(nil)
        fmt.Println(len(d), d["1"])             // OK можем осуществлять поиск в nil-мапе - если элемент отсутствует, возвращается значение по умолчанию !!!!!!!!!!!!
                                                // Попытка чтения из nil-map - вполне допустимая операция. При этом будет прочитано zero-value типа int - 0. !!!!!!!!
        d["2"]=2                                // FAIL - не можем добавлять элемент в nil-мапу (panic: assignment to entry in nil map)

    (!) в силу структуры мапы под капотом, невозможно взять указатель на элемент мапы:
        c := &d["1"]                            // FAIL 
        указатель на область памяти будет меняться, поскольку при расширении мапы она выделит новые бакеты (?) в другой области памяти и этот
        указатель будет некорректным (устаревшим)

     (!) Карты небезопасны для одновременного использования: не определено, что происходит, когда вы читаете и записываете
      в них одновременно.  Если вам нужно читать и записывать на карту из параллельно выполняющихся горутин, доступ должен
      быть опосредован каким-то механизмом синхронизации.  Один из распространенных способов защиты карт - это sync.RWMutex.
        
     (!) Карта обеспечивает операции поиска, вставки и удаления за O(1) ожидаемое амортизированное время.
            
            Инициализация карты: 
                1) с помощью make():
                    m = make(map[string]int)
                    m["a"] = 1
                    key, ok := m["b"]
                    fmt.Printf("%#v %#v\n", key, ok)	// 0 false
                
                2) вы можете создать карту с помощью одного оператора (называемого составным литералом в спецификации):
                    var keys = map[int]string{
                        1: "aa",
                    }


        (!) Типы карт (map) являются ссылочными типами, такими как указатели или срезы (slice), 
            и поэтому значение m выше равно nil; оно не указывает на инициализированную карту
            Это значит, можно определять функции, которые возвращают не *map[T]T, а map[T]T

        (!) Структура как ключ карты (работает)
                type gg struct {
                    g int
                }

                func main() {
                    var aa map[gg]int = make(map[gg]int)
                    aa[gg{g: 1}] = 1
                    aa[gg{g: 2}] = 2

                    fmt.Println(aa, aa[gg{1}])          // map[{1}:1 {2}:2] 1
                    return
                }



    func createSet(arr []int) map[int]bool {
        set := make(map[int]bool)
        for _, val := range arr {
            set[val] = true
        }
        return set
    }


    // Инициализация при создании
    var user map[string]string = map[string]string{
        "name": "Vasiliy",
        "lastName": "Romanov",
    }

    // 50 оттенков (habr): Важно инициалиировать карту:
    var m map[string]int
    m["one"] = 1                // !!! ошибка runtime panic

    Нулевая карта (nil map) ведет себя как пустая карта при чтении, но попытки записи в нулевую карту вызовут панику во время выполнения
    (runtime panic). Чтобы инициализировать карту, используйте встроенную функцию make
    // сразу с нужной емкостью
    profile := make(map[string]string, 10)

    // 50 оттенков (habr): Ёмкость хеш-таблиц: Можно устанавливать ёмкость при создании хеш-таблиц, но нельзя применять к ним функцию cap()
    func main() {  
        m := make(map[string]int, 99)        // в отличие от make(слайс), make(map) может содержать только один параметр (длины и емкости нет, есть емкость) 
        fmt.Println(cap(m))                  // ошибка
        fmt.Println(len(m))                  // НО len(m) - не ошибка
    }

    // Удаление по ключу из карты
    delete(map, "key")
    
    Встроенная функция delete удаляет элемент с ключом k из карты m. Тип k должен быть назначаемым (assignable) типу ключа m.
        delete(m, k)  //  удалить элемент m[k] из карты m
    Если карта m равна nil или элемент m[k] не существует, delete не производит действий.

    profile := map[int]string{1:"Test1", 2:"Test2"}
    // Итерации по карте:
    // только по ключам
    for key := range profile {
        fmt.Println(key)
    }

    // или по ключам и по значению
    for key, val := range profile {
        fmt.Println(key, val)
    }

    // или так: 
    for _, val := range profile {
        fmt.Println(val)
    }

    // проверка на существование ключа:
    name, isNameExist := user["middleName"]     // isNameExist - bool

    /*Пример кода динамического списка (карты)*/ https://golang-blog.blogspot.com/2020/01/map-golang.html
    type Node struct {
        Next  *Node
        Value interface{}
    }
    var first *Node

    visited := make(map[*Node]bool)
    for n := first; n != nil; n = n.Next {
        if visited[n] {
            fmt.Println("cycle detected")
            break
        }
        visited[n] = true
        fmt.Println(n.Value)
    }



// УПРАВЛЯЮЩИЕ КОНСТРУКЦИИ
    // условие с блоком инициализации
    if a := foo(); a > 10 {
        b := a / 2
    }

    // множественные if else:
    if cond == 1 {
        fmt.Println("cond is 1")
    } else if cond == 2{
        fmt.Println("cond is 2")
    }

    // SWITCH CASE. Для перехода к следующему кейсу (без проверки условия в case) можно использовать ключевое слово fallthrough.
    strVal := "name"
    switch strVal {                         // switch c параметром
        case "name":
            fallthrough                             //!!! необходимо, чтобы провалиться в следующее условие без проверки условия следующей ветки
        case "test", "lastName":                    // можно указать сразу несколько условий через запятую
            // some code
        case foo(strVal) > 1 || bar (strVal) < 10:  // несколько условий через логический оператор
            // some code
        default:
            // some code
    }

    switch {                                // switch без параметра
        case a == 1 || a < 0 :
            // some code
            fallthrough                     // оператор, передающий управление в следующую ветку без проверки условия следующей ветки
        case b = 0:
            // some code        
        default:
            // some code
    }
    
    // пример (выведет 1 2):
        switch 1 {
            case 1:
                fmt.Println(1)
            case 2:
                fmt.Println(2)
        }

    // Пример (выведет: 1 2) 
        switch 1 {
            case 1:
                fmt.Println(1)
                fallthrough                 // тут можно использовать - можем провалиться ниже
            case 2:
                fmt.Println(2)
                fallthrough                 // а тут - нельзя - ошибка!! cannot fallthrough final case in switch
        }


    // SWITCH без выражения (эквивалентно switch true) - Эту форму можно использовать вместо многострочных операторов if/else для сокращения кода.
    switch {
    case now.Hour() < 12:
        fmt.Println("AM")

    default:
        fmt.Println("PM")
    }

    // МЕТКА (см. команду break Loop - завершить внешний цикл, а не SWITCH)
        func main() {
            fmt.Println(1)
            goto End
            fmt.Println(2)
        End:
            fmt.Println(3)
        }
        Вывод:
            // 1
            // 3


    // пример:
    Loop:
        for key, val := range mapVal {
            switch {
                case key == "lastName":
                    break
                    println("dont print this")
                case key == "firstName" && val == "Vasiliy":
                    println("switch - break loop there")
                    break Loop                                  // прерываем и switch и for (!). Аналогично можно использовать break <метка>
                                                                // для выхода из вложенных for-циклов
            }
        }

        outer:
            for i:=0; i<10; i++ {
                for j:=0; j<10; j++ {
                    fmt.Println(i, j)
                    // continue outer                       # выведет "0 0", "1 0", "2 0" - т.е. внутренний цикл будет выполнять тело один раз и переходить снова к внешнему циклу
                    // break                                # остановит выполнение внутреннего цикла. В данном случае - break аналогичен continue outer
                    // break outer                          # выведет "0 0" и завершит выполнение внешнего цикла
                }
            }

        Область видимости метки - это тело функции, в которой она объявлена, и исключает тело любой вложенной функции.
        ЗАПРЕЩЕНО:
                func() {
                    fmt.Println(“Nested function”)
                    goto End
                }()
            End:

        ! метки не конфликтуют с переменными идентификаторами:
        МОЖНО:
            x := 1
                goto x
            x:
                fmt.Println(x)

        


    // ЦИКЛЫ
        (!) Вместо использования новой переменной на каждой итерации цикла, Go переиспользует ту же самую

        // цикл, инвертирующий слайс без использования вспомогательного слайса
		for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {
			words[i], words[j] = words[j], words[i]
		}
	

        // цикл с условием и блоком инициализации
        sum := 0
        for i := 0; i < 10; i++ {
            if i == 1 {
                continue
            }
            sum += i
        }
        fmt.Println(sum)    

        // цикл без условия 
        for {
            fmt.Println("1")
            break
        }

        // цикл без условия 2
        isRun := true
        for isRun {
            fmt.Println("1")
            isRun = false
        }
        
        // Операторы init и post необязательны
        for ; sum < 1000; {
            sum += sum
        }
        fmt.Println(sum)    // 1024

        // Цикл while определяется через for:
        sum := 1
        for sum < 1000 {
            sum += sum
        }
        fmt.Println(sum)    // 1024

        // бесконечный цикл
        for {
            }

    
        // Циклы по строке (СТРОКА = СЛАЙС БАЙТов)
        s := "Hello 钱 мир!"
        for pos, char := range s {
            fmt.Printf("%#U at pos %d\n", char, pos)
        }

        // вывод:
        U+0048 'H' at pos 0
        U+0065 'e' at pos 1
        U+006C 'l' at pos 2
        U+006C 'l' at pos 3
        U+006F 'o' at pos 4
        U+0020 ' ' at pos 5         // pos4-pos5 - 1 символ - 1 байт (позиция)
        U+94B1 '钱' at pos 6        // pos6-pos9 - 1 иероглиф - 3 позиции
        U+0020 ' ' at pos 9         
        U+043C 'м' at pos 10        // pos10-pos12 - 1 русская буква - 2 позиции 
        U+0438 'и' at pos 12
        U+0440 'р' at pos 14
        U+0021 '!' at pos 16



    // область видимости
        // Как и for, оператор if может начинаться с короткого оператора, который выполняется перед условием.
        // Переменные, объявленные оператором, находятся в области видимости только до конца if.
        func pow(x, n, lim float64) float64 {
            if v := math.Pow(x, n); v < lim {
                return v
            }
            return lim
        }

        // оператор switch. Выражение os := "test"; вычисляется внутри switch
        switch os := "test"; os {
            case "test":
                fmt.Println("1")
            case "linux":
                fmt.Println("Linux.")
            default:
                fmt.Printf("default")
        }

        // switch без условия - это то же самое, что и переключатель true
        t := time.Now()
        switch {
            case t.Hour() < 12:
                fmt.Println("Good morning!")
            case t.Hour() < 17:
                fmt.Println("Good afternoon.")
            default:
                fmt.Println("Good evening.")
        }   



    // BREAK
        Обычно break без дополнительной метки завершает самый внутренний for, switch или select оператор
        break Оператор не может выходить за границы функции: 
        
        ОШИБКА: break is not in a loop
        
            func f() {
                break
            }
            
            func main() {
                for i := 0; i < 10; i++ {
                    f()
                }
            }

        ОШИБКА: invalid break label FirstLoop, поскольку метка связана с отсутствием включения for цикла 
            FirstLoop:
                for i := 0; i < 10; i++ {
                }
                for i := 0; i < 10; i++ {
                    break FirstLoop
                }

        ПРАВИЛЬНО:
            OuterLoop:
                for i := 0; i < 10; i++ {
                    for j := 0; j < 10; j++ {
                        fmt.Printf(“i=%v, j=%v\n”, i, j)
                        break OuterLoop
                    }
                }   

            // выведет i=0, j=0

        ПРАВИЛЬНО:
        SwitchStatement:
            switch 1 {
                case 1:
                    fmt.Println(1)
                    for i := 0; i < 10; i++ {
                        break SwitchStatement
                    }
                    fmt.Println(2)
            }
            fmt.Println(3)

            // выведет 1 3


    // CONTINUE
        Он работает аналогично оператору break, но вместо остановки начинает следующую итерацию и может использоваться только для циклов:
            OuterLoop:
                for i := 0; i < 3; i++ {
                    for j := 0; j < 3; j++ {
                        fmt.Printf(“i=%v, j=%v\n”, i, j)
                        continue OuterLoop
                    }
                }> ./bin/sandbox
            i=0, j=0
            i=1, j=0
            i=2, j=0

    // GOTO 
        goto может перемещать элемент управления только в пределах одной и той же функции.  
        Поскольку можно перенести элемент управления вперед, есть два дополнительных правила:
            1) любое объявление переменной не может быть пропущено, поэтому переменная попадает в область видимости:

            ОШИБКА: goto Done jumps over declaration of v at…
                goto Done
                    v := 0
                Done:
                    fmt.Println(v)
            
            2) goto не может перейти в другой блок:

            ОШИБКА: goto Block jumps into block starting at …
                goto Block
                {
                Block:
                    v := 0
                    fmt.Println(v)
                }

        // еще пример
        func main() {
            i := 0
            Start:
                fmt.Println(i)
                if i > 2 {
                    goto End
                } else {
                    i += 1
                    goto Start
                }
            End:            (!) пустой оператор, он разрешен
        }



// ФУНКЦИИ - основной инструмент для декомпозиции вашей программы на более простые блоки
    // 1 обычное объявление. 
    func foo(y string) int {
        return 1
    }

    // 2 Много параметров. Много результатов (неименнованных)
    func swap(x, y string) (string, string) {
        // Функция может возвращать любое количество результатов.
        return y, x
    }

    // 3 Именованный результат
                        // возвращаемые значения. Несколько возвращаемых результатов
                        // ВСЕ !!ИМЕНОВАННЫЕ!! РЕЗУЛЬТАТЫ СРАЗУ ИНИЦИАЛИЗИРУЮТСЯ ЗНАЧЕНИЯМИ ПО УМОЛЧАНИЮ (см. пример 4 ниже)
    func split(sum int) (x, y int) {
        x = sum * 4 / 9
        y = sum - x
        
        // возврат без указания переменных - вернуться переменные x, y - "nacked return" - что возвращать - указано после параметров функции (!)
        return
    }

    (!) но, если в функции с именнованным результатом явно указать значения в return, то она выведет именно их, несмотря на значения
        указанных переменных:

        func greeting() (name string, ok bool) {
            name = "Bob"            // обычное присваивание, name := "Bob" с импользованием :=  приведет к ошибке, т.к. name уже объявлена как возвращаемая переменная с типом string
            ok = false

            return "Alice", true                // вернет именно эти значения - "Alice", true !!!!!!!!!!!!!!!! несмотря на то, что определили name и ok как возвращаемые
        }

    // 4 Вариативная функция (ВНИМАНИЕ НА возвращаемое значение result int - т.к. оно инициализировано по умолчанию нулем, 
    // то result удобно использовать в качестве сумматора без явной инициализации нулем)
    func sum(in ...int) (result int) {
        fmt.Printf("in = %#v \n", in)
        for _, val := range in {
            result += val           // result не инициализировано нулем
        }
        return
    }

    Для объявления вариативной функции используется многоточие (...) с последним параметром
    func terraform(prefix string, worlds ...string) []string {
        newWorlds := make([]string, len(worlds)) // Создает новый срез вместо прямого изменения worlds
    
        for i := range worlds {
            newWorlds[i] = prefix + " " + worlds[i]
        }
        return newWorlds
    }

    Параметр worlds является срезом строк, что содержит ноль или более аргументов, передаваемых в terraform:
    twoWorlds := terraform("Нью", "Венера", "Марс")
    fmt.Println(twoWorlds) // Выводит: [Нью Венера Нью Марс]

    Для передачи среза вместо множества аргументов, расширьте срез через многоточие:!!!!
    planets := []string{"Венера", "Марс", "Юпитер"}
    newPlanets := terraform("Нью", planets...) //!!!!!!!! РАСПАКОВКА СЛАЙСА В ОДИНОЧНЫЕ аргументы
    fmt.Println(newPlanets) // Выводит: [Нью Венера Нью Марс Нью Юпитер]



// Троеточие ... (три точки)
    Три случая использования многоточия (...) в Go:
    1 Для подсчета компилятором Go количества элементов композитного литера для массива;
        a := [...]int{1,2,3,4,5,6,7,8}
    
    2 Заставить последний параметр вариативной функции зафиксировать ноль или большее число аргументов в качестве среза;
        func sum(worlds ...int) { // some code }        // передача слайса как вариативного параметра (распаковка слайса)

        т.е. можно отправлять сколько угодно параметров: sum(1,3,5,7,23)

    3 Расширить элементы среза в аргументы, передаваемые функции.
        otherBuf := make([]int, 3)
        buf = append(buf, otherBuf...)          // добавление другого слайса

        sum(a)      // ошибка - функция принимает 0 или более int, а передали []int
        sum(a...)   // верно



// ФУНКЦИИ КАК ОБЪЕКТ ПЕРВОГО КЛАССА:
    1) можем присваивать функцию в какую-то переменную              // var less func(i,j int) bool
    2) принимать функцию как аргумент в другую функцию              // func mySort(fn func(i,j int)) { if fn.less(..) ..}
    3) возвращать функцию как результат работы другой функции       
    4) функция может быть полем некторой структуры

    // обычная функция 
    func doNothing() {
        fmt.Print("---")
    }

    func main() {
        // анонимная функция, которая объявляется и вызывается
        func (in string){
            fmt.Print(in)
        }("test")

        // присваивание анонимной функции в некоторую переменную
        printer := func(in string) {
            fmt.Print(in)
        }
        printer("функция - как переменная")

        // опредеяем тип функции
        type strFuncType func(string)

        // функция принимает параметр callback - который является функцией типа strFuncType
        // колбеки - нужны, например, когда необходимо выполнить функцию по завершению какой-то работы
        // или в зависимости от разных условий имеют разную логику
        worker := func(callback strFuncType) {
            callback("функция printer - как колбек") // внутри этой функции, вызываем ту функцию, которую передали в параметрах
        }
        worker(printer)




        // ЗАМЫКАНИЯ - функции, которые обращаются к переменным, которые были созданы вне ее объявления
        prefixer := func (prefix string) strFuncType {
            return func(in string) {    // возвращаем замыкание. 
                fmt.Printf("[%s] %s\n", prefix, in)
            }
        }
        succesLogger := prefixer("SUCCESS")
        succesLogger("expected behaviour")

        Один из способов использования замыкания — функция, возвращающая другую функцию, 
        которая при вызове генерирует некую последовательность чисел. Например, следующим образом мы могли бы сгенерировать все четные числа:
        http://golang-book.ru/chapter-07-functions.html

        makeEvenGenerator возвращает функцию, которая генерирует чётные числа. Каждый раз, когда она вызывается, к переменной i
        добавляется 2, но в отличие от обычных локальных переменных её значение (!) сохраняется между вызовами.

        func makeEvenGenerator() func() uint {
            i := uint(0)
            return func() (ret uint) {
                ret = i
                i += 2
                return
            }
        }
        func main() {
            nextEven := makeEvenGenerator()
            fmt.Println(nextEven()) // 0
            fmt.Println(nextEven()) // 2
            fmt.Println(nextEven()) // 4
        }
    }

    // ЗАХВАТ ПЕРЕМЕННЫХ (https://habr.com/ru/company/badoo/blog/468863/)
        for i := 0; i < 5; i++ {
            go func() {
                fmt.Println(i)                  // Выведет 5 5 5 5 5 !!!!!!!!!!!!
            }()
        }

        Исправить код выше очень просто:
        for i := 0; i < 5; i++ {
            go func(a int) {
                fmt.Println(a)
            }(i)
        }




// ОТЛОЖЕННОЕ ВЫПОЛНЕНИЕ И ОБРАБОТКА ПАНИКИ
    // Оператор defer откладывает выполнение функции до возврата из окружающей функции.
    func main() {
        defer fmt.Println("world")
        fmt.Println("hello")
    }

    // вывод "hello\n MY \nworld"
    func main() {
        defer fmt.Println("world")
        defer fmt.Println(" MY ")         // несколько defer выполняется в порядке, обратном их объявления
        fmt.Println("hello")
    }


    // порядок вызовов функций в объявлении defer (v.1)
    func getSomeVars() string {
        fmt.Println("IN get some vars func")
        return "return from getSomeVars"
    }

    // !!! Если defer объявлен после return, он не выполнится (программа ниже ничего не выведет)
    func main() {
        if true {
            return
        }
        defer fmt.Println("world")
        fmt.Println("hello")
    }

    // !!! Определение defer (c recover) после блока с паникой не сработает! 
    func main() {
        fmt.Println("Hello, playground")
        
        if true {
            panic("123")
        }
        defer func(){
            err := recover()
            fmt.Println("Hello, playground", err)
        }()  
    }
    // а так сработает
      func main() {
        fmt.Println("Hello, playground")
        defer func(){
            err := recover()
            fmt.Println("Hello, playground", err)
        }() 
        if true {
            panic("123")
        } 
    }


    func main() {
        defer fmt.Println("defer 1")
        defer fmt.Println(getSomeVars())    // !!! аргументы вложенных функций вычисляются при объявлении блока defer!!!
                                            // (не когда функция будет вызвана, а при объявлении)
        fmt.Println("Hello, playground")
    }
    
    // вывод:
    IN get some vars func                   // выполнение функции fmt.Println(), которая вычисляет свой аргумент
    Hello, playground                       // выполнение некоторой полезной работы внутри main()
    return from getSomeVars                 // нижний defer - вывод результата функции getSomeVars
    defer 1                                 // верхний defer


    // порядок вызовов функций в объявлении defer (v.2)
    func main() {
        defer fmt.Println("defer 1")
        defer func() {
            fmt.Println(getSomeVars())
        }()
        fmt.Println("Hello, playground")
    }

    // вывод:   
    Hello, playground                       // выполнение некоторой полезной работы внутри main()
    IN get some vars func                   // нижний defer - работа функции getSomeVars
    return from getSomeVars                 // нижний defer - вывод результата функции getSomeVars
    defer 1                                 // верхний defer


    // panic() - встроенная функция, останавливающая выполнение программы
    // recover() - встроенная функция, возвращающая ошибку, которую бросила паника

    func deferTest() {
        defer func(){
            if err := recover(); err != nil {
                fmt.Println("panic happend:", err)
            }
        }()

        fmt.Println("some useful work")
        panic("something bad happend")
        return
    }

    func main() {
        deferTest()
        return
    }

    вывод:
    some useful work
    panic happend: something bad happend

    // плохая практика: panic внутри блока восстановления
    func deferTest() {
        defer func(){
            if err := recover(); err != nil {
                fmt.Println("panic happend 1:", err)
            }
        }()
        
        defer func(){
            if err := recover(); err != nil {
                fmt.Println("panic happend 2:", err)
                panic("second panic")
            }
        }()

        fmt.Println("some useful work")
        panic("something bad happend")
        return
    }
    вывод:
    some useful work
    panic happend 2: something bad happend
    panic happend 1: second panic



// СТРУКТУРЫ И их МЕТОДЫ. Структуры - сущности, объединенные для логического удобства.
    Полями структуры может быть любой тип в go, даже функция (как объект первого класса), либо другая структура 
    (!) Получатель (приемник) — это объявление типа, для которого вы хотите определить метод.

    type Vertex struct {
        X int
        Y int
    }

    // объявление экземпляра стурктуры Vertex{1, 2}
    func main() {
        // полное объявление структуры:
        var ver Vertex = Vertex{
            X: 1,                       // можем опустить некоторые поля, тогда они примут значение по умолчанию
        }

        // короткое объявление структуры (обязательно указать все параметры, т.к. они без явного объявления):
        v := Vertex{1, 2}
        ver1 := Vertex{1}               // Ошибка: too few values in Vertex{...}
        ver2 := Vertex{X:1}             // так можно
        
        p := &v                         // p - указатель на экземпляр структуры
        p.X = 19                        // что эквивалентно (*p).X = 19
        fmt.Println(v)                  // {19 2}
    }


    // определяем структруры
    var (
        v1 = Vertex{1, 2}  // has type Vertex   // {1 2} 
        v2 = Vertex{X: 1}  // Y:0 is implicit   // {1 0} - X - определили, Y - нет
        v3 = Vertex{}      // X:0 and Y:0       // {0 0} - создание "экземпляра" структуры, но с дефолтными значениями полей
        p  = &Vertex{1, 2} // has type *Vertex  // &{1 2} - тип *Vertex
    )

    // встраивание структур
    type Person struct {
        Id int
        Name string
        Adress string
    }

    type Account struct {
        Id int
        Name string
        Cleaner func(string) string
        Owner Person
        Person          // встраиваем структуру в структуру. Теперь поля Person являются частью структуры Account
                        // при обращении к полю Name (которе есть и в Account и в Person) - обратимся к полю Name верхнего уровня (Account.Name)
    }

    func main() {
        var acc Account = Account {
            Id: 1,
            Name: "Vasiliy",
            Person: Person {
                Name: "Baсилий",
                Adress: "Москва",
            }, 
        }

        fmt.Println(acc.Name)               // "Vasiliy", а не "Василий"
        fmt.Println(acc.Person.Name)        // "Василий"
    }


    // Методы структур. Метод - функция, которая привязана к определенному типу данных.
    type Person struct {
        Id int
        Name string
    }

    // в метод передается копия типа. Метод не изменит оригинальной структуры, для которой вызван метод при присваивании полю некоторого значения.
    func (p Person) UpdateName(name string){
        p.Name = name
    }

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // однако если поле структуры - ссылочный тип (указатель, срез, мапа, канал, интерфейс) и в методе изменяются значения поля по указателю,
    // то в таком случае после вызова метода в оригинальной структуре значение поля изменится: 

    // пример:
        type NamedParams struct {
            Number int
            OptionalNumber *int
            Name   string
            Params map[string]int
            Bytes []byte
            Something interface{}
        }

        func (s NamedParams) Clear() {
            s.Number = -1                   // not changed after call Clear()
            *s.OptionalNumber = -1          // chanded, because change value by pointer
            s.Name = "no name"              // not changed after call Clear()

            for k := range s.Params {
                delete(s.Params, k)         // changed
            }
            
            s.Bytes[0] = 'a'                // changed
            s.Bytes = []byte{}              // not changed after call Clear()
            s.Something = 42                // несмотря на ссылочный тип интерфейса, изменится значение в копии (s), однако 
                                            // после вызова этого метода p.Something не изменится. Однако, если бы в интерфейсе 
                                            // была бы map, и внутри Clear() значение существующего ключа было бы изменено, то 
                                            // после вызова Clear() p.Something изменится !!!!!!!
        }


        func main() {
            value := 5
            p := NamedParams{Number: 5, OptionalNumber: &value, Name: "box", Params: map[string]int{"length":100, "width":200}, Bytes: []byte{'A','B','C'}, Something: "test"}

            // 5 5 box 100 0 ABC test
            fmt.Println(p.Number, *p.OptionalNumber, p.Name, p.Params["length"], p.Params["other"], string(p.Bytes), p.Something)

            p.Clear()

            // 5 -1 box 0 0 aBC test
            fmt.Println(p.Number, *p.OptionalNumber, p.Name, p.Params["length"], p.Params["other"], string(p.Bytes), p.Something)
        }

    //  в метод передается адрес на тип. Метод изменит оригинальной структуры, для которой вызван метод
    func (p *Person) SetName(name string){
        p.Name = name
    }

    func main() {
        pers: = Person{1, "Vasiliy"}
        pers.SetName("Vasiliy Rom")     // Компилятор автоматически преобразует к (&pers).SetName("Vasiliy Rom), т.к. в метод передается указатель
        pers := &Person{}               // эквивалентно pers := new(Vertex) 


    (!) // ВОЗМОЖНА И ТАКАЯ КОНСТРУКЦИЯ - вызов метода из неинициализированного объекта, причем первым параметром - передается экземпляр 
        // структуры
        (*Person).SetName(
		    &pers, 
		    "Bob",
		)
	    fmt.Println(pers)       // {1 Bob}
    }

        (!) упрощенный пример с вызовом метода неинициализированной структуры:
            type Vertex struct {
                X int
                Y int
            }

            func (v Vertex) Sum() int {
                return v.X + v.Y
            }
            
            func main() {
                ver := Vertex{1, 2}

                fmt.Println(
                    Vertex.Sum(ver),        // (!) вызов метода структуры без ее инициализации.
                )
            }


    // Добавим структуру Account
    type Account struct {
        Id int
        Name string
	    Person                  // имплементируем структуру Person в Account
    }

    // создадим метод Account с таким же именем, как в Person
    func (p *Account ) SetName(name string){
        p.Name = name
    }

    func main() {                             
        acc := Account{
            Id: 1,
            Name: "Василий",
            Person: Person {
                Id: 2,
                Name: "Vasily",
            },
        }
        acc.SetName("NEW NAME")
        fmt.Println(acc)                    // !!! {1 NEW NAME {2 Vasily}}

        acc.Person.SetName("Вася")
        fmt.Println(acc)                    // !!! {1 NEW NAME {2 Вася}}
    }


    // Пример: как передать ссылку на структуру B другой структуре A, так, чтобы при изменении структуры B, менялась структура A внутри B
            package main

            import (
                "fmt"
            )

            type A struct {
                bb *B 
            }

            func (a *A) set(bb *B) {
                a.bb = bb
                fmt.Println(bb.b)
            }

            func (a *A) get() {
                fmt.Println("a.bb.b =", a.bb.b)
            }


            type B struct {
                b int
            }

            func (b *B) changeB(){
                b.b = 99
            }

            func (b *B) get() {
                fmt.Println("B.b=", b.b)
            }


            func main() {
                bb := B{b:100}
                aa := A{}
                aa.set(&bb)
                
                bb.changeB()
                bb.get()
                aa.get()
                
                fmt.Println("Hello, playground")
            }

            // вывод
            100
            B.b= 99
            a.bb.b = 99
            Hello, playground


    // КАСТОМНЫЕ ТИПЫ
        -позволяют объявить собственные методы
        -разные типы получателя у методов (по указателю - func (p *Point) и по значению func (p Point))
        -для работы может потребоваться явное приведение типов

            type RichInt int

            func (i RichInt) IsNegative() bool {
                return i < 0
            }

            func (i *RichInt) Set(newValue int) {
                *i = RichInt(newValue)
            }

            func main() {
                var i RichInt = 4

                i += 1                      // OK

                b := 1
                i += b                      // FAIL - mismatched types RichInt and int. Чтобы исправить, нужно привести типы:

                i += RichInt(b)             // OK

                fmt.Println(i.IsNegative())             // false
                i.Set(-1)
                fmt.Println(i.IsNegative())             // true
            }

    // ПРИВЕДЕНИЕ ТИПОВ
        The expression T(v) converts the value v to the type T.
        func main() {
            var x, y int = 3, 4
            var f float64 = math.Sqrt(float64(x*x + y*y))
            var z uint = uint(f)
            fmt.Println(x, y, z)
        }

// ПАКЕТЫ И ОБЛАСТЬ ВИДИМОСТИ
    Go работает с так называемой системной переменной GOPATH.
    Это адрес директории, внутри которой должны находиться некоторые специализированные директории.
    Первая из них — это папка bin, в нее кладутся собранные бинарники, то есть либо .exe, либо l-файлы.
    В pkg кладутся временные объектные файлы, а src содержит исходники вашей программы. 

    Если переменная, структура, поле структуры, константа, функция начинается с заглавной буквы,
    это значит, что эта сущность экспортируемая, то есть она доступна для обращения из других пакетов.
    Если же она начинается со строчной, это значит, что эта сущность принадлежит только этому пакету. 

    Пакет состоит не из файла, а из директорий. То есть одна директория, person, это и есть пакет.
    Следовательно, все, что я объявлю в файле person.go, будет доступно и из файла func.go, потому что они составляют один пакет. 

    C:\Users\User\Go
    |----bin
    |----pkg
    |----src
        |----coursera
        |       |----visibility
        |       |       |----person
        |       |       |        |----person.go
        |       |       |        |----func.go
        |       |       |----main


    // файл person.go:
        package person

        var (
            Public = 1
            private = 0
        )

        type Person struct {
            Id      int
            Name    string          // можем обратиться из другого пакета
            secret  string          // приватное поле, можем обращаться только из функций этого пакета (включая методы этой структуры)
        }

    // import распространяется на файл, в котором он определен, а не на весь пакет (состящий из нескольких go-файлов)




// nil (нил)
    https://golangify.com/nil
    Разыменование указателей nil приведет к сбою программы;
    Методы могут защитить от получения значений nil;
    Поведение по умолчанию может быть предоставлено функциям, передаваемых в виде аргументов;
    Срез nil часто можно заменить пустым срезом;
    Карту nil можно читать, но записывать в нее нельзя;
    Если интерфейс выглядит так, будто это nil, убедитесь, что оба тип и значение являются nil;
    nil — не единственный способ представления пустого значения





// ИНТЕРФЕЙСЫ в go
    Как известно, интерфейсы определяют некий контракт. И каждый объект, реализующий этот контракт, обязан его соблюдать.
    Интерфейсы не содержат никакого поведения.
    Zero-value интерфейса - это nil
    Интерфейс - вполне конкретная переменная, на которую можно взять указатель, но обычно указатель на интерфейс не применяется (не нужен)
    Интерфейс - абстракция над стандартным типом, позволяющая нам разорвать связь между использованием и реализацией

    Интерфейсы описываются там, где используются, и должны содержать то, что используется. Т.е. где понадобился метод - там 
    и используем

    Цель интерфейса - уменьшение степени связности (между пакетами) - низкий coupling (зацепления)
    Со связностью нужно бороться - меняя одну часть кода - затрагивается другой код.

    Интерфейс под капотом:
        type iface struct {
            tab *itab
            data unsafe.Pointer
        }

    Создать не-nil интерфейс нельзя, за каждым не-nil интерфейсом стоит конкретный тип.
    Реализация интерфейса - конкретный тип, не обязательно структура

    Пример 1.
        type SomeInterface interface {
            SomeMethod(in string) (out string)
        }

        type SomeStruct struct {
            prefix string
        }

        func (s SomeStruct) SomeMethod(in string) (out string) {
            return s.prefix + in
        }

        func main() {
            var iv SomeInterface = SomeStruct{"I say: "}        // реализация интерфейса - конкретный тип, в котором определены все методы, 
                                                                // указанные в описании интерфейса (утиная типизация)
            fmt.Printf("method: %q\n", iv.SomeMethod("Hello, world!"))
        }


    (!) Согласно принципам SOLID, I - принцип разделения интерфейсов:
        Интерфейсы не должны быть большими, можно принимать их на вход и никогда не возвращать (!), 
        Важное эмпирическое правило для Go, принимать интерфейсы, а возвращать структуры.

        Псевдонаследование (плохая практика так писать код):
            type SomeInterface interface {
                SomeMethod(in string) (out string)
            }

            type SomeOtherInterface interface {
                SomeInterface
                SomeOtherMethod(in string) (out string)
            }

    (!!!) Важно!! Не использовать указатель на интерфейс
        Не надо возвращать указатель на тип интерфейса из функции: указатель на интерфейс, 
        никогда не сможет удовлетворить интерфейс.

        type Producer interface {
            SendMessages()
        }

        func GetProducer() *Producer {}     // НЕЛЬЗЯ возвращать указатель на интерфейс.
        ...
        producer := mq.GetProducer()       // producer имеет тип *Producer (указатель на интерфейс)
        producer.SendMessages()            // ошибка! хотя и интерфейс имеет этот метод, но из указателя на интерфейс этот метод найден не будет


    Пустой интерфейс - универсальный объект. Пустой интерфейс - не интерфейс, он даже реализован в языке другой структурой данных.
    Переменную любого типа можно присвоить в переменную пустого интерфейса.

    Пример 2.   
        var x interface{}
        x = "foo"           // x представляет из себя пару ("foo", string).


    Интерфейс - это описание того, что может и должен уметь делать объект класса, который реализует этот интерфейс.
    Смысл интерфейса - в унификации работы с разнотипными объектами.
    В общем интерфейсы нужны, чтобы связать группу не связанных объектов, которые обязаны реализовать поведение того интерфейса,
    чтобы можно было взаимодействовать с ними через этот общий интерфейс.
    Главное отличие класса от интерфейса — в том, что класс состоит из интерфейса и реализации.

    Под капотом интерфейсы реализованы как два элемента: тип и значение. Для целочисленного значения 3, 
    интерфейс содержит (схематично) (int, 3)

    Значение интерфейса равно nil, только если внутреннее значение и тип не заданы, (nil, nil).  
    В частности, интерфейс nil всегда будет иметь тип nil.  Если мы сохраняем nil указатель типа *int внутри значения
    интерфейса, внутренний тип будет *int независимо от значения указателя: (*int, nil).  Таким образом, такое значение
    интерфейса будет отличным от nil, даже если указатель внутри равен nil.

            func Foo() error {
                var err *os.PathError = nil
                return err
            }

            func Task3() {
                err := Foo()
                fmt.Println(err)        // <nil>
                fmt.Println(err == nil) // false
            }
            Поэтому fmt.Println(err == nil) выведет false, потому что внутреннее значение интерфейса err содержит указатель
            типа *os.PathError со значением nil
            
            Другими словами, если мы храним nil указатель типа *os.PathError внутри значения интерфейса, внутренний тип
            будет *os.PathError независимо от значения указателя: (T=*os.PathError, V=nil). Поэтому такое значение интерфейса
            будет не равно nil, даже если значение указателя V внутри равно nil.


            еще пример:
            a := (*interface{})(nil)       // тоже самое, что и var a *interface{} = nil - переменная является ссылочным типом
            fmt.Println(reflect.TypeOf(a), reflect.ValueOf(a))  // *interface {} <nil>
            
            var b interface{} = (*interface{})(nil)         // b - имеет тип "интерфейс", который nil тогда, когда тип и значение интерфейса
            // равны nil. Тип *interface{} не равен nil
            fmt.Println(reflect.TypeOf(b), reflect.ValueOf(b))  // *interface {} <nil>
            
            fmt.Println(a == nil, b == nil)                     // true false

    В Go полиморфизм организован через интерфейсы (возможность функции принимать в себя аргументы различных типов)
    В Go, когда вы создаете структуру с методами, она не знает, какому интерфейсу она соответствует, то есть типизация неявная
    То есть вы передаете в метод, который принимает определенный интерфейс.
    А уже интерфейс описывает, что если мы хотим сюда попасть, там должны быть определенные методы.
    То есть вы можете передать в функцию ту структуру, даже если она не знает, что она реализует этот интерфейс

    
    https://thecode.media/oop-abstract/
    Абстракция — это когда мы сосредотачиваемся только на существенных для задачи деталях и игнорируем всё остальное. 
    В ООП абстракция означает, что для каждого объекта мы задаём минимальное количество методов, полей и описаний, которые
    позволят нам решить задачу. Чем меньше характеристик, тем лучше абстракция, но ключевые характеристики убирать нельзя.
    Чтобы работать с абстракциями, используют интерфейсы.

    // Интерфейс - как тип данных
    var a interface{} = "hello"     // анонимный интерфейс - а анонимная структура: var c struct{}
    a = 42
    a = 4.2
    и это будет работать!!! поскольку этот интерфейс может быть любым типом, реализующим 0 методов!!!!!!

    Приведение типов (!!! ТАКИМ СПОСОБОМ МОЖНО ПРИВОДИТЬ ТИПЫ ТОЛЬКО В ИНТЕРФЕЙСАХ):
    a := "hello"
    f, ok := a.(float32)
    fmt.Println(f, ok)  //0, false

    Интерфейс под капотом - это кортеж 
    type structHere struct {
        N1, N2 int
    }
    ...
    type InterfaceHere interface {
        Sum()   int
    }

    var os *structHere
    var i InterfaceHere
    i = os
    ({3,1}, *main.structName)

    где {3,1} - значение в структуре structHere
    *main.structName - тип интерфейса (в пакете main)

    // SWITCH type для определения, какой тип данных в интерефесе:
    var a interface{} = "hello"
    switch a.(type) {
        case int:
            fmt.Println("int")
        case string:
            fmt.Println("string")
        default:
            fmt.Printf("unknown type %T\n", a)
    }

    // https://go.dev/ref/spec#Switch_statements
    switch i := x.(type) {
        case nil:
            printString("x is nil")                // type of i is type of x (interface{})
        case int:
            printInt(i)                            // type of i is int
        case float64:
            printFloat64(i)                        // type of i is float64
        case func(int) float64:
            printFunction(i)                       // type of i is func(int) float64
        case bool, string:
            printString("type is bool or string")  // type of i is type of x (interface{})
        default:
            printString("don't know the type")     // type of i is type of x (interface{})
        }

    С помощью type мы можем переключиться на тип значения интерфейса.
    var data interface{} 
        data = 112523652346.23463246345
        switch mytype:= data.(type) { 
        case string: 
            fmt.Println("string")
        case bool: 
            fmt.Println("boolean") 
        default: 
            fmt.Printf("%T", mytype) 
        } 
    }

    // Пример 1.
    type Payer interface {
        Pay(int) error
    }

    type Wallet struct {
        Cash int
    }

    func (w *Wallet) Pay(amount int) error {
        if w.Cash < amount {
            return fmt.Errorf("Не хватает денег в кошельке")
        }
        w.Cash -= amount
        return nil
    }
    
    // Есть функция Buy, которая принимает в себя интерфейс «плательщик».
    // Она не знает уже, какая структура туда придет.
    // Ей просто важно, чтобы то, что придет в эту функцию,
    // обладало методом Pay. 
    func Buy(p Payer) {
        err := p.Pay(10)
        if err != nil {
            panic(err)
        }
        fmt.Printf("Спасибо за покупку через %T\n\n", p)
    }

    func main() {
        myWallet := &Wallet{Cash: 100}
        Buy(myWallet)                       // Спасибо за покупку через *main.Wallet
    }


    // Пример 2.
    // --------Интерфейс платильщика-----------
    type Payer interface {
        Pay(int) error
    }
    // --------Интерфейс платильщика-----------

    // --------Функция "купить"-----------
    func Buy(p Payer) {
        err := p.Pay(10)
        if err != nil {
            panic(err)
        }
        fmt.Printf("Спасибо за покупку через %T\n\n", p)
    }
    // --------Функция "купить"-----------

    // --------Кошелек-----------
    type Wallet struct {
        Cash int
    }

    func (w *Wallet) Pay(amount int) error {
        if w.Cash < amount {
            return fmt.Errorf("Не хватает денег в кошельке")
        }
        w.Cash -= amount
        return nil
    }
    // --------Кошелек-----------

    // --------Карточка-----------
    type Card struct {
        Balance int
        Number string
        CardholderID int
    }

    func (c *Card) Pay(amount int) error {
        if c.Balance < amount {
            return fmt.Errorf("Не хватает денег в кошельке")
        }
        c.Balance -= amount
        return nil
    }
    // --------Карточка-----------

    // --------Apple Pay-----------
    type ApplePay struct {
        Money int
        AppleID string
    }

    func (a *ApplePay) Pay(amount int) error {
        if a.Money < amount {
            return fmt.Errorf("Не хватает денег в кошельке")
        }
        a.Money -= amount
        return nil
    }
    // --------Apple Pay-----------

    func main() {
        var myMoney Payer
        myMoney = &Card{Balance:100, CardholderID: 12342314325, Number: 342323}
        Buy(myMoney)

        myMoney = &ApplePay{Money:9, AppleID: 12363456}
        Buy(myMoney)

        myMoney = &Wallet{Cash:90}
        Buy(myMoney)
    }

    // Но иногда нам бывает нужно
        не просто вызывать какие-то методы интерфейса,
        но и проверить, что в действительности нам пришло

    func Buy(p Payer) {
        switch p.(type) {
            case *Wallet:
                fmt.Println("Оплата наличными?")
            case *Card:
                // необходимо проверить владельца карты. Но из интерфейса нельзя обратиться к полям структуры, 
                // которая "лежит" под этим интерфейсом!!! Ведь у интерфейса нет поля "CardholderID".
                // Попробуем явно преобразовать к типу *Card
                plasticCard, ok := p.(*Card)
                if !ok {
                    fmt.Println("Не удалось преобразовать к типу *Card")
                }

                // Теперь в plasticCard у меня действительно лежит мой тип Card,
                // и я могу обратиться к его полям, это уже не интерфейс. 
                fmt.Println("Вставляйте карту,", plasticCard.CardholderID)
            default:
                fmt.Println("Что-то новое")
        }

        // Покупаем: у интерфейса есть метод Pay()
        err := p.Pay(10)
        if err != nil {
            panic(err)
        }
        fmt.Printf("Спасибо за покупку через %T\n\n", p)
    }

    func main() {
        myWallet = &Wallet{Cash:90}
        Buy(myWallet)

        var myMoney Payer
        myMoney = &Card{Balance:100, CardholderID: 12342314325, Number: 342323}
        Buy(myMoney)

        myMoney = &ApplePay{Money:9, AppleID: 12363456}
        Buy(myMoney)
    }

    // структура может удовлетворять интерфейсу, если:
        1) структура содержит встроенную(!) анонимную структуру (!!!), которая удовлетворяет данному интерфейсу!!!
        2) структура имеет все методы, которые требует данный интерфейс
    

    // Пустой интерфейс — это интерфейс,
    который может принять в себя вообще любую переменную,
    потому что у него нет никаких требований к реализации 
    (пустому интерфейсу удовлетворяет вообще любой тип)

    функция Printf() стандартной библиотеки не знает ничего про тип,
    который я только что определил.
    На самом деле функция Printf() принимает в себя пустой интерфейс.
    Поэтому мы туда можем передавать абсолютно любые параметры,
    одни за другими, она все из них выведет

    // Пример.
    func Buy(in interface{}) {
        var p Payer
        var ok bool
       
        // я хочу проверить, является ли то, что мне пришло, интерфейсом?
        Если не является, говорю, что нельзя.
        Ну а поскольку оно, если является,
        я уже присвоил переменную p плательщика, то я произвожу оплату. 

        if p, ok = in.(Payer); !ok {
            fmt.Println("%T не является платежным средством")
            return
        }
        
       // Покупаем: у интерфейса есть метод Pay()
        err := p.Pay(10)
        if err != nil {
            panic(err)
        }
        fmt.Printf("Спасибо за покупку через %T\n\n", p)
    }

    Что будет в переменной myVal если не получится преобразовать тип из пустого интерфейса ( ok == false )
    myVal, ok := emptyInterfaceVal.(int)
    Ответ - Значение по-умолчанию, для int-а это 0

    // Композиция интерфейсов
    type Payer interface {
        Pay(int) error
    }
    
    type Ringer interface {
        Ring(string) error
    }

    type NFCPhone interface {
        Payer                   // интерфейс образован композицией двух других
                                // интерфейсов: Плательщик и Звонилка - они встроены
        Ringer                  // а, если необходимо объявить, то используется Ring(string) error
                                // Не обязательно использовать только интерфейсы, вы можете один интерфейс встроить, а другой — объявить. 
    }

     func PayInMetroTurniket(phone NFCPhone) {
        err := phone.Pay(1)
        if err != nil {
            fmt.Printf("Ошибка при оплате %v\n\n", err)
            return
        }
        fmt.Printf("Турникет открыт через %T\n\n", phone)
    }

    func main() {
        myPhone := &Phone{Money: 9}
        // передал NFCPhone, который реализует и функцию Pay, и функцию Ring, звонить, он пройдет
        PayInMetroTurniket(myPhone)
    }








    // ФИЛОСОФИЯ ПРИМЕНЕНИЯ ИНТЕРФЕЙСОВ 
        Data access layer (DAL) - слой в приложении, выделяемый для общения с базой данных
        Необходимо ограничить распространение сложности - иначе сложность БД расползется по коду приложения 
        и отравит его.

        Для решения этой проблемы необходимо создать несколько интерфейсов по 5-6 методов в каждом. 
        Таким образом, мы отвяжем наш код от кода DAL, используя только свои интерфейсы.

        Методы интерфейса должны использоваться в функции полностью, иначе - нужно дробить интерфейс на более мелкие

        Параметры методов внутри интерфейса - привязаны к реализации DAL. Попытка заменить типы параметров на 
        интерфейсы не принесет результата: утиная типизация работает для конкрентных типов и интерфейсов, а так же
        для интерфейсов и интерфейсов, но не работает для производных типов: функций, слайсов, хеш-таблиц и т.д.

        (!) мы можем присвоить переменную типа интерфейса io.ReadWriter переменной типа io.Reader, но мы не можем 
        присвоить переменную типа []io.ReadWriter переменной типа []io.Reader. 
        Это самый большой косяк системы типов Go. 
        Т.е. функции, которые используют совместимые интерфейсы, не будут восприняты как функции с совпадающими сигнатурами.

            Эта проблема Go:
                - мешает писать эффективный код
                - мешает использовать средства обобщенного программирования (generic programming) - парадигма 
                    программирования, заключающаяся в таком описании данных и алгоритмов, которое можно применять к 
                    различным типам данных, не меняя само это описание. В том или ином виде поддерживается разными 
                    языками программирования.
                - сильно ограничивает применимость интерфейсов в реальной жизни: утиная типизация работает только при 
                    совпадении типов параметров и возвращаемых значений и эти типы привязаны к конкретному пакету

            Поэтому часто используются пустой интерфейс - interface{}: 
                две функции, которые принимают пустой интерфейс и возвращают пустой интерфейс будут совместимы между собой
            
            Что плохого в этом?
                - типизация становится динамической, со всеми сопутствующими проблемами (приведение типов в рантайме, а не на
                    этапе компиляции)

            (!) Что можно сделать - унести используемые типы в отдельный пакет и привязать к нему реализацию и использование.
                т.е. лучше привязать 2 пакета к третьему, чем свзать их между собой


    // ТЕХНОЛОГИЧЕСКИЕ ОСОБЕННОСТИ ИСПОЛЬЗОВАНИЯ ИНТЕРФЕЙСОВ   
        Интерфейсы используются для уменьшения свзности в модульном коде. Именно поэтому интерфейс описывается на стороне его использующей       
        Идентичный интерфейс нужно вынести в отдельный пакет, но не не сторону реализации.

        Decoupling:
            не размещай интерфейс в модуле 1 с логикой (реализацией этого интерфейса) - может возникнуть доп. зависимость из модуля 2, 
            который хочет определить интерфейс. Решение - выделить интерфейс в отдельный пакет.
            Можно копировать интерфейс из пакета в пакет.

        Интерфейсы очень подходят для Mocking. Это серебряная пуля для unit-тестов. Важно, чтобы интерфейсы были маленькими.
        По-возможности, избегайте полиморфизм (пока нет generics - параметрические типы)
        

    // Рефлексия 
        приведение типов (в рантайме):
            someVar := SomeInterface.(SomeOtherInterface)           // вызовет панику, если типы несовместимы
            someVar := SomeInterface.(SomeStruct)                   // вызовет панику, если типы несовместимы
            someVar := SomeInterface.(SomeType)                     // вызовет панику, если типы несовместимы
            someVar, ok := SomeInterface.(SomeOtherInterface)       // НЕ вызовет панику, если типы несовместимы - ok - флаг true|false в 
                                                                    // зависимости от успеха преобразования типов

        type switch - способ справиться с проблемой динамической типизации

    // Проверка выполнения контракта, которая подскажет соответствие структуры интерфейсу на этапе компиляции:
        пример:
            есть интерфейс (контракт) из пакета JSON:
                type Marshaller interface {
                    MarshalJSON() ([]byte, error)
                }
            задача: переопределить стандартное поведение:
                type myStruct struct {
                    privateField string
                }

                func (m *myStruct) MarshalJSON() ([]byte, error) {
                    ...
                }

            (!) теперь проверка выполнения контракта:
                var _ json.Marshaler = (*myStruct).(nil)

                что это дает? если метод структуры не выполняет контракт интерфейса, то на этапе 
                компиляции в этой строке будет ошибка.





    // Написание программы уникализации (на вход - строки, на выходе - уникальные строки без повторений) 
        cat data.txt | go run main.go   - команда для чтения из внешнего файла
        
        Давайте немножко переделаем нашу программу, для того чтобы она была
        похожа на команду стандартной поставки GNU Coreutils uniq.
        Команда uniq принимает на вход отсортированный набор данных,
        и за счет этого она может сравнить, что если мы уже пришли на
        эту позицию, мы уже видели, это значит,
        что все, что до этого было, оно должно быть меньше. 
        
        package main

        import (
            "bufio",
            "fmt",
            "os"
        )

        // на входе в программу - отсортированные строки
        func main() {
            in := bufio.NewScanner(os.Stdin)
            var prev string
            
            for in.Scan() {
                txt := in.Text()
                if txt == prev {    // текущая и предыдущая строки равны? продолжаем считывать, не добавляя в ответ.
                    continue
                }

                if txt < prev {
                    panic()
                }

                prev = txt
                fmt.Println(txt)
            }
        }

        // Написание тестов. Файл main.go:
        package main

        import (
            "bufio",
            "fmt",
            "os",
            "io"
        )

        func uniq(reader io.Reader, output io.Output) error {
            in := bufio.NewScanner(reader)
            var prev string
            
            for in.Scan() {
                txt := in.Text()
                if txt == prev {    // текущая и предыдущая строки равны? продолжаем считывать, не добавляя в ответ.
                    continue
                }

                if txt < prev {
                    return fmt.Errorf("file not sorted")
                }

                prev = txt
                fmt.Fprintln(output, txt)
            }
            return nil
        }

        // на входе в программу - отсортированные строки
        func main() {
            err := uniq(os.Stdin, os.Stdout)
            if err != nil {
                panic(err.Error())
            }
        }


    
    
    
    
    
    
    
    
    
    
    
    // Написание тестов. Файл main_test.go:
        package main

        import (
            "string"
            "bytes"
            "testing"
        )

        var testOk = `1
        2
        3
        3
        4
        5`

        var testOk = `1
        2
        3
        4
        5
        `

        var testFail = `1
        2
        1
        `

        func TestOk(t *testing.T) {
            in := bufio.NewReader(strings.NewReader(testOk))
            out := new(bytes.Buffer)

            err := uniq(in, out)
            if err != nil {
                t.Errorf("Test for Ok failed")
            }
            
            result := out.String()
            if result != testOkResult {
                t.Errorf("test for OK Failed - results not match \n %v %v", result, testOkResult)
            }
        }

        // тесты для ошибки
        func TestForError(t *testing.T) {
            in := bufio.NewReader(strings.NewReader(testFail))
            out := new(bytes.Buffer)

            err := uniq(in, out)
            if err == nil {
                t.Errorf("Test for Ok failed - error: %v", err)
            }
        }

        // запуск тестов - go test -v

        // error interface
        type error interface {
            Error() string
        }

































// ФОРМАТИРОВАНИЕ СТРОК/ВЫВОДА %%%%%%%%%%%%%%%%%
    Для представления Юникода в Go используется тип rune, который иначе называется int32.
    byte является другим названием типа uint8. Он используется для бинарных данных, хотя byte может 
    использоваться для символа английского алфавита, определенного ASCII, более старого 128-символьного набора Юникод.

    Запоминать все Юникоды нет нужды, в Go есть символьный литерал. Просто поместите символ в одинарные кавычки: 'A'

    Строка форматирования представляет набор спецификаторов. Каждый спецификатор представляет набор символов, которые интерпретируются определенным образом и предваряются знаком процента %. Каждый спецификатор представляет определенный тип данных:

        %t: для вывода значений типа boolean (true или false)
        %b: для вывода целых чисел в двоичной системе
        %c: для вывода символов, представленных числовым кодом
        %d: для вывода целых чисел в десятичной системе
        %o: для вывода целых чисел в восьмеричной системе
        %q: для вывода символов в одинарных кавычках
        %x: для вывода целых чисел в шестнадцатиричной системе, буквенные символы числа имеют нижний регистр a-f
        %X: для вывода целых чисел в шестнадцатиричной системе, буквенные символы числа имеют верхний регистр A-F
        %U: для вывода символов в формате кодов Unicode, например, U+1234
        %e: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78
        %E: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456E+78
        %f: для вывода чисел с плавающей точкой, например, 123.456
        %F: то же самое, что и %f
        %g: для длинных чисел с плаващей точкой используется %e, для других - %f
        %G: для длинных чисел с плаващей точкой используется %E, для других - %F
        %s: для вывода строки
        %p: для вывода значения указателя - адреса в шестнадцатеричном представлении
        %v: Также можно применять универсальный спецификатор %v, который для типа boolean аналогичен %t,
            для целочисленных типов - %d, для чисел с плавающей точкой - %g, для строк - %s.
    %c
    Для отображения символов вместо их числовых значений можно использовать специальный символ %c вместе с Printf:
    fmt.Printf("%c%c%c%c\n", pi, alpha, omega, bang) 
    // Выводит: πάω!

    %x
    Более короткий способ создания презентабельного вывода для грязной строки - использовать %x (шестнадцатеричный)
    формат в fmt.Printf.  
    // bdb23dbc20e28c98

    %q      // https://golang-blog.blogspot.com/2019/09/string-byte-rune-character-golang.html
    Форма %q (в кавычках) будет экранировать любые непечатаемые последовательности байтов в строке, поэтому вывод будет однозначным.
    // "\xbd\xb2=\xbc ⌘"

    Если мы незнакомы или смущены странными значениями в строке, мы можем использовать "плюс" флаг к %q. 
    Этот флаг заставляет выходные данные экранировать не только непечатаемые последовательности, но также и любые байты,
    отличные от ASCII, при интерпретации UTF-8. В результате он предоставляет Unicode значения правильно отформатированного UTF-8,
    который представляет не-ASCII данные в строке:
    fmt.Printf("%+q\n", sample)
    // "\xbd\xb2=\xbc \u2318"

    %#U
    Вот пример, использующий еще один удобный формат Printf, %#U, который показывает значение Unicode кодовой точки и ее печатное представление:
    const nihongo = "日本語"
    for index, runeValue := range nihongo {
        fmt.Printf("%#U starts at byte position %d\n", runeValue, index)
    }
    U+65E5 '日' starts at byte position 0
    U+672C '本' starts at byte position 3
    U+8A9E '語' starts at byte position 6


// Способы конкатенации строк:
    a := "Hello"
    b := "World"

    1) c := a + b               // самый неоптимальный
    2) var c bytes.Buffer       // средне, уступает методу 3)
       c.WriteString(a)
       c.WriteString(b)
       fmt.Println(c.String())
    3) var c strings.Builder    // самый быстрый
       c.WriteString(a)
       c.WriteString(b)
       fmt.Println(c.String())


// Testing. Benchmark
    const concatSteps = 1000
    
    // 1) проверка скорости конкатенации a+b
        func BenchmarkPlus(b *testing.B) {
            for n := 0; n <b.N; n++ {
                var str string
                for i := 0; i < concatSteps; i++ {
                    str += "x"
                }
            }
        }

    // 2) проверка скорости конкатенации Bytes
        func BenchmarkBytes(b *testing.B) {
            for n := 0; n <b.N; n++ {
                var buffer bytes.Buffer       
                for i := 0; i < concatSteps; i++ {
                    buffer.WriteString("x")
                }
            }
        }

    // 3) проверка скорости конкатенации Builder
        func BenchmarkBytes(b *testing.B) {
            for n := 0; n <b.N; n++ {
                var str strings.Builder       
                for i := 0; i < concatSteps; i++ {
                    str.WriteString("x")
                }
            }
        }







// АЛГОРИТМЫ
    /*
    //Fibonacci Iterative
        func fibonachi(n int) int {
            var a, b int = 1, 1
            for i := 0; i < n; i++ {
                a, b = b, a+b
            }
            return a
        }
    */


    // работа с QueryString
        /*
        http://127.0.0.1:8000/fibonachi/1/8

        That means that I'd like to catch both /articles/123 and /articles/123?key=456 in the same handler.

        package main

        import (
            "fmt"
            "log"
            "net/http"

            "github.com/gorilla/mux"
        )

        var router = mux.NewRouter()

        func main() {
            router.Path("/articles/{id:[0-9]+}").Queries("key", "{key}").HandlerFunc(YourHandler).Name("YourHandler")
            router.Path("/articles/{id:[0-9]+}").HandlerFunc(YourHandler)

            if err := http.ListenAndServe(":9000", router); err != nil {
                log.Fatal(err)
            }
        }

        func YourHandler(w http.ResponseWriter, r *http.Request) {
            id := mux.Vars(r)["id"]
            key := r.FormValue("key")

            u, err := router.Get("YourHandler").URL("id", id, "key", key)
            if err != nil {
                http.Error(w, err.Error(), 500)
                return
            }

            // Output:
            // /articles/10?key=[key]
            w.Write([]byte(u.String()))
        }
        */



    // C GITHUB INFO
    go install mymath - компиляция пакета в директории
    go get -u … - чтобы обновить Ваши удаленные пакеты, при этом установятся все дополнительные зависимости .
    go - набор утилит, выполняемых из командной строки. Вы можете исполнить в терминале команду go, чтобы увидеть их


    // Принципы RESTful: https://www.codecademy.com/articles/what-is-rest
    -Разделение клиента и сервера (Используя интерфейс REST, разные клиенты обращаются к одним и тем же конечным 
    точкам REST, выполняют одни и те же действия и получают одинаковые ответы)
    -Системы, которые следуют парадигме REST, не имеют состояния, что означает, что серверу не нужно ничего знать
    о том, в каком состоянии находится клиент, и наоборот.  
    
    -Связь между клиентом и сервером
    REST требует, чтобы клиент сделал запрос к серверу, чтобы получить или изменить данные на сервере.  Запрос обычно состоит из:

        *HTTP-глагол, который определяет, какую операцию выполнять 
            Есть 4 основных HTTP-команды, которые мы используем в запросах для взаимодействия с ресурсами в системе REST:
            (GET-получить определенный ресурс по id | POST-создать новый ресурс |PUT - обновить |DELETE)

        *заголовок, который позволяет клиенту передавать информацию о запросе
        *путь к ресурсу
        *необязательное тело сообщения, содержащее данные

    -Заголовки и параметры Accept
        В заголовке запроса клиент отправляет тип контента, который он может получить от сервера.  
        Это называется полем Accept, и оно гарантирует, что сервер не отправляет данные, которые не могут быть
        поняты или обработаны клиентом.  Варианты типов контента - это типы MIME 
        Типы MIME, используемые для указания типов содержимого в поле Accept, состоят из типа и подтипа.  Они разделены косой чертой (/).
        Например, текстовый файл, содержащий HTML, будет указан с типом text / html.  
        Если бы этот текстовый файл содержал вместо этого CSS, он был бы указан как text / css.
        Общий текстовый файл будет обозначаться как text / plain.  Однако это значение по умолчанию, text / plain, не является универсальным.
        Если клиент ожидает text / css и получает text / plain, он не сможет распознать контент. Еще MIME-типы:

        image — image/png, image/jpeg, image/gif
        audio — audio/wav, audio/mpeg
        video — video/mp4, video/ogg
        application — application/json, application/pdf, application/xml, application/octet-stream

        GET /articles/23
        Accept: text/html, application/xhtml
        Поле заголовка Accept в этом случае говорит о том, что клиент примет содержимое в text / html или application / xhtml.

    -Пути
    Запросы должны содержать путь к ресурсу, над которым должна выполняться операция.  
    В RESTful API пути должны быть спроектированы так, чтобы помочь клиенту знать, что происходит.

    -Отправка ответов
    -В случаях, когда сервер отправляет полезные данные клиенту, 
    сервер должен включать тип содержимого в заголовок ответа. 
    Это поле заголовка типа содержимого предупреждает клиента о типе данных, 
    которые он отправляет в теле ответа.  Эти типы контента являются типами MIME, 
    как и в поле accept заголовка запроса.  
    Тип содержимого, который сервер отправляет обратно в ответе, должен быть одним из параметров,
    указанных клиентом в поле accept запроса.

    Например, когда клиент обращается к ресурсу с идентификатором 23 в ресурсе статей с этим запросом GET:
    GET /articles/23 HTTP/1.1
    Accept: text/html, application/xhtml
    
    Сервер может отправить обратно контент с заголовком ответа:
    HTTP/1.1 200 (OK)
    Content-Type: text/html

    -Коды ответов
        Ответы сервера содержат коды состояния, предупреждающие клиента об успешном выполнении операции.  
        Код состояния Значение
        200 (OK) Это стандартный ответ для успешных HTTP-запросов.
        201 (СОЗДАНО) Это стандартный ответ на HTTP-запрос, в результате которого элемент был успешно создан.
        204 (NO CONTENT) Это стандартный ответ для успешных HTTP-запросов, когда в теле ответа ничего не возвращается.
        400 (ПЛОХОЙ ЗАПРОС) Запрос не может быть обработан из-за неправильного синтаксиса запроса, чрезмерного размера или другой ошибки клиента.
        403 (ЗАПРЕЩЕНО) У клиента нет разрешения на доступ к этому ресурсу.
        404 (НЕ НАЙДЕН) В данный момент ресурс не может быть найден.  Возможно, он был удален или еще не существует.
        500 (ВНУТРЕННЯЯ ОШИБКА СЕРВЕРА) Общий ответ на непредвиденный сбой, если нет более конкретной информации.

    Для каждого HTTP-глагола есть ожидаемые коды состояния, которые сервер должен вернуть в случае успеха:
        GET - вернуть 200 (ОК)
        POST - возврат 201 (СОЗДАН)
        PUT - возврат 200 (ОК)
        УДАЛИТЬ - вернуть 204 (НЕТ КОНТЕНТА) Если операция завершилась неудачно, вернуть наиболее конкретный возможный код 
        состояния, соответствующий возникшей проблеме.






// ОБРАТИТЬ ВНИМАНИЕ (подводные камни) (+ см. статью Хабр https://habr.com/ru/company/mailru/blog/314804/)
    1 Строки - иммутабельны (неизменяемы). Поэтому код, модифицирующий элемент строки, не пройдет компиляцию:
        func main() {
            s := "abc"
            modify(s)
            fmt.Println(s)
        }

        func modify(a string) {
            a[0] = '3'
        }

        Строки Go являются неизменяемыми и ведут себя как байтовые срезы только для чтения (с несколькими дополнительными свойствами).
        Чтобы обновить данные, используйте взамен срез рун.
            buf := []rune("hello")
            buf[0] = 'H'
            s := string(buf)
            fmt.Println(s)  // "Hello"
        Если строка содержит только символы ASCII, вы также можете использовать байтовый срез, поскольку каждый ASCII символ занимает 
        только 1 байт.
        
        Строка может быть ключом карты. Одно из свойст ключа карты - сравнимость. Поэтому, чтобы сторки можно было использовать 
        в качестве ключей мапы, их делают неизменяемыми. Иначе пришлось бы "изобретать механизм уведомления контейнера (мапы) об изменении ключа"


    Еще пример (Код не скомпилируется):
        func main() {
            var s []byte = "abc"
            modify(s)
            fmt.Println(s)
        }

        func modify(a []byte) {
            a[0] = '3'
        }
        Строку можно преобразовать в слайс байтов. Но это преобразование должно быть явным - []byte("abc")
        Поскольку это преобразование отсутствует, код не скомпилируется.



    2 Чтение с помощью Scanf
        fmt.Scanf("%s", &row) // пробел считается разделителем, и при вводе строки "а в ц" сохранит только слово до пробела
        fmt.Println(row)

        Аналогично, до пробела считывает:
        var input string
        fmt.Scanln(&input)

        Используйте вместо этого
        myscanner := bufio.NewScanner(os.Stdin)
        myscanner.Scan()
        input := myscanner.Text()


    3 Изменение структур а цикле - range vs for i:=0; i<len(a); i++
             type AA struct {
                a int
            }

            func main() {
                fmt.Println("Hello, 世界")
                buf := []AA{}
                for i := 0; i < 5; i++ {
                    buf = append(buf, AA{
                        a: i,
                    })
                }
                fmt.Println(buf)			// [{0} {1} {2} {3} {4}]

                for _, brand := range buf {
                    brand.a = 0
                }
                fmt.Println(buf)			// [{0} {1} {2} {3} {4}]            !!!!! ИСХОДНЫЙ СПИСОК НЕ ИЗМЕНИЛСЯ


                for i := 0; i < 5; i++ {
                    brand := buf[i]
                    brand.a = 0
                }
                fmt.Println(buf)            // [{0} {1} {2} {3} {4}]            !!!!! И ТУТ ТОЖЕ !!!! ИСХОДНЫЙ СПИСОК НЕ ИЗМЕНИЛСЯ

                // РЕШЕНИЕ 1
                for i := 0; i < 5; i++ {
                    brand := &buf[i]
                    brand.a = 0                                                 !!!!! использовать ссылку на ячейку в памяти
                }
                fmt.Println(buf)            // [{0} {0} {0} {0} {0}]       

                // РЕШЕНИЕ 2
                for i := 0; i < 5; i++ {
                    buf[i].a = 0                                                !!!!! напрямую обращаться к списку
                }
                fmt.Println(buf)			// [{0} {0} {0} {0} {0}]
            }


        АНАЛОГИЧНО С МАПАМИ!!!
            type AA struct {
                a int
            }

            func main() {
                buf := make(map[int]AA)
                for i := 0; i < 5; i++ {
                    buf[i] = AA{
                        a: i,
                    }
                }
                fmt.Println(buf)                // map[0:{0} 1:{1} 2:{2} 3:{3} 4:{4}]

                for i := 0; i < len(buf); i++ {
                    if aa, ok := buf[i]; ok {
                        aa.a = 7
                        // buf[i] = aa                     
                    }
                }

                fmt.Println(buf) // map[0:{0} 1:{1} 2:{2} 3:{3} 4:{4}] !!!! мапа не изменилась.!!!!

                // решение: раскомментить строку buf[i] = aa !Ё!!!!
            }

    4 Разыменовывание nil-указателя (PANIC):
        func main() {
            var b *bool           
            modify(b)
            fmt.Println(b)
        }

        func modify(b *bool) {
            *b = true
        }

        Zero-value для указателя - это nil. При попытке записать значение в *b, произойдет разыменовывание 
        nil-указателя, что приведет к панике panic: runtime error: invalid memory address or nil pointer dereference


    5 Код успешно аллоцирует память под переменную типа bool внутри функциии. Однако мы записываем адрес на новую память в копию аргумента.
     Копия аргумента уничтожится после выхода из функции. Поэтому в переменной b внутри функции main значение переменной остается неизменным - nil
        func main() {
            var b *bool
            modify(b)
            fmt.Println(b)              // <nil>
        }

        func modify(b *bool) {
            if b == nil {
                b = new(bool)
            }

            *b = true
        }


    6 Сравнение структур (ОК)
        type Point struct {
            X, Y int
        }

        func main() {
            var p Point

            if p == struct{X,Y int}{} {            // true
                fmt.Println("true")
            } else {
                fmt.Println("false")
            }
        }
        Мы объявили собственный тип Point на базе структуры из двух типов. 
        При этом вполне допустимо сравнивать Point с анонимной структурой такой же сигнатуры


    7 Конвертация структур (ОШИБКА КОМПИЛЯЦИИ)
            type Point struct {
                X, Y int
            }

            type AnotherPoint struct {
                X, Y int
            }

            func main() {
                var p Point

                if p == (AnotherPoint{}) {          // ошибка компиляции - сравнение разных типов
                                                    // решение: преобразовать тип и сравнить их
                                                    //  if p == Point(AnotherPoint{}) { ... }
                    fmt.Println("true")
                } else {
                    fmt.Println("false")
                }
            }
    

    8 Сравнение структур (ОШИБКА КОМПИЛЯЦИИ). Две переменных одного типа (структуры) являются сравнимым, если все поля этих структур сравнимы.
        type Point struct {
            X, Y     int
            Comments []string
        }

        func main() {
            var p Point

            if p == (Point{}) {             // Код не скомпилируется
                fmt.Println("true")
            } else {
                fmt.Println("false")
            }
        } 

        Объекты типа Point нельзя сравнивать ни с nil, ни друг с другом, поскольку в определении типа Point присутствует слайс []string, 
        который не поддерживает сравнение на равенство.


    9 Zero-value для указателя на структуру (OK)
        type Point struct {
            X int
        }

        func (p *Point) Description() string {          // тип получателя - *Point. В случае с "var p *Point" - типы совпадают
                                                        // в случае с "var p Point" - типы не совпадают, и то перед вызовом функции Description()
                                                        // получатель p - берет указатель на неявно передаваемую структуру                            
            return "Hello"
        }

        func main() {
            var p *Point                                // можно и так написать: var p Point (будет работать и выводить "Hello")
            fmt.Println(p.Description())                // Hello
        }

        Zero-value для типа *Point - nil. Поскольку тип получателя совпадает с типом переменной var p *Point, то nil передается 
        в качестве неявного аргумента функции Description "как есть". Поскольку он никак не используется, то никаких ошибок во время выполнения 
        не происходит.


    10 Разыменование nil-указателя (PANIC)
        type Point struct {
            X int
        }

        func (p Point) Description() string {
            return "Hello"
        }

        func main() {
            var p *Point
            fmt.Println(p.Description())
        }

        Zero-value для типа *Point - nil. Поскольку тип получателя функции не совпадает с типом переменной var p *Point,
        то перед вызовом функции Description происходит разыменовывание nil-указателя, которое приводит к панике panic: 
        runtime error: invalid memory address or nil pointer dereference


    11 Особенности передачи аргументов в горутины (в т.ч. в замыкания) - https://habr.com/ru/company/badoo/blog/468863/
        values := []int{1, 2, 3}
        
        for _, val := range values {
            go func() {
                fmt.Println(val)                // выведет 3 3 3
            }()                                 // это так, поскольку горутины не успели запуститься,
                                                // а переменные, объявленные в инициализирующем операторе, переиспользуются (!!!!!!)
                                                // в каждом цикле, т.е. цикл закончится быстрее, чем запустятся горутины
        }
        
        исправим это, явно передав (скопировав) значение переменной i в горутину:
        for _, val := range values {
            go func(val string) {
                fmt.Println(val)                // передали val по значению: 1, 2, 3
            }(val)
        }



    12 Передача по указателю (копии указателя) и по значению
        func foobyval(n int) {
            fmt.Println(n)
        }

        func main() {
            for i := 0; i < 5; i++ {
                go foobyval(i)                  // передаем по значению (скопировали). 
                                                // Результат - значения от 0 до 4 в случайном порядке. 
            }

            time.Sleep(100 * time.Millisecond)
        }

        НО, если в main передавать i в горутину по указателю (копии указателя):
        for i := 0; i < 5; i++ {
            go foobyref(&i)                 // выведется 5 5 5 5 5
        }
        Это так, поскольку мы передаем указатель на число в функцию foobyref.
        Во время работы цикл заканчивается быстрее, чем любая из созданных горутин начинает работать. 
        Когда они начнут работать, у них будет указатель на ту самую переменную i, а не на копию. 
        И какое же значение у i в этот момент? Значение 5. То самое, на котором у нас остановился цикл. 
        И вот почему все горутины выводят 5.



    13 Методы типов/структур со значением VS методы с указателем
        type MyInt int

        func (mi MyInt) Show() {            // в таком случае функция-приемник работает с копией mi
            fmt.Println(mi)                 
        }

        func main() {
            ms := []MyInt{50, 60, 70, 80, 90}
            for _, m := range ms {
                go m.Show()                 // в цикле range в переменную m копируется значение из ms
                                            // каждая копия m в горутине вызывает метод Show()
                                            // Результат: выводит элементы массива ms в рандомном порядке
            }

            time.Sleep(100 * time.Millisecond)
        }

        НО, если функция-приемник будет принимать ссылку на переменную типа:
            func (mi *MyInt) Show() {
               fmt.Println(*mi)
            }

            for _, m := range ms {
                go m.Show()
            }
        то, в примере выше go m.Show() выведет 90 пять раз !!!!!!!!!!!!!!!
        это так, поскольку функция-приемник работает с ссылкой, которая в процессе работы цикла - изменяется.
        Во время работы цикл заканчивается быстрее, чем любая из созданных горутин начинает работать. 
        Когда они начнут работать, указатель m будет указывать на значение ms из последней итерации (90)
        


    13 Замыкания. Как компилятор "захватывает переменные" в замыканиях (то есть свободные переменные, используемые 
        в замыканиях) - по указателю (копии указателя) или по значению при передаче явно "по значению"?
        - ПО УКАЗАТЕЛЮ (копии) - если переменная, передаваемая в замыкание, ИЗМЕНЯЕТСЯ
        - ПО ЗНАЧЕНИЮ - иначе.

        func foobyval(n int) {
            fmt.Println(n)
        }

        (!) Захват переменной i КОМПИЛЯТОРОМ "по указателю" (копии указателя) - т.к. переменная МЕНЯЕТ (!) 
        свое значение после вызова в цикле - т.е. переменная i - переиспользуется на каждой итерации
        
        func main() {
            for i := 0; i < 3; i++ {
                go func() {
                    foobyval(i)                 // в замыкании передаем i по значению (!) в функцию внутри замыкания
                }()                             // выведет 3 3 3, даже несмотря на то, что передали по значению
            }

            time.Sleep(100 * time.Millisecond)
        }

        
       (!) Захват переменной i КОМПИЛЯТОРОМ "по значению" - т.к. переменная ii является явной копией i и НЕ МЕНЯЕТСЯ (!)
        func main() {
            for i := 0; i < 3; i++ {
                ii := i
                go func() {                     // в замыкании передаем i по значению (!) в функцию внутри замыкания
                    foobyval(ii)                // НО! код ниже выведет 1 2 3 в случайном порядке!!!!
                }()                             // Оказывается, что данное поведение является артефактом эвристики,
                                                // которую компилятор Go использует, когда работает с замыканиями
            }
        }

        // ii явно не переиспользуется при каждой итерации
    


        НО! Модифицируем пример выше:
            func foobyval(n int) {
                fmt.Println(n)
            }

            func main() {
                for i := 0; i < 5; i++ {
                    ii := i
                    go func() {
                        foobyval(ii)                // выведет 99 пять раз. Почему?
                    }()
                    ii = 99                         // меняем значение переменной в области видимости цикла.
                                                    // значит, как было показано выше, компилятор захватил 
                                                    // переменную ii "по указателю" (копии указателя)
                                                    // НО ПОЧЕМУ ВЫВЕЛОСЬ 99 пять раз?
                                                    // Возможно:
                                                    // цикл завершился, горутины еще не запустились
                                                    // перед запуском горутин последнее изменение ii = 99
                                                    // значит горутины будут запущены с этим значением
                }

                time.Sleep(100 * time.Millisecond)
            }
    
    
        // Что произойдет тут? TODO
        package main

        import (
            "fmt"
            "time"
        )

        func tst() {
            ch := make(chan string)         // после выхода из функции - ch не будет доступен? или же он будет захвачен горутиной?
            go func() {                 
                defer close(ch)
                time.Sleep(time.Second)
                fmt.Println("close chan")
            }()
            fmt.Println("end tst")
        }

        func main() {
            fmt.Println("Hello, 世界")
            tst()
            time.Sleep(2 * time.Second)
            fmt.Println("exit")
        }

        // выведет
            Hello, 世界
            end tst                 // вышли из функции
            close chan              // но канал закрылся без паники, значит закрылся не nil канал.
            exit                    // получается, при захвате переменной в горутине созданный вне горутины канал все еще остается доступным?
    
    
    
    
    




//  ТУЛИНГ (tooling)
    Ассемблерное представление для всех примеров из данной статьи получено с использованием команды 
        go tool compile -l -S
            Флаг -l отключает инлайнинг функций и делает ассемблерный код более читаемым.







// АСИНХРОННОЕ ПРОГРАММИРОВАНИЕ
    Асинхронное программирование — это когда операции вашей программы выполняются не строго последовательно,
    а могут быть прерваны какими-то другими операциями вашей же программы.Самым известным примером асинхронного программирования
    является технология Ajax — асинхронный JavaScript и XML, когда во время запроса на сервер ваша страница не замораживается,
    а продолжает работать. 

    Context switch (Переключение контекста - дорогая операция - в кеше может и не быть запрашиваемых процессором данных):
        -Процессор выполняет только одну задачу одновременно
        -Планировщик задач переключает их
        -Для этого надо выгрузить одну задачу (тред, процесс) и загрузить другую
        -Для этого может потребоваться обращение к основной памяти

    подход к вытеснению одной программы другой, это называется вытесняющей многозадачностью

    // cgi-bin (тяжелая операция)
    -одно соединение - один процесс
    -если много запросов - упремся в память
    
    cgi-bin — на каждый запрос
    поднимается новая программа, создается новый процесс (!), это тяжелая операция, это нужно подключить довольно много памяти.
    Там выполняется какой-то запрос, и после этого программа убивается.
    Это может быть очень не эффективно,  потому что при увеличении количества запросов мы
    начнем тратить много времени на создание и завершение процессов и можем банально упереться в количество оперативной памяти. 

    // worker pool
    Эволюцией этого подхода является worker pool,
    когда у нас есть некое количество процессов (!), которые не убиваются после
    завершения работы, а остаются в ожидании следующего запроса. 

    // мультитрединг
    Это значит, что мы уже создаем не целый процесс(!!) на один
    запрос или одно соединение, а всего лишь тред (!поток).
    Тред — это более легкая сущность, чем процесс.
    + Тред имеет доступ к памяти своего процесса, То есть
    вы можете переиспользовать какие-то соединения, например, к базе данных.
    + Тред занимает меньше памяти,
    но для процессора это тоже системный тред,
    он тоже выполняется процессором, его тоже нужно переключать context switch.
    
    Таким образом, за счет хотя бы экономии памяти
    мы можем обработать большее количество запросов.
    Также эволюцией тут является то,
    что мы можем создать worker pool и обрабатывать запросы,
    не плодя бесконечно новые треды,
    а распределять запросы по фиксированному количеству.
    Может быть, это как-то можно ускорить? 

    Основное время на современном web api уходит на
    ожидание внешних сервисов (запроса от какой-то удаленной базы данных, от какого-то веб-сервиса)

    // Неблокирующий ввод-вывод.
    Когда мы отправили запрос в базу данных,
    мы на этом не блокируемся, мы продолжаем (!) выполнять какие-то
    другие запросы, потому что процессор у нас бездействует.
    Таким образом, мы можем получить очень хорошую производительность. 
    Мы можем обрабатывать много запросов внутри одного треда

    Дело в том, что, поскольку у нас тред один,
    то мы никак не можем выполнять параллельно запросы.
    В случае с вытесняющей многозадачностью,
    когда тред блокируется, какой-то другой тред работает.
    В случае с кооперативной многозадачностью в этом случае, то мы должны
    дождаться окончания работы запроса № 1 для того,
    чтобы выполнять запрос № 2, и
    это может быть плохо,
    если у нас много операций на ЦПУ.
    Например, мы считаем какие-то хеши, занимаемся шифрованием либо
    архивированием, потому что это тяжелая процессорная операция, и нам будет не
    хватать того времени, которое мы проводим в ожидании ответов от базы данных.
    Нам будет не хватать времени для обработки всех операций, всех запросов.
    Соответственно, хочется как-то разнести это на несколько ядер,
    для того чтобы, пока один тред занят, мы могли выполнять что-то в другом треде.
    То есть размасштабироваться.
    И именно такой подход реализован в Go.
    Основан он на модели, которая называется communicating sequential processes
    от Тони Хоара, и оперируем мы в этом подходе
    такой сущностью, как горутина.
    Горутина — это аналог сопрограммы, когда в одном системном
    треде может выполняться несколько горутин, несколько сопрограмм.
    При этом особенностью является то,
    что наша горутина может начать выполняться на одном треде,
    потом уйти в ожидание данных из базы и продолжить выполняться в другом системном
    треде, потому что первый системный тред занят уже какой-то другой горутиной.
    Этот подход позволяет получить очень хорошую производительность,
    очень хорошую пропускную способность.
    Это является одним из ключевых особенностей языка
    Go и одной из самых сильных его сторон. 













    // ГОРУТИНЫ
        «Горутина — это легковесный поток выполнения». Горутины легче, чем потоки, поэтому управление ими сравнительно
        менее ресурсозатратно.

        Горутина (goroutine) — это функция, выполняющаяся конкурентно с другими горутинами в том же адресном пространстве.
        Запустить горутину очень просто:
            go normalFunc(args...)          // начнет выполняться асинхронно с вызвавшим ее кодом.
        
        Горутины очень легковесны. Практически все расходы — это создание стека, который очень невелик, хотя при необходимости может расти.

        В среднем можно рассчитывать примерно на 4,5kb на горутину. То есть, например, имея 4Gb оперативной памяти, вы сможете 
        содержать около 800 тысяч работающих горутин.

        Горутина - это путь выполнения, который помещается в поток операционной системы, который в конечном итоге выполняется на каком-то ядре.  
        Начиная с версии 1.8, каждой горутине дается начальный 2048-байтовый блок непрерывной памяти, который формирует пространство ее стека.  
        Стек важен, потому что он обеспечивает пространство физической памяти для границ фрейма*, которые назначаются каждой отдельной функции.  
        Фрейм - отдельное пространство памяти для каждой соответствующей функции. Каждый фрейм позволяет функции работать
        в собственном контексте, а также обеспечивает управление потоком. Функция имеет прямой доступ к памяти внутри своего
        фрейма через указатель фрейма, но доступ к памяти за пределами своего фрейма требует косвенного доступа. 
        Чтобы функция могла получить доступ к памяти за пределами своего фрейма, эта память должна использоваться совместно с функцией.

        Когда функция вызывается, происходит переход между двумя фреймами. Код переходит из фрейма вызывающей функции во фрейм вызываемой
        функции. Если для вызова функции требуются данные, то эти данные должны быть перенесены из одного фрейма в другой.
        Передача данных между двумя фреймами в Go осуществляется «по значению».
        
        Горутины используются:   
        -Если нужна асинхронность. Например когда мы работаем с сетью, диском, базой данных, защищенным мьютексом ресурсом и т.п.
        -Если время выполнения функции достаточно велико (в зависимости от ситуации) и можно получить выигрыш,
            нагрузив другие ядра.

        https://habr.com/ru/post/141853/
        Каждая Машина работает в отдельном потоке и способна выполнять только одну горутину в момент времени. Число работающих Машин ограничено
        переменной среды GOMAXPROCS или функцией runtime.GOMAXPROCS(n int). По умолчанию оно равно 1. Обычно имеет смысл сделать его равным числу ядер.

        https://fooobar.com/questions/102728/what-exactly-does-runtimegosched-do
        При запуске программы Go без указания переменной среды runtime.GOMAXPROCS(n int), горутины запланированы для исполнения в одиночном потоке ОС. 
        Однако, чтобы программа казалась многопоточной (для чего предназначены goroutines, не так ли?), планировщик Go должен иногда переключать контекст
        выполнения, поэтому каждый горутин может выполнять свою работу.

    Создание горутин:
        1 Анонимная функция с параметром:
            go func(a int) {
                fmt.Print(a)
            }(a)
        2 Анонимная функция без параметра:
            go func() {
                fmt.Print("a")
            }()
        3 Вызов именнованной функции в горутине:
            go startWebServer()
        4 Вызов метода структуры
            go structur.Load()


    (!) Показать количество горутин:
        fmt.Println(
            runtime.NumGoroutine(),
        )

    Пример использования горутины - обработка каждого соединения для веб-сервера






        func say(s string) {
            for i := 0; i < 5; i++ {
                runtime.Gosched()
                fmt.Println(s)
            }
        }

        func main() {
            go say("world")
            say("hello")
        }

        результат:  hello
                    world
                    hello
                    world
                    hello
                    world
                    hello
                    world

        но, если удалить runtime.Gosched(), то программа больше не выводит world
        результат:  hello
                    hello
                    hello
                    hello
                    hello



    когда переменная GOMAXPROCS не указана (по умолчанию = 1), в Run runtime  разрешено использовать только один поток, 
    поэтому невозможно переключить контексты выполнения, в то время как goroutine выполняет некоторую обычную работу, 
    такую ​​как вычисления или даже IO (который отображается на простые функции C). Контекст можно переключать только тогда, 
    когда используются примитивы Go concurrency, например. когда вы включаете несколько chans или (это ваш случай), когда вы 
    явно указываете планировщику переключать контексты - для этого используется runtime.Gosched.

    Итак, короче говоря, когда контекст выполнения в одном goroutine достигает вызова Gosched, планировщику поручается 
    переключить выполнение на другой goroutine. В вашем случае есть два goroutines, main (который представляет "основной" 
    поток программы) и дополнительный, тот, который вы создали с помощью go say. Если вы удалите вызов Gosched, контекст 
    выполнения никогда не будет перенесен с первой goroutine на второй, следовательно, не будет вывода "world". Когда 
    присутствует Gosched, планировщик переносит выполнение на каждой итерации цикла с первой горуты на вторую и наоборот, поэтому у вас 
    есть "hello" и "world" interleaved.

    это называется "совместная многозадачность": goroutines должен явно передать управление другим goroutines. Подход, используемый в большинстве 
    современных ОС, называется "превентивной многозадачностью": потоки выполнения не связаны с передачей управления; планировщик переключает контексты 
    выполнения прозрачно для них. Кооперативный подход часто используется для реализации "зеленых потоков", то есть логических параллельных сопрограмм, 
    которые не отображают потоки 1:1 в ОС - это то, как реализовано время выполнения и его goroutines.
        
    Когда переменная GOMAXPROCS установлена ​​на положительное число N, время выполнения Go сможет создавать до N собственные потоки, по которым 
    запланированы все зеленые потоки. Собственная нить - это вид потока, который создается операционной системой (потоки Windows, pthreads и т.д.).
    Это означает, что если N больше 1, возможно, что goroutines будут запланированы для выполнения в разных собственных потоках и, следовательно,
    будут выполняться параллельно (по крайней мере, до ваших возможностей компьютера: если ваша система основана на многоядерных процессор, вполне 
    вероятно, что эти потоки будут действительно параллельными, если у вашего процессора есть одно ядро, тогда превентивная многозадачность, реализованная 
    в потоках ОС, создаст видимость параллельного выполнения).

    func main() {
        runtime.GOMAXPROCS(2)
        go say("world")
        say("hello")
    }
    
    В этом случае вы можете наблюдать интересные результаты. Возможно, что вы получите строки "hello" и "world", напечатанные чередующимися неравномерно,
    например:

    world
    world
    world
    world
    world
    hello
    hello
    hello
    hello
    hello

    или 

    hello
    hello
    hello
    hello
    hello

    Это может произойти, если goroutines планируют разделить потоки ОС. 
    Фактически, как работает превентивная многозадачность (или параллельная
    обработка в случае многоядерных систем): потоки параллельны, а их объединенный
    вывод является неопределенным. Кстати, вы можете оставить или удалить вызов
    Gosched, кажется, не имеет никакого эффекта, когда GOMAXPROCS больше 1.

    Похоже, что в новых версиях Go компилятора Go runtime заставляет goroutines
    выводить не только на использование примитивов concurrency, но и на системные 
    вызовы ОС. Это означает, что контекст выполнения может переключаться между 
    goroutines также на вызовы функций ввода-вывода. Следовательно, в последних 
    компиляторах Go можно наблюдать недетерминированное поведение, даже если 
    GOMAXPROCS не задано или установлено в 1.


    // https://habr.com/ru/post/141853/
    Исполнение горутины прерывается только тогда, когда она уже не может выполняться: то есть из-за системного 
    вызова или использования синхронизирующих объектов (операции с каналами, мьютексами и т.п.). 
    Не существует никаких квантов времени на работу горутины, после выполнения которых она бы заново возвращалась
    в очередь. Чтобы позволить планировщику сделать это, нужно самостоятельно вызвать runtime.Gosched().
    //
    for i:=0; i<10; i++ {
        go func() {
            for j:=0; j < 5; j++ {
                go func fmt.Println(j)
                runtime.Gosched()           // возможность передать управление другой горутине
            }
        }
    }

    На практике это в первую очередь означает, что иногда стоит использовать runtime.Gosched(), чтобы несколько
    долгоживущих горутин не остановили на существенное время работу всех других. С другой стороны, такие ситуации
    встречаются на практике довольно редко.

    Из горутины вы не можете вернуть никакое значение в основную программу, туда, где была вызвана эта горутина.
    Для этих целей используются каналы

    // Основная трудность при многопроцессорной разработке, то есть когда ваша программа использует несколько ядер 
    процессоров или даже несколько процессоров, состоит в том, что вам нужно как-то их синхронизировать между собой
    и каким-то образом передавать данные между разными потоками. В Go для этих целей есть каналы. 

    // Когда горутина переходит из одной очереди в другую (меняет тред), процессорный кеш теряется?


    // For + select Часто это используется чтобы читать из канала и смотреть на отмену контекста.






// СИНХРОНИЗИРУЮЩИЕ ОБЪЕКТЫ (каналы, мьютексы, примитивы синхронизации)
    КАНАЛЫ
        — это способ коммуникации между горутинами. 
        - это очередь сообщений, которая умеет работать в многопоточной среде

        Они используются, когда вы хотите передать результаты, ошибки или другую информацию от одной
        горутины другой. Каналы бывают разных типов, например, канал типа int получает целые числа, а канал 
        типа error — ошибки, и т.д.   

        В каналах можно передать все.

        (!) буфер канала недоступен для GC (GC не проверяет буфер канала, только указатель на сам канал )

        Аксиомы канала:
        - Отправка в нулевой канал nil блокирует навсегда.
        - Получение из нулевого канала nil блокируется навсегда.
        
        - Закрытие нулевого канала nil вызывает panic.
        
        - Отправка в закрытый канал вызывает panic.
        - Получение из закрытого канала немедленно возвращает нулевое значение типа канала (если буфер пустой).
        - Закрытие уже закрытого канала вызывает panic.
        
        - Запись в заполненный канал ведет к deadlock (если из канала никто не читает)*
        * когда горутина осуществляет попытку записи в канал, буфер которого полон, 
        рантайм переводит эту горутину в состояние “waiting”.

        Другими словами (аксиомы канала):
            deadlock:
                nil канал: запись и чтение

            panic:
                nil канал: закрытие
                закрытый канал: запись, закрытие


        Правила канала:
            1 Закрывает канал тот, кто в него пишет
            2 Если пишет несколько продюсеров, закрывает канал тот, кто создал его и продюсеров
            3 Не закрытый канал держит ресуры, закрывайте их явно: GC не соберет незакрытый канал, кроме того, произойдет утечка памяти:
                func main() {
                    ch := make(chan int)         
                    go myFunc(ch)
                    ...                         // пример не очень, но суть объясняет
                }

                func myFunc(ch <-chan int) {
                    <-ch                        // заблокировались для чтения. Получили повисший канал, повисшую горутину:
                                                // Утечка зключается в том, что горутина создана и не завершится. 
                                                // и память не освободится
                }





     
        Команда  |	Небуферизованный канал (не закрытый и не nil)   |	Буферизованный канал (не закрытый и не nil)  |	 Закрытый канал    | 	Нулевой nil канал
      -----------|--------------------------------------------------|------------------------------------------------|---------------------|------------------
     Отправлять  |	Блокировать, если нет соответствующего          |    Блокировать, если канал заполнен,           |        Паника 	   |  Заблокировать навсегда
                 |  получателя, в противном случае успех 	        |     в противном случае успех                   |    	               |  т.е. только объявили канал,
                 |                                                  |                                                |                     |  и сразу в него пишем
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------
     Получать 	 |   Блокировать, если нет соответствующего         |       Блокировать, если канал пуст,            | Получает значение   | Заблокировать навсегда 
                 |   отправителя, в противном случае успех 	        |          в противном случае успех              | типа данных по      |
                 |                                                  |                                                | умолчанию из        |
                 |                                                  |                                                | канала, если канал  |
                 |                                                  |                                                | пуст, иначе получает| 
                 |                                                  |                                                | фактическое         |
                 |                                                  |                                                | значение. 	       |
    --------------------------------------------------------------------------------------------------------------------------------------------------------------------
    Закрывать 	 |                  Успех 	                        |                           Успех 	             |      Паника 	       |        Паника
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------
        Длина 	 |                      0 	                        | Количество элементов в очереди в буфере канала |	-0, если           |        0
                 |                                                  |                                                |  небуферизованный   |
                 |                                                  |                                                | канал, иначе кол-во |
                 |                                                  |                                                | элементов в очереди |
                 |                                                  |                                                |  в буфере           |
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------                 
        Емкость  |  	                0 	                        |           Размер буфера канала 	             | -0, если            |        0
                 |                                                  |                                                |  небуферизованный   |
                 |                                                  |                                                |  канал. Иначе -     |
                 |                                                  |                                                |  размер буфера      |
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------                 




    // RANGE CHAN
        Также возможно перебирать значения, отправленные по каналу. Чтобы прервать такую итерацию, канал должен быть закрыт явно.
        (!) В противном случае range будет заблокирован навсегда так же, как и для nil-канала.
        
        for num := range ch {
            ...
        }


    Каналы под капотом:
        Рассмотрим пример с буферизированным каналом
            ch := make(chan int, 2)
            ch <- 42
            // структура канала
            type hchan struct {
                qcount   uint           // qcount определяет количество элементов в буфере (мы видим 1 т.к. записали одно значение в наш канал. 0 - для небуферизир. канала)
                dataqsiz uint           // размер буфера для буферизированного канала, в нашем случае это 2
                buf      unsafe.Pointer // buf — определяет буфер с данными, записанными в канал, реализованный с помощью структуры данных “кольцевой буфер”. 
                                            Используется только в буферизированных каналах.
                elemsize uint16         // elemsize — размер одного элемента в канале, в нашем случае это 8 байт
                closed   uint32         // closed — определяет закрыт или открыт канал в данный момент;
                elemtype *_type         // elemype — содержит указатель на тип данных в канале;
                
                sendx    uint           // sendx и recvx содержат индексы (смещения) в буфере, по которым должна 
                recvx    uint           // производиться запись и чтение из буфера соответственно; (откуда отправлять или куда класть новые данные)
                
                recvq    waitq          // sendq и recvq — односвязные списки,
                sendq    waitq          // содержащие заблокированные горутины, ожидающие чтения или записи;
                                        // для оптимизации при отправке\получении в\из канал(а):
                                            - пишушая горутина пишет значение напрямую в стек функции, которая читает (для небуф. канала, и для 
                                                буф. канала, когда буфер пуст)

                // lock protects all fields in hchan, as well as several
                // fields in sudogs blocked on this channel.
                //
                // Do not change another G's status while holding this lock
                // (in particular, do not ready a G), as this can deadlock
                // with stack shrinking.
                lock mutex  // lock — мьютекс, используемый для операций, изменяющих состояние канала
            }

            // В канале есть передача сообщения сразу на стек ожидающей горутины !
            // А зачем в канале нужен мьютекс? В hchan есть
            // // lock protects all fields in hchan, as well as several
            // fields in sudogs blocked on this channel.
            //
            // Do not change another G's status while holding this lock
            // (in particular, do not ready a G), as this can deadlock
            // with stack shrinking.
            //lock mutex
            // Потому что канал это очередь с мутексом
            // GC не ходит по объектам буфера канала


            type waitq struct {
                first *sudog           
                last  *sudog
            }

            // sudog это представление горутины которая стоит в очереди
            type sudog struct {
                // The following fields are protected by the hchan.lock of the
                // channel this sudog is blocking on. shrinkstack depends on
                // this for sudogs involved in channel ops.

                g *g

                // isSelect indicates g is participating in a select, so
                // g.selectDone must be CAS'd to win the wake-up race.
                isSelect bool
                next     *sudog
                prev     *sudog
                elem     unsafe.Pointer // data element (may point to stack)

                // The following fields are never accessed concurrently.
                // For channels, waitlink is only accessed by g.
                // For semaphores, all fields (including the ones above)
                // are only accessed when holding a semaRoot lock.

                acquiretime int64
                releasetime int64
                ticket      uint32
                parent      *sudog // semaRoot binary tree
                waitlink    *sudog // g.waiting list or semaRoot
                waittail    *sudog // semaRoot
                c           *hchan // channel
            }

            Создание канала происходит при помощи функции makechan
                Функция makechan выделяет память под структуру hchan в куче, инициализирует эту структуру,
                и возвращает указатель. И несмотря на то, что в go все передается по значению, передавать
                канал по ссылке бессмысленно, потому что под капотом канал — это и есть указатель.
            
            При записи в буферезированный канал, происходит следующее:
                -структура приобретает блокировку мьютексом;
                -в буфер копируется значение, которое мы положили в канал;
                -структура освобождается от блокировки мьютексом;
            
            И стоит обратить внимание на то, что при добавлении в буфер, элемент копируется.
            При чтении из канала, последовательность действий аналогичная:
                -структура приобретает блокировку мьютексом;
                -из слота буфера копируется значение с последующим удалением;
                -структура освобождается от блокировки мьютексом.

            Копирование значений при записи в буфер/чтении из буфера гарантирует нам
            отсутствие разделяемой памяти. Поэтому единственная разделяемая память, которая 
            присутствует в канале — это сама структура hchan, которая, однако, блокируется 
            встроенным в структуру мьютексом.

        Почему при заполнении буфера, последующая попытка записи в канал приведет к приостановке потока
        выполнения пишущей горутины?
            Ответ: Поскольку создание и управление горутинами — это зона ответственности runtime самого Go, 
            то runtime может без труда приостанавливать выполнение одной горутины, и запускать выполнение другой.
            Итак, когда горутина осуществляет попытку записи в канал, буфер которого полон, рантайм переводит эту горутину в состояние “waiting”.

        Как рантайм узнает, что нужно продолжить выполнение нашей горутины (т.е. запись в канал возможна, другая горутина 
        прочитала из переполненного канала)?
            Ответ: Для дальнейшего понимания процесса ожидания, нам нужно рассмотреть вспомогательную структуру sudog:
                    // sudog представляет заблокированную горутину, ожидающую чтения или записи
                    type sudog struct {
                        g *g                    // ссылка на горутину
                        elem     unsafe.Pointer // данные для записи   
                        // ...
                    }
            Мы видим, что канал содержит в себе ссылку на ожидающую горутину, представленную структурой sudog.
            Эта структура помещается в односвязный список waitq. И когда буфер становится доступным для заполнения, происходит следующее:
                очередная структура, представляющая ожидающую горутину sudog извлекается из списка waitq;
                данные из поля elem добавляются в буфер канала;
                горутина из sudog переходит из состояния “waiting” в состояние “runnable” (готова к выполнению).

        Что происходит при попытке чтения из канала, буфер которого пуст?
            Ответ:  
                Для горутины, осуществляющей попытку чтения из канала, создается структура sudog;
                Горутина переходит в состояние “waiting”
                Односвязный список recv пополняется структурой sudog;

            Стоит отметить, что в поле elem структуры sudog содержится адрес памяти, в который будет записано значение из канала. 
            Этот факт пригодится для дальнейшего понимания процесса.
            
        Что происходит при попытке записи в канал, буфер которого пуст?
            Когда другая горутина записывает данные в канал, последовательность действий отличается:
                Данные не пишутся в буфер, а пишутся напрямую в стек читающей горутины;
                Читающая горутина переходит из состояния “waiting” в состояние “runnable” (готова к выполнению).

            Такой подход позволяет сократить накладные расходы на блокировку буфера мьютексом. 
            Сам буфер также остается нетронутым, и не проиходит дополнительных операций копирования.



        Далее рассмотрим НЕБУФЕРИЗИРОВАННЫЕ каналы 
            Для небуферизированных каналов Go не аллоцирует буфер, поэтому в структуре hchan параметр buf будет пустым,
            как и размерность буфера(dataqsiz)

            func main() {
                ch := make(chan bool)

                go func() {
                    time.Sleep(time.Second)
                    ch <- true
                }()
                <-ch
            }

            Что происходит при попытке чтения из небуферизированного канала?
            Ответ: Когда произойдет попытка чтения из канала основной горутиной (main), main заблокируется рантаймом языка golang — выполнение
                   main приостановится до тех пор, пока другая горутина не осуществит запись в канал ch. Далее, запущенная горутина
                   при записи в канал ch выполняет следующие шаги:
                        -проверяет структуру recv;
                        -находит в ней ожидающую горутину (в нашем случае, это функция main);
                        -удаляет горутину main из списка recv;
                        -пишет напрямую в стек функции main (с целью оптимизации памяти — экономия одной операции копирования)
                   
                   После этого канал ch имеет состояние такое же, как и сразу после инициализации канала. 
                   Обе горутины завершают свое выполнение, и вместе с ними завершает свое выполнение программа.

        
        
        Закрытие канала (close channel, close())
            За закрытие канала отвечает функция closechan из файла chan.go.
            Набор действий, выполняемых при закрытии канала:
                -выполняется проверка, что канал инициализирован (panic в случае, если канал не инициализирован);
                -захватывается блокировка мьютекса;
                -выполняется проверка, что канал не закрыт (panic в случае, если канал уже закрыт);
                -значение поля closed канала (в структуре hchan) выставляется в true;
                -все структуры, ожидающие чтения, получают default value в зависимости от типа данных в канале;
                -все структуры, ожидающие записи, получают panic;
                -мьютекс канала разблокируется;
                -заблокированные горутины — разблокируются.




    
            ch1 := make(chan int)       // небуферизированный канал:
            
            Это значит, что, когда я кладу в канал какое-то значение,
            кто-то с другой стороны этого канала должен его прочитать.
            И если никто не читает, то горутина блокируется,
            до тех пор пока на той стороне не появится тот,
            кто вычтет это значение.
            К чему это можем привести?
            Привести это может к тому, что мы залочимся. 

            Но в случае если в deadlock попадут какие-то другие горутины
            внутри вашей программы, а другие горутины будут
            продолжать работать, которые будут выполнять совершенно другую работу,
            то может прийти ситуация, которая называется утечка горутин,
            то есть горутина залочилась и чего-то ждет, но никогда не дождется.
            Это приводит к утечке памяти (!)
            
            канал может принимать не одно значение,
            до того как он залочится, а несколько.
            Осуществляется это если мы укажем значение буфера для этого канала
            ch2 := make(chan int, 1)        // буферизированный канал

            !! буферизированный канал заблокируется (deadlock?), если 
            - буфер переполнен для пишущей стороны
            - буфер пуст для читающей стороны


            // закрытие канала
            close(ch1)

            ch1 := make(<-chan int, 3)
            close(ch1)              // invalid operation: close(ch1) (cannot close receive-only channel)
        (!) невозможно закрыть канал, из которого только читают!!!

            // если где-то происходит итерирование данных из канала:
            for i:= range ch1 {
                fmt.Println(i)
            }
            // и в другой горутине что-то писалось в канал, то произойдет deadlock, т.к. в цикле ждем сообщений в канале, 
            // но никто ничего уже писать туда не будет. Поэтому, необходимо вызывать close(ch1) в пишушей горутине, тогда 
            // цикл завершится

            // FAQ каналы:
            при попытке чтения из закрытого канала (!):
            -Происходит мгновенный возврат значения по-умолчанию для типа который находится в данном канале 
            и признака того что канал был закрыт
            
            при попытке записи в закрытый канал (!):
            -Происходит паника

            Когда может завершиться цикл по буферизированному каналу?
            -Когда канал будет закрыт при помощи функции close
            -При ручном прерывании цикла при помощи оператора break

            Что будет, если в буферизированный канал переполнить?
            func main() {
                c := make(chan int, 2)
                c <- 1
                c <- 2
                c <- 3
            }
            -произойдет deadlock (так как никто не читает с канала и не освобождает буфер)!

            А если заполнить буфер и выйти?
            func main() {
                c := make(chan int, 2)
                c <- 1
                c <- 2
                fmt.Println("Hello, playground")
            }
            -программа отработает нормально

            После закрытия канала вы не можете записать в него новые значения 
            (будет сбой при попытке), и любое чтение вернется сразу с нулевым значением для типа канала
            
            nil каналы:
                Установка переменной канала в nil просто устанавливает значение переменной в nil, 
                оставляя канал, на который она ранее ссылалась, инициализированным. Это то же самое, 
                что установить для любой другой переменной значение nil. Если есть другие ссылки на канал,
                вы все равно можете получить к нему доступ. Если их нет, он будет обработан сборщиком мусора. 
                Кроме того, nil и закрытые каналы ведут себя по-разному при записи или чтении.

                // deadlock
                var c chan int
                c <- 1

                // deadlock
                var c chan int
                fmt.Println(<-c)

                Если закрыть канал nil, произойдет сбой.
                // panic: close of nil channel
                var c chan int
                close(c)




    // Направление каналов
        Мы можем задать направление передачи сообщений в канале, сделав его только отправляющим или принимающим. 
        Например, мы можем изменить функцию pinger:

        func pinger(c chan<- string)        // можем только писать в канал

        и канал c будет только отправлять сообщение. Попытка получить сообщение из канала c вызовет ошибку компилирования. 
        Также мы можем изменить функцию printer:

        func printer(c <-chan string)       // можем только читать из канала
    (!) невозможно закрыть канал, из которого только читают!!!

        Существуют и двунаправленные каналы, которые могут быть переданы в функцию, принимающую только принимающие или
        отправляющие каналы. Но только отправляющие или принимающие каналы не могут быть переданы в функцию, требующую двунаправленного канала!




    // буферизированный канал
        буферизированный канал с ёмкостью 1. Обычно каналы работают синхронно - каждая из сторон ждёт, когда другая сможет
        получить или передать сообщение. Но буферизованный канал работает асинхронно — получение или отправка сообщения не 
        заставляют стороны останавливаться. Но канал теряет пропускную способность, когда он занят, в данном случае, если мы 
        отправим в канал 1 сообщение, то мы не сможем отправить туда ещё одно до тех пор, пока первое не будет получено.

        c := make(chan int, 1)

        // Если закрыть буферизированный канал в котором еще есть в очереди данные, то если из этого канала продолжать читать,
        // то сначала мы вычитаем оставшиеся данные, а потом будет читаться дефолтное значение.


        // Горутины, многопоточность, deadlocks
        !!! Важно не читать и не писать в один канал, созданный в одном потоке: deadlock
        НЕТ ДРУГИХ ПОТОКОВ, КОТОРЫЕ МОГЛИ БЫ ЗАПИСАТЬ В ЭТОТ КАНАЛ

        func main() {
            ch := make(chan string)
            sayHello(ch)    // ДЛЯ КОРРЕКТНОЙ РАБОТЫ ЭТОГО КОДА НЕОБХОДИМО функцию сделать горутиной: go sayHello(ch)
            <-ch        // считываем (все в одном потоке)
        }

        func sayHello(exit chan string) {
            fmt.Print("hello")
            exit <- "gg bb" // записываем (все в одном потоке)
        }

        // Закрытие канала:
        func main() {
            ch := make(chan string)
            go sayHello(ch)
            
            // работает до закрытия потока функцией close(ch)
            for i := range ch {
                fmt.Println(i)
            }
        }

        func sayHello(exit chan string) {
            for i := 0; i < 5; i++ {
                time.Sleep(100*time.Millisecond)
                exit <- i
            }
            close(exit)
        }

        // deadlock part 2!!!!!!!!

        func main() {
            c1 := make(chan int)
            c2 := make(chan int)
            c3 := make(chan int)


            // DEADLOCK! т.к. каналы инициализированы, в канал пишется значение, но его никто не читает (управление не дошло до горутины,
            // которая способна читать из c1). Решение: Перенести код после объявления и запуска горутин. Тогда в отдельном потоке 
            // из канала c1 будет ожидаться чтение, после чего в канал поступит значение
            // c1 <- 1


            go func() {
                for _, value := range []int{1, 4, 7} {
                    <-c1
                    fmt.Println(value)
                    c2 <- 1
                }
            }()

            go func() {
                for _, value := range []int{2, 5, 8} {
                    <-c2
                    fmt.Println(value)
                    c3 <- 1
                }

                //wg.Done()
            }()

            go func() {
                for _, value := range []int{3, 6, 9} {
                    <-c3
                    fmt.Println(value)
                    c1 <- 1
                }

                //wg.Done()
            }()

            // А вот так работать будет!!!!
            c1 <- 1

            var input string
            fmt.Scanln(&input)
        }






// Шаблоны использования каналов
    1 Сбор данных из нескольких источников

        func producer(ch chan <- string) { 
            // пишем в канал ch
        }
        
        func main() {
            ch := make(chan string)
            for i:=0; i<10; i++ {
                go producer(ch)             
            }

            for x := range ch {
                // Обработка собранных данных из канала
            }
        }


    2 Раздача заданий для обработки нескольким воркерам
        
        func consumer(ch <-chan string) {
            // читаем из канала ch 
        } 

        func main() {
            ch := make(chan string)
            for i:=0; i<10; i++ {
                go consumer(ch)             
            }

            for {
                ch <- "abc"     // заполняем канал задачами для воркеров
                ...
            }
        }


    3 Синхронизация потоков выполнения

        func worker(ch <-chan int) {
            for {
                v, ok := <- ch
                if !ok {
                    return
                }
                
                fmt.Println(v)
                time.Sleep(time.Second)
            }
        }

        func main() {
            ch := make(chan int, 5)
            
            go worker(ch) 

            for i:=0; i<100; i++ {
                ch <- i
            }

            close(ch)
            ...
        }


    4  Завершение работы сервиса через сигналы ОС
        
        c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt)

        for {
            select {
                case <- c:                  // завершение работы
                    // приберем за собой
                    return
                case data, ok <- dataChan:
                    if !ok {                // если канал стал закрыт
                        fmt.Println("Внештатная ситуация, завершаемся")
                    }
                    // иначе - обработка данных
            }
        }









// Мультиплексирование каналов через оператор select (SELECT в горутинах)
    Select тоже что и switch, но работает с каналами. Он случайно 
    выбирает готовый для взаимодействия канал.

    Select - неблокирующий, если все case - неблокирующие, либо есть default.

    (!) можем как читать из канала, так и писать в него! 
    select {
        case <- chan1:
            // Если chan1 успешно прочитал данные, переходим к оператору обработки case
        case chan2 <- 1:
            // Если chan2 успешно записывает данные, переходим к оператору обработки case
        default:
            // Если ничего из вышеперечисленного не помогло, введите поток обработки по умолчанию
    }

    Если ни один из операторов не может быть выполнен (то есть все каналы заблокированы), возникнут две ситуации:
    Если есть оператор по умолчанию, то выполняется оператор по умолчанию, и выполнение программы возобновится с оператора после оператора select.
    (!) Без оператора по умолчанию оператор select будет заблокирован до тех пор, пока не будет продолжено хотя бы одно взаимодействие.



    select под капотом:
        Каждый элемент внутри оператора select представлен структурой scase:
        type scase struct {
            c           *hchan         // Канал
            elem        unsafe.Pointer // Ссылка на данные
            kind        uint16         // Тип операции (получение, запись или default)
            // ...
        }

        Последовательность действий при обработке оператора select следующая:
            1 Элементы(scase) внутри select сортируются в случайном порядке(перемешиваются):

                for i := 1; i < ncases; i++ {
                    j := fastrandn(uint32(i + 1))
                    pollorder[i] = pollorder[j]
                    pollorder[j] = uint16(i)
                }

            2. Каждый из каналов блокируется мьютексом.
            3. Происходит последовательная попытка взаимодействия (запись или чтение) с каналами, перечисленными внутри 
                оператора select. При наличии секции default, чтение и запись происходят в неблокирующем режиме(об этом далее).
            4. В случае, если ни один из каналов недоступен для взаимодействия, и секция default отсутствует, то текущая горутина 
                переходит в состояние waiting до тех пор, пока какой то из каналов не станет доступен.
            5. С каналов снимается блокировка мьютексом.

        Почему при наличии секции default внутри оператора select, каналы опрашиваются в неблокирующем режиме? 
        Почему выполнение горутины не приостанавливается на попытке записи или чтения канала, если запись или чтение в данный момент невозможны?
        Ответ кроется в функциях chanrecv и chansend, которые отвечают непосредственно за чтение из канала и отправку данных в канал:
            func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... }
            func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { ... }

        Здесь нас интересует параметр block. При наличии секции default в операторе выбора select, функции chansend и chanrecv вызываются с 
        параметром block равным false, в итоге функции осуществляют быстрый возврат в случае, если записать в канал или прочитать из канала 
        без ожидания не удалось:
            
            if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||
                c.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&
                atomic.Load(&c.closed) == 0 {
                return
            }

        В качестве оптимизации, при таком подходе канал не блокируется мьютексом, вместо этого используются атомарные операции.
        На этом все. Теперь вы понимаете не только как использовать каналы, но и их внутренюю реализацию, а значит сможете использовать их более эффективно.


    Оператор «break» завершает выполнение самого внутреннего оператора «for», «switch» или «select».

    L:
    for i < n {
        switch i {
        case 5:
            break L
        }
    }

    for {
        select {
        // select в бесконечном цикле ждет сообщения из канала. Следующая итерация цикла не выполняется, до тех пор,
        // пока в одном из каналов не появится сообщение
        case msg1 := <-c1:
            fmt.Println(msg1)
        case msg2 := <-c2:
            fmt.Println(msg2)
            // ИЛИ появляется сообщение (cases 1,2) ИЛИ выполняется case 3 с таймаутом 1с: time After создаёт канал, по которому посылаем метки времени с заданным интервалом.
        case <-time.After(time.Second):
        	fmt.Println("timeout")
            // дефолтное значение будет выполняться очень быстро: Выполняемые по умолчанию команды исполняются сразу же, если все каналы заняты.
            default:
            	fmt.Println("nothing ready")
        }
    }

    // FAQ
    (!) В случае, если результат есть нескольких каналах внутри select'а - какой из них будет выбран?
        Случайный 








    // Инструменты для многопроцессорного программирования
        // Таймер и таймаут

        У таймера есть канал, и в случае если мы будем использовать
        мультиплексор select, то мы можем поставить на
        чтение с этого канала, и как только наступит нужное время,
        там появится событие, и он сработает. 
        
        timer := time.NewTimer(1*time.Second)
        select {
            case <-timer.C:             // канал таймера
                fmt.Println("timer.C timeout happened")

            // У NewTimer есть короткое объявление,
                когда нам сразу же возвращается канал без 
                промежуточной переменной.
                Но у них есть небольшие особенности.
                Мы можем остановить timer от выполнения (!),
                а time.After мы остановить не можем (!), и пока он не выполнится,
                даже если мы завершили функцию, он не освободит ресурсы.
                Поэтому если вам нужно лучше контролировать расход ресурсов,
                расход памяти, пользуйтесь простым таймером и останавливайте его,
                когда вам это требуется. 

            case <-time.After(time.Minute):
                // пока не выстрелит - не соберется сборщиком мусора
                fmt.Println("timer.After timeout happened")

            case result := <-longSQLQuery():       
                // освобождает ресурс
                if !timer.Stop() {
                    <-timer.C
                }
                fmt.Println("operation result:", result)
        } 


        // Переодические события — это значит, что с определенным интервалом
        времени вам приходят события, и вы что-то делаете в это время.
        Делается это через конструкцию ticker,
        она тоже находится в пакете time, ее можно создать через NewTicker.
        Если вы читаете из канала, который предоставляет ticker,
        то вам возвращается время, когда было срабатывание. 

        // ждем 5 секунд, каждую секунду идет вывод
        ticker := time.NewTicker(time.Second)
        i := 0
        for tickTime := range ticker.C {
            i++
            fmt.Println("step", i, "time", tickTime)
            if i >= 5 {
                // надо останавливать
                ticker.Stop()
                break
            }
        }
        fmt.Println("total", i)


        // у тикера есть короткий alias,
        time.Tick, который Вам возвращает сразу канал,
        с которого вы можете читать, но у него есть особенность: он работает бесконечно,
        вы никак не можете его освободить (!). 
        
        c := time.Tick(time.Second)
        i = 0
        for tickTime := range c {
            i++
            fmt.Println("step", i, "time", tickTime)
            if i >= 5 {
                break
            }
        }

        // Его надо использовать тогда, когда вы точно не планируете его останавливать.
        Например, для сбора какого-то мониторинга с вашей программы,
        то есть который запускается каждую минуту, собирает метрики и куда-то их отсылает. 
        

        // AfterFunc, запускает функцию через определенный промежуток времени.
        Как результат выполнения этой функции,
        вам возвращается таймер, который Вы можете остановить,
        тем самым прервав выполнение этой функции. 

        timer := time.AfterFunc(1 * time.Second, func () { 
            fmt.Println("qq")
        })

        fmt.Scanln()
        timer.Stop()            // прерываем таймер
        fmt.Scanln()







    // CONTEXT. (отмена асинхронных операций, передача контекста)
        Пакет context в Go полезен при взаимодействиях с API и медленными процессами, особенно в production-grade системах,
        которые занимаются веб-запросами. С его помощью можно уведомить горутины о необходимости завершить свою работу (!).
        
        Пакет context в go позволяет вам передавать данные в вашу программу в каком-то «контексте». 
        Контекст так же, как и таймаут, дедлайн или канал, сигнализирует прекращение работы и вызывает return. 

        Пакет Context определяет тип context.Context, который содержит дедлайны, 
        сигналы отмены и другие значения для внешнего запроса через API и между 
        обрабатывающими запрос горутинами.

        Входящие запросы к серверу должны создавать контекст, а исходящие вызовы 
        к серверам должны принимать контекст. Цепочка вызовов функций между ними 
        должна распространять контекст, при необходимости заменяя его производным 
        контекстом, созданным с помощью WithCancel, WithDeadline, WithTimeout или
        WithValue. Когда контекст отменяется, все производные от него контексты 
        также отменяются.

        Функции WithCancel, WithDeadline и WithTimeout принимают родительский Context
        и возвращают производный дочерний Context и CancelFunc. Вызов CancelFunc 
        отменяет дочерний элемент и его дочерние элементы, удаляет ссылку родителя
        на дочерний элемент и останавливает все связанные таймеры, если они были. 
        Все дочерние контексты теперь могут быть уничтожены GC, если они перестали 
        использоваться в каких-либо горутинах и если GC посчитал необходимым 
        произвести такую очистку. Горутины, использующие контексты, должны следовать
        некоторым правилам, чтобы обеспечить согласованность интерфейсов между 
        пакетами и дать возможность использовать инструменты статического анализа 
        для проверки распространения контекста:

        1. Не храните контексты внутри структур. Вместо этого явно передайте контекст
        каждой функции, которая в нем нуждается. Контекст должен быть первым параметром,
        обычно называемым ctx

        func DoSomething(ctx context.Context, arg Arg) error {
            // ... use ctx ...
        }

        2. Не передавайте пустой контекст (nil), даже если это поддерживается функцией.
        Передайте context.TODO, если вы не уверены, какой контекст использовать.

        3. Используйте значения контекста только для данных окружения одного запроса,
        проходящего через горутины и API, а не для передачи дополнительных параметров
        функциям.

        4. Контекст можно отменить только один раз

        Один и тот же контекст может быть передан функциям, работающим в разных горутинах. 
        Контексты безопасны для одновременного использования несколькими горутинами.
        Пример с отменой контекста:

        func httpDo(ctx context.Context, req *http.Request, f func(*http.Response, error) error) error {
            // Run the HTTP request in a goroutine and pass the response to f.
            c := make(chan error, 1)
            req = req.WithContext(ctx)
            go func() { c <- f(http.DefaultClient.Do(req)) }()
            select {
            case <-ctx.Done():
                <-c // Wait for f to return.
                return ctx.Err()
            case err := <-c:
                return err
            }
        }

        Функция httpDo запускает HTTP-запрос и обрабатывает его ответ в новой горутине. 
        Она отменяет запрос, если ctx.Done закрывается до завершения дочерней горутины.


        (!) НО, Безопасен ли запуск этого кода? 
            func doSomething() {
                ctx, cancel := context.WithCancel(ctx)
                defer cancel()

                someArg := "loremipsum"
                go doSomethingElse(ctx, someArg)
            }

            Этот код небезопасен для запуска! Когда мы выполняем doSomething, мы создаем контекст и откладываем его отмену, 
            что означает отмену контекста ctx после того, как doSomething заканчивает выполнение. Мы передаем этот же контекст в 
            doSomethingElse функция, которая может полагаться на предоставленный ей контекст. С doSomethingElse выполняется в 
            другой горутине, вполне вероятно, что контекст будет отменен до окончания doSomethingElse, т.е. если внутри 
                doSomethingElse находится код:
                    select {
                        case <-ctx.Done():          // выполнится почти сразу, поскольку defer cancel() отправит в канал ctx.Done пустую структуру
                            ...
                            return
                        case ...

                    }

                Если это явно не то, что вы хотите, вы всегда должны создавать новый контекст при запуске функции в другой горутине, например:
                func doSomething() {
                    ctx, cancel := context.WithCancel(ctx)
                    defer cancel()

                    someArg := "loremipsum"
                    go doSomethingElse(context.Background(), someArg)
                }



        context.Background() ctx Context
        ctx, cancel := context.Background()
        Эта функция возвращает пустой контекст. Она должна использоваться только 
        на высоком уровне (в main или обработчике запросов высшего уровня). Он 
        может быть использован для получения других контекстов.


        context.TODO() ctx Context
        ctx, cancel := context.TODO()
        Эта функция также создает пустой контекст. И она тоже должна использоваться
        только на высоком уровне или когда вы не уверены, какой контекст использовать,
        или если в функции еще нет получения нужного контекста. Это значит, что вы
        планируете позже добавить контекст в функцию.


        context.WithValue(parent Context, key, val interface{}) Context
        ctx := context.WithValue(context.Background(), key, "test")
        Эта функция принимает контекст и возвращает производный от него контекст,
        в котором значение val связано с key и проходит через всё контекстное дерево.
        То есть, как только вы создадите контекст WithValue, любой производный контекст
        получит это значение. Не рекомендуется передавать критические параметры,
        используя значения контекста, вместо этого функции должны принимать их в 
        сигнатуре явным образом.


        context.WithCancel(parent Context) (ctx Context, cancel CancelFunc)
        ctx, cancel := context.WithDeadline(context.Background(), 
                time.Now().Add(2 * time.Second))
        Эта функция создает новый контекст из переданного ей родительского.
        Родителем может быть контекст background или контекст, переданный в
        качестве аргумента функции. Возвращается производный контекст и функция
        отмены. 
        (!) Вызывать функцию отмены контекста должна только та функция, которая
        его создает. (НИКОГДА не передавайте функцию отмены в другие функции)
        
        
        context.WithDeadline(parent Context, d time.Time) (ctx Context, cancel CancelFunc)
        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))
        Эта функция возвращает производный контекст от своего родителя, который 
        отменяется после дедлайна или вызова функции отмены. Например, вы можете
        создать контекст, который автоматически отменяется в определенное время 
        и передает это дальше в дочерние функции. Когда этот контекст отменяется 
        после дедлайна, все функции, у которых есть этот контекст, по уведомлению 
        должны закончить работу.


        context.WithTimeout(parent Context, timeout time.Duration) (ctx Context, cancel CancelFunc)
        ctx, cancel := context.WithTimeout(context.Background(), 2 * time.Second)
        Эта функция похожа на context.WithDeadline. Разница в том, что в качестве
        входных данных используется длительность времени. Эта функция возвращает
        производный контекст, который отменяется при вызове функции отмены или по
        истечении времени.

        https://habr.com/ru/company/nixys/blog/461723/


        Давайте посмотрим пример.
        Допустим, мы отправляем запросы на несколько разных серверов,
        при этом нам нужен только первый из них, и всех остальных мы не ждём

        
        func worker(ctx context.Context, workerNum int, out chan<- int) {
            // имитация некоторой работы:
            waitTime := time.Duration(rand.Intn(100) + 10) * time.Millisecond
            fmt.Println(workerNum, "sleep", waitTime)

            select {
                // БЕЗОПАСНО ИСПОЛЬЗОВАТЬ между неск. горутинами (ctx.Done)
                // либо завершаем горутину по сигналу от finish()
                case <- ctx.Done():
                return

                // либо по времени
                case <-time.After(waitTime):
                    fmt.Println("worker", workerNum, "done")
                    out <- workerNum
            }
        }
        
        func main() {
            // ВАРИАНТ 1. Завершение горутин по событию
                // ContextBackground — это такой базовый контекст
                ctx, finish := context.WithCancel(context.Background())
                
                result := make(chan int, 1)
                
                for i := 0; i <= 10; i++ {
                    go worker(ctx, i, result)
                }

                // Дожидаемся первого результата
                foundBy := <-result
                fmt.Println("result found by", foundBy)
            
                // вызов метода, полученного при создании ctx.WithCancel
                finish()
            

            // ВАРИАНТ 2. Завершение горутин по таймауту
                workTime := 50 * time.Millisecond

                ctx, finish = context.WithTimeout(context.Background(), workTime)
                result = make(chan int, 1)

                for i := 0; i <= 10; i++ {
                    go worker(ctx, i, result)
                }

                total := 0
                LOOP:
                    for {
                        select {
                            // когда таймер сработал, в канал <-ctx.Done() что-то посылается
                            case <-ctx.Done():
                                break LOOP
                            
                            case foundBy := <-result:
                                total++
                                fmt.Println("result found by", foundBy)
                        }
                    }

                 fmt.Println("total", total)
            time.Sleep(time.Second)
        }




    // АСИНХРОННОЕ ПОЛУЧЕНИЕ ДАННЫХ
        func getComments(){
            // !!! важно использовать буферизированный канал.
            // так как это даёт нам возможность записать хотя бы одно значение
            // в этот канал, не блокируясь. 
            // Если использовать небуферезированный канал, то горутина пытается
            // записать в канал синхронно, то есть ожидая с другой стороны чтение,
            // но оттуда уже никто не читает. И получится утечка горутин и,
            // как следствие, утечка памяти. 
            res := make(chan string, 1)

            go func(out chan<- string) {
                // долгая операция
                out <- "32 комментария"
            } (res)
            return result
        }

        func getPage() {
            // получаем канал
            resultCh := getComments()

            // какая-то длительная операция 
            ...

            result := <-resultCh
            fmt.Println(result)
        }


        (!) Утечка памяти происходит также когда буфер канала переполняется и 
        происходит блокировка на записи второго значения:
        func getComments() chan string {
            result := make(chan string, 1)
            go func(out chan<- string) {
                out <- "загрузка комментариев"
                out <- "32 комментария"
            }(result)
            return result
        }
        
        func getPage() {
            resultCh := getComments()
            // не читаем из полученного канала
            return
        }
    
    // ПУЛ ВОРКЕРОВ (POOL WORKERS)
    Мы можем создать сразу просто несколько горутин,
    которые будут читать из какого-то канала.
    И если нам приходит какая-то задача, мы просто будем писать ее в этот канал.
    А там воркеры уже дальше сами разберутся. 

    
    func startWorker(workerName int, in <-chan string) {
        for input := range in {
            // выполнение работы из пула
            fmt.Printf(workerNum)

            // Готовые к исполнению горутины выполняются в порядке очереди, то есть FIFO
             (First In, First Out). Исполнение горутины прерывается только тогда, когда 
             она уже не может выполняться: то есть из-за системного вызова или
             использования синхронизирующих объектов (операции с каналами, мьютексами и
             т.п.). Не существует никаких квантов времени на работу горутины, после
             выполнения которых она бы заново возвращалась в очередь. Чтобы позволить
             планировщику сделать это, нужно самостоятельно вызвать runtime.Gosched().
             На практике это в первую очередь означает, что иногда стоит использовать
             runtime.Gosched(), чтобы несколько долгоживущих горутин не остановили на 
             существенное время работу всех других. С другой стороны, такие ситуации
             встречаются на практике довольно редко (!)
            runtime.Gosched()
        }
        
        fmt.Printf("Воркер завершил работу!!")
    }

    func main() {
        // пул - как очередь заданий. буферизированный канал. Если небуферизированный - то deadlock
        // т.к. пишем, и в этот же момент никто не читает
        workerInput := make(chan string, 2)

        // создаем горутины
        for i := 0; i < 5; i++ {
            go startWorker(i, workerInput)
        }

        // воркеры сами разберутся - задача идет в канал. 
        // рендомная горутина принимает к работе
        months := []string{"a", "b", "c", "a", "b", "c"}
        for _, mName := range months {
            workerInput <- mName
        }

        // обязательно закрыть канал (пул воркеров) - иначе не дождемся окончания 
        // работы воркеров. Это может привести к дедлоку или утечки памяти
        close(workerInput)
    }


    // sync.Waitgroup - ожидание завршения работы
        каким образом можно дождаться окончания работы нескольких горутин,
        кроме использования каналов, конечно. Ранее использовали Scanln()

        Вызовы Add увеличивает счетчик на переданное число, а вызовы Done 
        уменьшают счетчик на единицу. Wait блокируется пока счетчик не станет 
        равным нулю.

        (!) Что будет, если счетчик отмотать до -1? Произойдет паника!
            Пример:
                wg.Add(3)
                //вызов четырех горутин с defer wg.Done()

            Best practices:
                увеличивать счетчик внутри цикла при создании горутин, т.е. 
                    for i:=0; i<5; i++ {
                        wg.Add(1)
                        go myFunc(wg)             // функция с defer
                    }
                    wg.Wait()

        (!) Кроме того, добавление wg.Wait(1) - запрещено внутри горутины.
        (!) wg - нужно передавать по указателю в горутины, т.к. wg - структура

        Еще пример:
            func startWorker(in int, wg *sync.WaitGroup) {
                // после выполнения задачи уменьшаем счетчик на 1
                defer wg.Done() 

                for j := 0; j < 3; j++ {
                    fmt.Println(in, j)
                    runtime.Gosched()
                }
            }

            func main() {
                // всегда по указателю создаем waitGroup
                wg := &sync.WaitGroup{}

                for i := 0; i < 3; i++ {
                    // добавляем воркер
                    wg.Add(1)
                    // запускам горутину в том же блоке, где и добавляем wg.Add (!) но не в самой горутине,
                    // потому что горутина может еще не запуститься к тому моменту, когда вызовется увеличение счетчика
                    go startWorker(i, wg)
                }

                // ожидаем, пока waiter.Done() не приведет счетчик к нулю
                wg.Wait()
            }


    // RATE-лимиты (ограничение по ресурсам, rate limit)
    Довольно часто бывает так, что нам нужно каким-либо образом затормозить нашу
    программу, например, в зависимости от утилизации процессора,
    либо дисковой подсистемы, нам нужно уменьшить нагрузки на эти части.
    В Go мы можем организовать это, используя буферизированные каналы. 

        >> пул воркеров недостаточно для rate limit. нужно еще подсчитывать количество за единицу времени 
        (например, минуту), и приостанавливать отправку при достижении этого числа - вот это и есть суть 
        задания. Надо сделать общий счетчик rate limit и общую приостановку воркеров при достижении его 
        насыщенности. И суметь их снова запустить как только насыщенность упадет со временем. При этом, 
        когда лимит еще не достигнут, воркеры работают как Вы и написали.
        Здесь нужно будет использовать несколько видов сигнализации и передачи данных между горутинами, 
        входящими в пул. Graceful shutdown тоже надо не забыть.

    В примере ниже могут исполняться только 2 горутины. Горутины в цикле выводят 
    значения от 0 до iterationsNum на экран. 

    При варианте без модификации - 2 горутины занимают квоту и выводят значения 
    в некотором порядке (хаотично). При варианте с модификацией - передаем управление 
    от первых занявших квоту горутин на другие горутины. Итого на выходе имеем 
    "сбалансированное" выполнение работы (все горутины начинают свою задачу, и потом
    заканчивают. Без модификации - по-другому - первые занявшие 2 горутины выполняют свою
    задачу полностью и только потом выполняются остальные горутины по такому же принципу)

    Важно отметить, что с учетом модификации по-прежнему программа не выходи за 
    установленные rate-лимиты (выполнять 2 горутины максимум).

    const (
        iterationsNum = 6
        goroutinesNum = 5
        quotaLimit = 2              (!) ограничиваем ресурсы
    )
    
    
    func startWorker(in int, wg *sync.WaitGroup, quotaCh chan struct{}) {
        // берём свободный слот и блокируемся, до тех пор, пока не появится место
        quotaCh <- struct{}{} 

        // после выполнения задачи уменьшаем счетчик на 1
        defer wg.Done()

        for j := 0; j < iterationsNum; j++ {
            fmt.Printf(in, j)

            /* вариант модификации - можем возвращать квоту обратно на каждой второй итерации
                if j % 2 == 0 {
                    <-quotaCh       // возвращаем слот 
                    quotaCh <- struct{}{}
                }
            */
        }
        
        // возвращаем слот
        <-quotaCh 
    }
        
    func main() {
        wg := &sync.WaitGroup{}
        
        // Канал с квотой — это буферизированный канал,
        // где размер буфера как раз и является нашим лимитом
        // пустая структура не занимает никакого места
        quotaCh := make(chan struct{}, quotaLimit) 
        
        // создаем 5 горутин при квоте в 2
        for i := 0; i < goroutinesNum; i++ {
            wg.Add(1)

            // передаем канал с воркером в горутины
            go startWorker(i, wg, quotaCh)
        }

            time.Sleep(time.Millisecond)
            wg.Wait()
        }


    // СОСТОЯНИЕ ГОНКИ (Data race). Ситуация гонки на примере конкурентной записи в map
        map в Go — это конкурентно небезопасный тип данных,
        то есть обращаясь к нему из разных горутин, которые могут выполняться
        совершенно на разных процессорах, можно как раз словить это состояние гонки. 

    func main() {
        var counters = map[int]int{}
        for i := 0; i < 5; i++ {
            go func(counters map[int]int, th int) {
                for j := 0; j < 5; j++ {
                    // небезопасная запись в MAP
                    counters[th*10+j]++
                }
            }(counters, i)
        }
        fmt.Scanln()
        fmt.Println("counters result", counters)
    }

    // при запуске - fatal error: concurrent map writes
    
    Для того чтобы ловить похожие ошибки,
    в Go есть специальная директива при запуске программы или компиляции race
        go run -race race_1.go

    WARNING: DATA RACE





    // sync.Mutex для синхронизации данных (Мьютекс, Mutex)
        Mutex означает mutual exclusion(взаимное исключение) и является способом
        защиты critical section(критическая секция) вашей программы.

        Критическая секция — это область вашей программы, которая требует 
        эксклюзивного доступа к общему ресурсу. При нахождении в критической 
        секции двух (или более) потоков возникает состояние race(гонки). 
        Так же возможны проблемы взаимной блокировки(deadlock).

        mutex — это такой большой, «жирный» примитив,
        большая, «жирная» конструкция для синхронизации мощных кусков. 

        type counter struct{
            sync.Mutex
            count int
        }
        
        func (c *counter) Increment() {
            c.Lock()
            defer c.Unlock()            
            c.count++
        }
        
        вызываем Unlock в defer. Это очень распространенная идиома при 
        использовании Mutex, чтобы гарантировать, что вызов всегда произойдет,
        даже при панике. Несоблюдение этого требования может привести к deadlock
        вашей программы. Хотя defer и несет небольшие затраты.

        (!) Unlock уже свободного мьютекса приводит к панике!

        Mutex обеспечивает безопасный доступ к общим ресурсам.

        func main() {
            var counters = map[int]int{}
            // использовать по ссылке
            mu := &sync.Mutex{}
            
            for i := 0; i < 5; i++ {
                go func(counters map[int]int, th int, mu *sync.Mutex) {
                    for j := 0; j < 5; j++ {
                        mu.Lock()
                        counters[th*10+j]++
                        mu.Unlock()
                    }
                }(counters, i, mu)
            }
            
            fmt.Scanln()
        *    //mu.Lock()
            fmt.Println("counters result", counters)
        *    //mu.Unlock()
        }

        go run -race main.go:
        ...
        counters result map[0:1 1:1 2:1 3:1 4:1 10:1 11:1 12:1 13:1 14:1 20:1 21:1 22:1 23:1 24:1 30:1 31:1 32:1 33:1 34:1 40:1 41:1 42:1 43:1 44:1]
        Found 2 data race(s)

        Для решения нужно обращение к данным покрыть Lock() на мьютексе (раскоментить *)


    // RWMutex
        RWMutex концептуально то же самое, что и Mutex: он защищает доступ к
        памяти. Тем не менее, RWMutex дает вам немного больше контроля над памятью.
        Вы можете запросить блокировку для чтения, и в этом случае вам будет 
        предоставлен доступ, если блокировка не удерживается для записи.

        Это означает, что произвольное число читателей может удерживать блокировку
        читателя, пока ничто другое не удерживает блокировку писателя.

    // RWMutex - это блокировка взаимного исключения чтения / записи.  Блокировку может удерживать произвольное количество читателей
	// или один писатель.  Нулевое значение для RWMutex - это разблокированный мьютекс.
	// Другими словами, читателям не нужно ждать друг друга.  Им остается только дождаться писателей, удерживающих Lock.
	// Таким образом, sync.RWMutex предпочтительнее для данных, которые в основном читаются

        func (c *counter) CountV1() int {
            c.Lock()
            defer c.Unlock()
            return c.count
        }
        func (c *counter) CountV2() int {
            c.RLock()
            defer c.RUnlock()
            return c.count
        }

        CountV2 (в отличие от CountV1) не блокирует c.count если
        не было блокировок на запись.


    // Cond
        Условная переменная(condition variable) — примитив синхронизации, 
        обеспечивающий блокирование одного или нескольких потоков до момента
        поступления сигнала от другого потока о выполнении некоторого условия 
        или до истечения максимального промежутка времени ожидания.

        Сигнал не несет никакой информации, кроме факта, что произошло какое-то
        событие. Очень часто мы хотим подождать один из этих сигналов, 
        прежде чем продолжить выполнение. Один из наивных подходов состоит 
        в использовании бесконечного цикла:

        for conditionTrue() == false {
            time.Sleep(1 * time.Millisecond)
        }

        Но это довольно неэффективно, и вам нужно выяснить, как долго спать:
        слишком долго, и вы искусственно снижаете производительность; 
        слишком мало, и вы отнимаете слишком много процессорного времени. 
        Было бы лучше, если бы у процесса был какой-то способ эффективно спать,
        пока ему не будет дан сигнал проснуться и проверить его состояние.

        Такие задачи могут решать каналы или вариации 
        паттерна PubSub(Publisher-Subscriber).

        Но если у вас низкоуровневая библиотека, где необходим более 
        производительный код, тогда можно использовать тип sync.Cond.

        Предположим у нас есть некоторый общий ресурс в системе. 
        Одна группа процессов может изменять его состояния, а другая группа
        должна реагировать на эти изменения.

        type message struct {
            cond *sync.Cond
            msg  string
        }

        func main() {
            msg := message{
                cond: sync.NewCond(&sync.Mutex{}),
            }

            // запуск 3 goroutine, которые ждут сигнала
            for i := 1; i <= 3; i++ {
                go func(num int) {
                    for {
                        // При входе в Wait вызывается Unlock в Locker переменной Cond
                        msg.cond.L.Lock()
                        
                        // вызов Wait не просто блокирует, он приостанавливает текущую процедуру,
                        // позволяя другим процедурам запускаться.
                        msg.cond.Wait()

                        fmt.Printf("hello, i am worker%d. text:%s\n", num, msg.msg)
                        
                        // а при выходе из Wait вызывается Lock в Locker переменной Cond.
                        msg.cond.L.Unlock()
                    }
                }(i)
            }

            // читаем ввод из консоли и отправляем сигнал об изменении состояния.
            scanner := bufio.NewScanner(os.Stdin)
            fmt.Print("Enter text: ")
            
            for scanner.Scan() {

                msg.cond.L.Lock()
                msg.msg = scanner.Text()
                msg.cond.L.Unlock()

                // отправляет сигнал всем ожидающим goroutine
                msg.cond.Broadcast()
            }
        }
        

    // sync.Atomic
        Atomic - потокобезопасен
        Atomic быстрее мьютекса: внутри мьютекса встроен atomic как более низкоуровневый примитив.
        В пакете atomic довольно много разных функций  для атомарных операций со счетчиками либо для сравнения и замены. 

        (!) atomic.AddInt32(&var, 1) быстрее, чем var++, поскольку работает напрямую с памятью (1 такт процессора против нескольких)
        
        // Пример программы со счетчиком, инкрементирующимся из 1000 горутин (состояние гонки).
        var totalOperations int32 = 0
        func inc() {
            totalOperations++
        }
        
        func main() {
            for i := 0; i < 1000; i++ {
                go inc()
            }
            
            time.Sleep(2 * time.Millisecond)
            
            // ождается 1000, но по факту будет меньше
            fmt.Println("total operation = ", totalOperations)
        }

        Изменим функцию inc(): 
            мы уже не инкрементируем счетчик напрямую,
            а используем функцию из пакета atomic
            Мы вызываем функцию AddInt32, куда передаем адрес нашей
            переменной и то значение, на которое мы хотим увеличить. 
        func inc() {
            atomic.AddInt32(&totalOperations, 1)    // автомарно
        }


    // atomic.Value
        var := atomic.Value{}
        var.Store(100)          // Store(x interface{})
        var.Load()

        fmt.Println(var)







    // STRING TO SLICE OF BYTE
    Иногда нам понадобится работать с бинарными данными. Чтобы преобразовать строку в набор байт (и наоборот), выполните следующие действия:
    arr := []byte("test")
    str := string([]byte{'t','e','s','t'})





// ФАЙЛЫ. Чтение из файла:
package main

import (
    "fmt"
    "io/ioutil"
)

func main() {
    bs, err := ioutil.ReadFile("test.txt")
    if err != nil {
        return
    }
    str := string(bs)
    fmt.Println(str)
}

// ФАЙЛЫ. Запись в файл
package main

import (
    "os"
)

func main() {
    file, err := os.Create("test.txt")
    if err != nil {
        // здесь перехватывается ошибка
        return
    }
    defer file.Close()

    file.WriteString("test")
}


// МЬЮТЕКСЫ
Когда мьютекс (m) заблокирован из одного процесса, любые попытки повторно блокировать его из других процессов
приведут к блокировке самих процессов до тех пор, пока мьютекс не будет разблокирован.
func main() {
    m := new(sync.Mutex)

    for i := 0; i < 10; i++ {
        go func(i int) {
            m.Lock()                    // Заблокировали в первом вызове горутины и моментально создали еще 9 горутин, которые при попытке
            // снова заблокировать мьютекс приведет к блокировке этих горутин до разблокировки мьютекса в первой запущенной горутине
            fmt.Println(i, "start")
            time.Sleep(time.Second)
            fmt.Println(i, "end")
            m.Unlock()
        }(i)
    }

    var input string
    fmt.Scanln(&input)
}




Например, можно перенаправить потоки из stdout и stderr в файлы на диске при запуске приложения
 из терминала следующим образом
go run ./cmd/web >>/tmp/info.log 2>>/tmp/error.log
 лучше записывать вывод в стандартные потоки и перенаправлять вывод в файл при запуске приложения из командной строки.
  Но, если вы не хотите этого делать, всегда можно открыть файл в Go и использовать его в качестве места назначения лога. Например:

f, err := os.OpenFile("info.log", os.O_RDWR|os.O_CREATE, 0666)
if err != nil {
    log.Fatal(err)
}
defer f.Close()

infoLog := log.New(f, "INFO\t", log.Ldate|log.Ltime)



Пакеты в Go:

    // go get
        - эта команда позволяет устанавливать сторонние пакеты в локальную среду разработки и использовать их в вашей программе.
        При использовании go get для установки сторонних пакетов часто используется канонический путь пакета. 
        Это может быть путь к публичному проекту, размещенному в таком хранилище кода, как GitHub. 
        Если вы захотите импортировать пакет flect, вы используете полный канонический путь:
            go get github.com/gobuffalo/flect
        
        Инструмент go get найдет пакет на GitHub и установит его в каталог $GOPATH.

    // fmt
        Основными задачами fmt являются:
            Формирование строкового представления и, возможно, вывод в исходящий поток данных
            Сканирование значений из входящего потока данных
            Форматирование сообщений об ошибках (fmt.Errorf)

        В функциях этого пакета используются спецификаторы преобразования:  %v, %t, %b и т.д.

            Старайтесь не использовать fmt.Print, Printf, Println для отладки приложений.


    // encoding
        Пакет encoding определяет интерфейсы, общие для других пакетов, которые 
        преобразуют данные в байтовые или текстовые представления и обратно. 
        Пакеты, которые проверяют эти интерфейсы, включают например encoding/json
        и encoding/xml. В результате однократная реализация интерфейса может 
        сделать тип полезным в нескольких форматах. Стандартные типы, реализующие 
        эти интерфейсы, включают time.Time и net.IP.

        // encoding/json (Подробнее: https://go.dev/blog/json)
            Пакет encoding/json реализует кодирование и декодирование для формата 
            JSON, описанного в RFC7159.
            

            (!) Важно, чтобы поля у структуры были экспортируемыми. Иначе в это поле не запишем 
            значение из строки JSON и не прочитаем в строку JSON
            type User struct {
                ID int          // при маршализации получим только ID в JSON `{"id":32}`
                phone string    // а phone - не отобразится в JSON
            }

            MARSHAL (сериализация): - преобразование объекта к строке JSON
                func Marshal(v interface{}) ([]byte, error)
                Функция Marshal возвращает
                    -слайс байт, содержащий текстовое представление в формате JSON
                    объекта, переданного в функцию
                    -ошибку, если она встретилась в процессе преобразования

                Вот таблица соответствия между типами данных Golang и JSON`
                    Golang 	  |  JSON
                    __________|__________
                    Boolean 	Boolean
                    
                    Floating 
                    point,      Numbers
                    integer, 
                    и Number 	

                    String      JSON strings в формате UTF-8
                                с заменой некорректных байт 
                                на Unicode runes
                    Array 
                    и slice 	JSON arrays, за исключением []byte,
                                который кодируется как строка в base64
                    
                    Struct 	    JSON object

                    *Объекты JSON поддерживают только строки в качестве ключей; чтобы кодировать Go тип map он должен иметь вид map[string]T 
                    (где T - любой тип Go, поддерживаемый пакетом json).

                    *Channel, complex и func типы не могут быть закодированы.

                    *Циклические структуры данных не поддерживаются; они приведут к попаданию Marshal в бесконечный цикл.

                    *Указатели будут закодированы как значения, на которые они указывают (или 'null', если указатель равен nil).`


                Для того, чтобы представить структуру как JSON, нужно использовать специальные
                // теги структур:
                    // Маршаллинг будет использовать название и тип поля
                    Field int

                    // Это поле структуры будет представлено в JSON объекте как "myName"
                    Field int `json:"myName"`

                    // То же самое, что и в предыдущем примере, только если поле
                    // пустое (zero-value), то его не будет в JSON объекте (не нужно маршалить).
                    Field int `json:"myName,omitempty"`

                    // Если не указать название поля, то будет использовано имя по умолчанию - "Field"
                    // в данном случае еще не сериализуем это поле, если оно пустое (zero-value)
                    Field int `json:",omitempty"`

                    // Поле будет проигнорировано при сериализации этой структуры.
                    Field int `json:"-"`

                    // Поле будет представлено с названием "-"
                    Field int `json:"-,"`

                    // Если указать опцию string, то поле будет представлено как UTF-8 строка JSON.
                    Int64String int64 `json:",string"


            Обратите внимание, что поля должны быть публичными, то есть иметь имя
            начинающееся с буквы верхнего регистра! В противном случае они будут
            проигнорированы в процессе сериализации.

        UNMARSHAL (десериализация): - преобразование строки JSON к объекту
            func Unmarshal(data []byte, v interface{}) error

            Функция Unmarshal разбирает предоставленный слайс байт data в объект, 
            переданный вторым аргументом. Возвращает ошибку, если она произошла 
            в процессе разбора данных. Обычно вторым объектом передается указатель
            на тот или иной объект.

            Если попытаться разобрать объект в интерфейс, то пакет будет
            использовать следующее соответствие типов JSON типам Golang:

                JSON 	    |    Golang
                ____________|_______________
                booleans 	        bool
                numbers 	        float64
                strings 	        string
                JSON arrays 	    []interface{}
                JSON objects 	    map[string]interface{}
                null 	            nil
        

        Как десериализовать (распаковать) строки JSON с различной структурой в структуру Go?
        data := []byte(jsonStr)
        var user1 interface{}
        json.Unmarshal(data, &user1)
        fmt.Printf("unpacked in empty interface: \n%#v\n\n", user1)     // распакует в слайс интерфейсов

        Точно так же вы можете запаковать (сериализовать) любое значение через пустой интерфейс
        user2 := map[string]interface{}{
            "id":42,
            "username":"rvasily"
        }
        result, _ := json.Marshal(user2)
        fmt.Printf("json string from map: \n%s\n", string(result))     // получим валидный JSON
    
        encoding/xml

            Пакет encoding/xml содержит средства, позволяющие разбирать данные 
            в формате XML 1.0, а также сериализовать данные в этот формат.
        
        MARSHAL:
            func Marshal(v interface{}) ([]byte, error)
            Функция Marshal возвращает
                -слайс байт, содержащий текстовое представление объекта v в 
                формате XML
                -ошибку, если она встретилась в процессе сериализации.


            Имя XML элемента будет выбрано из следующего списка в порядке важности:
                Тег поля XMLName, если данные это структура
                Значение поля XMLName типа xml.Name
                Значение тега поля
                Название поля структуры
                Название типа, который сериализуется

            Элемент XML для структуры содержит упорядоченные элементы для каждого
            из экспортируемых полей структуры, за исключением следующих:
                Поле с тегом "-" будет пропущено.
                Поле с тегом "name,attr" станет атрибутом с заданным именем 
                    в элементе XML
                Поле с тегом ",chardata" будет записано как символьные данные, 
                    а не XML элемент.
                Поле с тегом ",cdata" будет записано как символьные данные,
                    обернутые в один или несколько тегов , не как XML-элемент.
                Поле с тегом ",innerxml" будет записано дословно, без каких либо
                    преобразований.
                Поле с тегом ",comment" будет записано как XML комментарий, без
                    каких либо преобразований. Это поле не должно содержать
                    строку, содержащую "--" внутри себя.
                Поле с тегом, содержащим опцию "omitempty" будет пропущено, 
                    если оно содержит пустое значение. Пустые значения это false,
                    0, любой nil указатель или интерфейс, а также любые массивы, 
                    слайсы, отображения или строки нулевой длины.
                Анонимное поле структуры обрабатывается так, как если бы поля 
                    его значения были частью внешней структуры.
                Поле, содержащее структуру, которая имплементирует интерфейс
                    Marshaler, будет записано путем вызова его метода MarshalXML.
                Поле, содержащее структуру которая, имплементирует интерфейс 
                    encoding.TextMarshaler, будет записано путем вызова его 
                    MarshalText в виде текста.

            Если в поле используется тег a>b>c, то элемент c будет вложен 
            в родительские элементы a и b. Поля, которые отображаются рядом
            друг с другом и которые называют одного и того же родителя, будут
            заключены в один XML-элемент.

        UNMARSHAL:

        func Unmarshal(data []byte, v interface{}) error
        По аналогии с рассмотренным ранее пакетом json, функция xml.Unmarshal 
        разбирает предоставленный слайс байт data в объект, переданный вторым 
        аргументом.


    // io
    Пакет io предоставляет базовые интерфейсы для примитивов ввода-вывода.
    Обратите внимание, что поскольку эти интерфейсы и примитивы используют
    низкоуровневые операции с различными реализациями, не стоит предполагать, 
    что они безопасны для параллельного выполнения, конечно, если об ином явно 
    не сказано в документации.

    Интерфейсы:
        -Reader
            Сигнатура интерфейса Reader выглядит вот так:

            type Reader interface {
                Read(p []byte) (n int, err error)
            }

            Read считывает до len(p) байтов в слайс байт p. 
            Он возвращает количество прочитанных байтов и ошибку, 
            если она произошла в процессе чтения. Даже если Read 
            возвращает n < len(p) байт, он может использовать 
            все p байт в качестве пустого места во время вызова.
        
        -Writer
            Сигнатура интерфейса Writer выглядит вот так:

            type Writer interface {
                Write(p []byte) (n int, err error)
            }

            Write записывает len(p) байт из слайса байт p в базовый
            поток данных. Он возвращает количество байт, записанных
            из p и любую обнаруженную ошибку, которая привела 
            к преждевременной остановке записи. Write должна возвращать
            ненулевую ошибку, если она возвращает n < len(p) байт. 
            Write не должна изменять данные среза, даже временно.

        -Closer
            Интерфейс Closer закрывает поток данных, для которого определен.
            Он имеет следующую сигнатуру:

            type Closer interface {
                Close() error
            }

        -ReadWriteCloser
            Объединением троих выше рассмотренных интерфейсов 
            является ReadWriteCloser.

            type ReadWriteCloser interface {
                Reader
                Writer
                Closer
            }

        Функции
            В пакете содержится ряд полезных функция для работы с интерфейсами,
            описанными выше.
            
            -Copy
                func Copy(dst Writer, src Reader) (written int64, err error)

                Функция Copy копирует данные из объекта src в объект dst,
                используя для этого определенные в этих объектах 
                функции Read и Write соответственно; 
                Возвращает количество записанных байт и ошибку, 
                если она встретилась в процессе записи.
            
            -ReadAll
                func ReadAll(r Reader) ([]byte, error)

                Функция ReadAll читает все доступные данные из объекта r,
                который должен реализовать интерфейс Reader. Возвращает слайс 
                байт, содержащий данные и ошибку, если она встретилась в 
                процессе чтения.

                Пример того, как io.Writer используется при записи данных 
                в файл в Go:

                func main() {
                    f, err := os.OpenFile("/tmp/123.txt", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0600)
                    if err != nil {
                        panic(err)
                    }
                    defer f.Close()

                    n, err := f.Write([]byte("writing some data into a file"))
                    if err != nil {
                        panic(err)
                    }
                    fmt.Printf("wrote %d bytes", n)
                }

            os.File является реализацией интерфейса io.Writer, который используется
            для записи байтового среза в поток данных файла. Вот так определен 
            тип os.File.Write:

                func (f *File) Write(b []byte) (n int, err error)


    // time 
        Пакет time предоставляет возможности для измерения и отображения времени.
        Все расчёты, связанные с календарём, всегда предполагают 
        григорианский календарь без високосных секунд.
        
        Объект Time
            Объект Time является отображением момента времени с точностью 
            до наносекунды.
            Обычно объект Time передается как значение, а не как указатель. 
            Иными словами, если ваша функция принимает этот объект как один из своих 
            аргументов, то это должен быть time.Time, а не *time.Time.

            Можно сравнить экземпляры объекта, используя методы Before, After и Equal.
            Метод Sub вычитывает свой аргумент из исходного объекта и создает объект
            Duration (продолжительность). Метод Add прибавляет к объекту продолжительность
            и делает новый объект Time.
            Значением по умолчанию для объекта Time является January 1, year 1, 
            00:00:00.000000000 UTC. Вряд ли в реальном коде когда-либо встретится эта
            дата, тем не менее существует метод IsZero, который позволит определить 
            это точно.
        
        Layout
            В пакете time важной является константа Layout:
            01/02 03:04:05PM '06 -0700
            Дело в том, что она используется как для форматирования вывода объекта Time,
            так и для, например, разбора строки, содержащей преобразование даты в 
            объект Time. В более привычном для нас виде её можно представить вот так:
                
                Mon Jan 2 15:04:05 MST 2006

            На самом деле запомнить её достаточно просто. Если вы посмотрите на
            классическое представление, то увидите, что логика этой даты - это
            прибавлять +1 к предыдущему значению. Первый месяц, второе число, 
            три часа, четыре минуты и так далее. Сложность лишь в перепутанных на американский манер, с нашей точки зрения, месяце и дне.

            Вот примеры преобразования строки к объекту time.Time и наоборот:

            const longForm = "Jan 2, 2006 at 3:04pm (MST)"
            t, _ := time.Parse(longForm, "Feb 3, 2013 at 7:54pm (PST)")

            const shortForm = "2006-Jan-02"
            t, _ = time.Parse(shortForm, "2013-Feb-03")

            Здесь константы содержат шаблон, взятый из константы Layout, а вторым
            аргументом передаётся строка, которую требуется преобразовать в объект Time.

            Метод Format принимает шаблон и возвращает строку:
            fmt.Println("Unix format:", t.Format(time.UnixDate))
            fmt.Println("Custom format", t.Format("Jan 2, 2006 at 3:04pm (MST)"))

        Объект Duration
            Объект Duration представляет из себя разницу между двумя объектами Time
            с точностью до наносекунд в виде числа (int64).

            t0 := time.Now()
            // Прошло сколько-то времени
            t1 := time.Now()
            fmt.Print("Сколько времени прошло между t1 и t0", t1.Sub(t0))

            Duration можно получить путём разбора строки, содержащей его текстовое
            представление. Это достигается с помощью функции time.ParseDuration 
            К сожалению, здесь нет шаблонов, и можно использовать лишь следующие 
            заранее определенные значения: "ns", "us" или "µs", "ms", "s", "m", "h".

            Например:
            hours, _ := time.ParseDuration("10h")
            complex, _ := time.ParseDuration("1h10m10s")

            fmt.Println(hours) //10h0m0s
            fmt.Println(complex) //1h10m10s
            fmt.Printf("There are %.0f seconds in %v.\n", complex.Seconds(), 
                complex) //There are 4210 seconds in 1h10m10s.

        Конкурентность
            Пакет time также содержит ряд объектов и методов, которые применяются 
            при конкурентном программировании в Golang.

            Например,
                time.After
                time.Tick
                Тип Ticker
                Тип Timer

    
    net/http
        В любом даже маленьком проекте, использующем протокол HTTP для передачи данных,
        понадобится пакет net/http. В нем содержатся все самые необходимые реализации
        интерфейсов для работы с протоколами HTTP, HTTPS, создания запросов и обработки
        ответов, настройки клиентов и серверов. Знание абстракций этого пакета существенно
        упрощает разработку сетевых взаимодействий приложений.

        Оригинальная документация пакета достаточно обширна, поэтому для начала
        предлагаем ознакомиться только с некоторыми типами, которые используются 
        чаще всего:

            Transport   https://pkg.go.dev/net/http#Transport
            Server      https://pkg.go.dev/net/http#Server
            ServeMux    ...
            Handler
            Client
            Request
            Response

    
    
    errors
        Этот пакет реализует функции для управления ошибками.
        Функция New создает ошибки, единственным содержанием которых является
        текстовое сообщение.
        Функции Unwrap, Is и As работают с ошибками, которые могут оборачивать другие
        ошибки. Ошибка завершает другую ошибку, если ее тип имеет метод:

            Unwrap() error

        Простой способ создать обернутые ошибки - вызвать fmt.Errorf и применить 
        спецификатор преобразования %w к аргументу ошибки:

            errors.Unwrap(fmt.Errorf("... %w ...", ..., err, ...))

        Is последовательно разворачивает свой первый аргумент в поисках ошибки, 
        соответствующей второму и сообщает о том, нашла ли она совпадение. 
        Её следует использовать вместо простых проверок равенства. 
        
        Вместо

            if err == fs.ErrExist

        лучше сделать так:

            if errors.Is(err, fs.ErrExist)

        Потому что второе будет успешным, если err оборачивает fs.ErrExist.

        As разворачивает свой первый аргумент, последовательно ища ошибку, 
        которую можно присвоить второму аргументу-указателю. В случае успеха она 
        выполняет присвоение и возвращает значение true. В противном случае 
        возвращается false. Предпочтительнее вызвать As:

        var perr *fs.PathError
        if errors.As(err, &perr) {
            fmt.Println(perr.Path)
        }

        вместо

        if perr, ok := err.(*fs.PathError); ok {
            fmt.Println(perr.Path)
        }

        потому что второе будет успешным, если err оборачивает *fs.PathError.

        Пример:

        // MyError is an error implementation that includes a time and message.
        type MyError struct {
            When time.Time
            What string
        }

        func (e MyError) Error() string {
            return fmt.Sprintf("%v: %v", e.When, e.What)
        }

        func oops() error {
            return MyError{
                time.Date(1989, 3, 15, 22, 30, 0, 0, time.UTC),
                "the file system has gone away",
            }
        }

        func main() {
            if err := oops(); err != nil {
                fmt.Println(err)
            }
        }








        


Подробнее о JWT
    JSON Web Tokens — это открытый стандарт RFC 7519 для создания токенов доступа.
    JWT используется в передаче данных для аутентификации в клиент-серверных приложениях.
    В обычных небольших веб-приложениях легко идентифицировать пользователей с помощью 
    сессий, но в микросервисной архитектуре и при высокой нагрузке сессии становятся
    малопригодными для использования. С помощью JWT мы можем создать уникальный токен 
    для каждого аутентифицированного пользователя. Этот токен будет содержать необходимую
    информацию о пользователе и будет включён в заголовок последующего запроса к API. 
    Этот метод позволяет идентифицировать всех пользователей, которые выполняют 
    вызовы API.

    Давайте начнем с разбора самого JWT токена. Его содержимое представляет из себя 
    ascii-строку, благодаря чему, может быть использован в качестве значения куки. 
    По спецификации он содержит 3 блока: заголовки, набор кастомных полей (claims) 
    и подпись, которые разделены через точку. Набор полей (claims) содержит произвольные
    пары имя/значения, однако стоит учитывать, что стандарт JWT имеет несколько 
    зарезервированных имен. Первые два блока представлены в JSON-формате и 
    дополнительно закодированы в формат base64. Подпись же вычисляется на основе 
    первых двух блоков с помощью их хеширования по заданному в заголовке алгоритму, 
    используя секретный ключ. Этим ключом также должен обладать и сервер, который 
    впоследствии будет валидировать токен. Для валидации сервер выполняет тот же 
    алгоритм калькуляции хеша подписи, и если они совпадают, считает токен валидным






Пакет reflect - работаем с динамикой в рантайме
    Отражение(reflection) в вычислениях - это способность программы исследовать свою собственную структуру,
    особенно с помощью типов; это форма метапрограммирования. Это также отличный источник путаницы.
    Отражение - это способность программы проверять свои переменные и значения во время выполнения и находить их тип.
    В целом она нужна для оперирования свойствами объектов неизвестных в момент компиляции.
    По сути это механизм, позволяющий обойти строгую типизацию. Задача, которую решает рефлексия в данном случае это 
    получение дополнительной информации о типе объекта в момент исполнения.

    Для начала разберёмся что доступно в языке Go. К рефлексии, то есть способности кода получать какие-то данные 
    о программе в момент исполнения в Go отвечают два пакета: runtime и непосредственно reflect. С помощью первого 
    можно получать такие данные как стек вызовов или размер занимаемой памяти. Нас интересует пакет reflect, который 
    предоставляет методы для извлечения информации о типах.

    Пакет поможет определять тип переменной во время выполнения. Например,
    когда передаем в качестве параметра функции структуры разных типов в функцию вида:
    func myFunc(a interface{}) {...}
    Пакет reflect помогает идентифицировать лежащий в основе конкретный тип и значение интерфейса {} переменной

        type order struct {  
            ordId      int `json:"foo"`     // структурные тэги для внедрения различных аспектов в описании классов
            customerId int `json:"bar"`
        }

        func createQuery(q interface{}) {  
            t := reflect.TypeOf(q)          
            v := reflect.ValueOf(q)
            k := t.Kind()

            fmt.Println("Number of fields", v.NumField())   // Number of fields 2
            fmt.Println("Type ", t)                         // Type  main.order - фактический тип интерфейса
            fmt.Println("Value ", v)                        // Value  {456 56} 
            fmt.Println("Kind ", k)                         // Kind  struct     - представляет конкретный вид типа
            fmt.Println(t.Field(0).Tag.Get("json"))         // foo.

            for i := 0; i < v.NumField(); i++ {
                fmt.Printf("Field:%d type:%T value:%v\n", i, v.Field(i), v.Field(i))
            }

            // Field:0 type:reflect.Value value:456  
            // Field:1 type:reflect.Value value:56  
        }

        func main() {  
            o := order{
                ordId:      456,
                customerId: 56,
            }
            createQuery(o)

            a := 56
            x := reflect.ValueOf(a).Int()
            fmt.Printf("type:%T value:%v\n", x, x)          // type:int64 value:56  
            b := "Naveen"
            y := reflect.ValueOf(b).String()
            fmt.Printf("type:%T value:%v\n", y, y)          // type:string value:Naveen 
        }

        Стоит ли использовать отражение? Роб Пайк ответил: "Отражение никогда не бывает ясным"
        Clear is better than clever. Reflection is never clear.
        Отражение - очень мощная и продвинутая концепция в Go, и ее следует использовать с осторожностью.
        С помощью отражения очень сложно написать понятный и удобный в сопровождении код. По возможности его
        следует избегать и использовать только в случае крайней необходимости. 

        Плюсы рефлексии:
        + можно отделить определённую логику в отдельные аспекты, не дублируя и не усложняя код.
        
        Минусы рефлексии:
        - оперирование нетипизированными объектами в момент исполнения
        - падение скорости работы

        Примеры использования рефлексии:
        Рефлексия широко применяется в стандартной библиотеке для сериализации и десериализации, 
        а также форматирования (json, xml, fmt). При этом надо упомянуть, что рефлексия всегда 
        используется как последнее средство. Сначала производятся попытки привести пустой интерфейс 
        к стандартным типам, затем к объявленным внутренним интерфейсам, и только потом формируются 
        объекты рефлексии. Конечно, это делается потому, что стандартная библиотека должна быть настолько 
        быстрой, насколько это возможно, не усложняя интерфейсы. В сторонних библиотеках рефлексия 
        применяется более аггрессивно: ORM, валидация, (де)сериализация и многие другие области. 
        Часто рефлексия применяется для имитации отсутствующих в языке дженериков (например, 
        стандартный пакет sort).

        Reflection API (пакет reflection) используется на этапе выполнения программы, кодогенерация — перед
        этапом компиляции. Reflection API увеличивает время работы программы. Пример: инструмент для кодирования 
        и декодирования JSON из стандартной библиотеки Go использует Reflection API. Взамен ему сообществом были
        рождены такие альтернативы, как easyjson, который с помощью кодогенерации кодирует и декодирует JSON
        в 5 раз быстрее.

    // Кодогенерация 
        Так как кодогенерация — неявное программирование, она недооценивается сообществом Go, хотя и является 
        официальным инструментом от создателей этого языка программирования. 

        Кодогенерация применяется:
        - компилятором, например, при работе с тестами
        - синтаксическими анализаторами

        Конкретный пример:
        При разработке микросервисов есть много похожего шаблонного кода, который нужно писать в каждом микросервисе. 
        Например, код репозитория по работе с базой данных.
        Тот же protobuf, swagger - выполняет кодогенерацию.
        В целом задача сводится к тому, чтобы разработчик микросервиса мог описать свои данные обычным образом 
        в стандартном синтаксисе Go

        Плюсы кодогенерации:
        + в отличие от рефлексии, кодогенерация не выполняется в рантайме

        Минусы кодогенерации:
        - приходится отдельно писать программу "для написания другой программы" и отдельно отлаживать ее


    // Benchmark (бенчмарк)
        Запуск бенчмарка:
        go test -bench . -benchmem main.go

        Результат:
        BenchmarkName-1 <Iterations_count> <Nanoseconds_for_1_operation> <bytes_for_1_operation> <memory_allocations_count> 

    // sync.pool - пул горутино-безопасен
        иногда хочется не выделять новую память каждый раз, а переиспользовать какой-то пул памяти, чтобы там уже 
        были преаллоцированные объекты. Это будет быстрее. В go есть инструмент для этого, называется он sync.Pool. 
        
        Пакет sync предоставляет мощный пул экземпляров, которые могут быть повторно использованы для того, чтобы 
        уменьшить давление на сборщик мусора. Перед использованием пакета очень важно провести тестирование приложения
        до и после использования пула, поскольку это может снизить производительность, если вы плохо понимаете, как оно 
        работает внутри.



// Garbage collector (GC, сборщик мусора)
    Сборщик мусора (далее GC) не постоянно собирает мусор, а через определённые промежутки времени. 
    В случае если ваш код выделяет память под некоторые структуры данных, а потом освобождает их — и так по кругу — 
    это вызывает определённое давление на GC, в том числе заставляет runtime обратиться к ОС для выделения новой памяти.
    Представьте: выделяем слайс (например []byte), работаем с ним, освобождаем. Пройдёт определённое время, прежде GC 
    "очнётся ото сна" и соберёт этот слайс. Если в это время мы выделим ещё один такой же кусок и уже выделенной у ОС
    памяти на это не хватит, то приложение будет вынуждено запросить у ОС ещё памяти. По времени приложения запрос 
    памяти у ОС длится вечность. А в это самое время где-то пылится, ждёт своего часа тот прежний "отработанный" слайс.

    Для этого можно:    
        -создать пул (sync.pool)
        -сбрасывать состояние слайса
        -складывать в пул отработанные слайсы
        -брать новые слайсы из пула

    В современных приложениях обычно существует два способа выделения памяти: stack и heap.
    Куча, с другой стороны, представляет собой пул памяти, который может использоваться для динамического выделения.
    Распределение стэка отлично в том, что он живет только в течение срока службы функции, частью которой он являются. 
    Однако выделение кучи не будет автоматически освобождено, когда он выйдет за пределы области. Чтобы предотвратить 
    рост кучи без привязки, мы должны либо явно освободить место, либо в случае языков программирования с управлением 
    памятью (например, Go) полагаться на сборщик мусора(GC) для поиска и удаления объектов, на которые больше не ссылаются.

    Вообще говоря, на языках с GC, чем больше вы можете хранить в стеке, тем лучше, так как эти выделения никогда даже не 
    замечаются GC. Компиляторы используют метод escape analysis, чтобы определить, может ли что-то быть выделено в стеке 
    или должно быть помещено в кучу.

    На практике написание программ, которые заставляют компилятор выделять только в стеке, может быть очень ограничивающим, 
    и поэтому в Go мы используем его замечательный GC, чтобы сделать работу по поддержанию нашей heap чистой.

    (!) GC работает конкурентно с основной программой (мутатором). Мутатор может изменять состояние кучи в процессе выполнения.
     Чтобы GC смог находить (раскрашивать) неиспользуемые объекты, и чтобы этого не случалось, используется write barrier, 
     который поддерживает консистенстность данных в куче.
     Write barrier включается, когда программа полностью остановлена (Stop The World - полная остановка программы).
     Одна из основных задач 

    Pacer - следит за тем, когда нужно запускать GC (следит за выделением памяти).
    (!) Запуск GC вручную - runtime.GC(). Однако в этом случае этот запуск может заблокировать фызывающую функцию или Даже
    всю программу целиком.

    (!) По умолчанию GC запускается, когда размер кучи становится в 2 раза больше. Данный коэффициент можно регулировать,
    изменяя значение переменной среды GOGC.

    (!) Сборка мусора 
        1 фаза Sweep Termination:
            - Stop The World
            - Ожидаем пока все горутины достигнут safe-point
            - Завершаем очистку ресурсов
        2 фаза разметки Mark phase (выделяется примерно 25% CPU)
            - включается Write Barrier
            - Start The World
            - Запускаем сканирование глобальных переменных и стеков
            - При сканировании стека работа горутины приостанавливается
            - Выполняется трехцветный алгоритм для поиска мусора
        3 фаза Mark Termination
            - Stop The World
            - Дожидаемся завершения обработки последних задач из очереди
            - Очистка кешей
            - STW не обязательный
            - Завершаем разметку
        4 фаза очистки Sweep phase
            - Отключаем write barrier
            - Start The World
            - Очистка ресурсов происходит в фоне

    В трехцветном сборщике мусора, каждый объект может быть помечен, как белый, серый или чёрный, и мы рассматриваем кучу 
    (heap) как граф связанных объектов. В начале каждого цикла GC все объекты белые. GC проходит всё корневые узлы (roots) 
    графа, которые являются объектами, напрямую доступными программе — это глобальные переменные и переменные в стеке — и 
    помечает их серыми. Затем GC выбирает серый объект, делает его чёрным, а затем сканирует его на наличие указателей и 
    других объектов. Если скан обнаруживает указатель на белый объект, он делает его серым. Этот процесс повторяется, пока 
    не останется серых объектов. В этот момент все белые объекты будут считаться недостижимыми и могут быть переиспользованы.

    Это всё происходит параллельно с работой программы, также называемой мутатором (mutator), изменяющей указатели по мере 
    того, как работает сборщик. Из этого следует, что мутатор должен поддерживать инвариант того, что ни один черный объект 
    не указывает на белый, чтобы сборщик мусора не потерял след объекта в той части кучи, которую он уже обошел. Поддержка 
    такого инварианта это задача для «барьеров записи» (write barrier), которая по сути является маленькой функцией, 
    запускающейся каждый раз, когда мутатор меняет указатель в куче. Барьер записи в Go помечает серым объекты, которые были 
    белыми, гарантируя, что сборщик мусора рано или поздно просканирует его.

    Определение момента, когда все объекты просканированы — тонкая задача и может быть очень дорогостоящей и сложной, если 
    мы хотим избежать блокировок мутатора.

    Недостатки GC:
        - Не реализован алгоритм поколений
        - Не реализовано уплотнение (GC подвержен фрагментации в памяти)
        - Stop the world
        - Нет тонкой настройки GC (кроме GOGC)

    GC может стать узким местом вашей программы, когда речь идет о производительности. Примерно 25% CPU занимает алгоритм 
    разметки и во время одного цикла работы дважды происходит Stop The World
    (!) Оптимизации:
        - Уменьшить кол-во вызовов GC с помощью изменения переменной GOGC
        - Используйте балласт - большое выделение памяти, которое уменьшает количество циклов GC на определенном промежутке
        времени:
            *увеличивает базовый размер кучи
            *не будет удален как мусор
            *помечается за O(1)
            *выделяется в виртуальном адресном пространстве и не использует физическую память
        - Используйте sync.Pool 




    // GOGC
        Его значение контролирует общий размер кучи относительно размера достижимых объектов. Дефолтное значение «100» 
        означает, что общий размер кучи сейчас на 100% больше (тоесть, вдвое) размера реально достижимых объектов после 
        последнего цикла GC. «200» означает, что общий размер кучи на 200% больше (тоесть, в три раза), чем размер реально 
        используемых объектов. Если вы хотите уменьшить общее количество времени работы GC, увеличьте GOGC. Если вы хотите 
        отдать больше времени GC, и выиграть себе память — уменьшайте GOGC.

        Важно понимать, что по мере того, как количество памяти удвоится со следующим поколением железа, простое увеличение 
        GOGC вдвое уменьшит количество циклов GC вдвое. С другой стороны, так как GOGC оперирует понятием достижимых объектов, 
        увеличение нагрузки и сопутствующее увеличение количества достижимых объектов не нуждается в ретюнинге. Приложение 
        просто масштабируется. Более того, необременённая поддержкой дюжин ползунков, команда, пишущая рантайм языка может 
        сфокусироваться на улучшении рантайма, основываясь на фидбеке от реальных программ в продакшене.

        Сегодня 16 гигабайт памяти стоят 100$ и все процессоры многоядерны, и поддерживают гипертрединг. Через 10 лет это железо 
        будет выглядеть устаревшим, но программы написанные на Go сегодня должны будут уметь масштабироваться, чтобы работать на 
        растущих ресурсах железа и быть готовыми к «следующему прорыву» (next big thing). Учитывая, что железо дает возможность 
        наращивать пропускную способность, сборщик мусора Go разрабатывается так, чтобы отзывчивость и маленькие паузы были 
        приоритетом, а тюнинг происходил одним ползунком. Go 1.5 это первый большой шаг в этом направлении, и эти первые шаги 
        навсегда повлияют на дальнейшее развитие Go и на программы, написанные на нём. Этот пост даёт обзорную картинку того, 
        что мы сделали в Go 1.5 сборщике.

        Чтобы установить целевой процент GC, вы передаете GOGC переменная среды при запуске вашей программы. Если вы установите 
        его явно, ничто не помешает вам получить его с помощью os.Getenv().
            GOGC=50 go run *.go
        Второй вариант заключается в использовании debug.SetGCPercent(percent int) int. Как указано в документации пакета:
            SetGCPercent устанавливает целевой процент сборки мусора: сборка запускается, когда отношение только что выделенных 
            данных к оперативным данным, оставшимся после предыдущей сборки, достигает этого процента. SetGCPercent возвращает 
            предыдущую настройку . Исходной настройкой является значение переменной среды GOGC при запуске или 100, если 
            переменная не установлена. Отрицательный процент отключает сборку мусора. 
                prev := debug.SetGCPercent(0)
                fmt.Println(prev) // 100 : this is the most previous setting.
                debug.SetGCPercent(prev) // since we have the previous setting, we can freely revert it to the original.


    // Проблема частого запуска GC https://github.com/golang/go/issues/23044
        Часто отмечалось, что программы, которые производят много аллокаций памяти, сохраняя при этом маленькую живую кучу, в 
        конечном итоге производят чрезмерную сборку мусора. 

        В моей компании мы замечали это несколько раз. Как правило, это проблема приложений обработки данных, которые могут 
        считывать и записывать сообщения из очередей с большой скоростью, но в долгосрочной перспективе сохраняют очень мало данных. 

        Существующие обходные пути решения этой проблемы:
            1) GOGC - Ручка, доступная для управления этой ситуацией. Когда мы сталкивались с этими проблемами в прошлом, мы 
            устанавливали высокие значения GOGC, и это в значительной степени устраняло проблему, по крайней мере, в краткосрочной перспективе.    
            Если установить это значение очень большим, то GC приступит к сборке мусора только тогда, когда размер кучи увеличится до 
            GOGC/50 раз после последнего цикла GC. Тут проблемой может быть увеличение размера кучи (GC не освобождает).

            2) SetGCPercent 
            Одним из способов устранения недостатков GOGC является динамическая корректировка его значения. Это возможно с помощью runtime/debug.SetGCPercent. 
            При таком подходе есть как минимум две проблемы:
                -Мы не можем реагировать на произвольно быстрое увеличение размера кучи. Если куча очень маленькая и мы устанавливаем SetGCPercent очень 
                высоким, мы склонны к OOMing, если куча внезапно увеличивается, прежде чем мы снова настроим SetGCPercent. (И мы не хотим вносить 
                коррективы слишком часто, потому что это недешево.)

                -Насколько я могу судить, динамический размер кучи с конца предыдущей коллекции не раскрывается runtime.MemStats. (Я думаю, что это доступно 
                только при анализе вывода gctrace.) Это число нам действительно нужно, чтобы точно выбрать значение GOGC.
            
            3) Использование балласта в куче
                Выделение в main() большого слайса байт, который определит начальный размер кучи. Программа будет работать без сборки мусора до тех пор, 
                пока размер кучи (вместе со слайсом) не удвоится. Только тогда запустится GC и освободит неиспользуемую память из кучи.
                Проблема: Очевидно, что это не лучшее решение в долгосрочной перспективе, поскольку оно тратит впустую память, которую в противном случае 
                можно было бы использовать для чего-то другого (например, дискового кеша). 

                // Create a large heap allocation of 10 GiB
	            ballast := make([]byte, 10<<30)

                НО! https://medium.com/clean-code-channel/go-memory-ballast-dec0c04830b1
                Не будет ли это использовать до 10Gib моей драгоценной оперативной памяти? 
                    Ответ: Нет, не будет, если вы не сделаете это намеренно. Память в системах nix (и даже Windows) фактически адресована и сопоставлена 
                    через таблицы страниц ОС. При выполнении вышеуказанного кода массив, на который указывает балластный срез, будет выделен в виртуальном
                    адресном пространстве программы. Только если мы попытаемся прочитать или записать в срез, произойдет ошибка страницы, из-за которой 
                    физическая оперативная память, поддерживающая виртуальные адреса, будет выделена.
                        Мы можем легко подтвердить это с помощью следующей тривиальной программы:
                            func main() {
                                _ = make([]byte, 100<<20)
                                <-time.After(time.Duration(math.MaxInt64))
                            }
                        $ ps -eo pmem,comm,pid,maj_flt,min_flt,rss,vsz --sort -rss | numfmt --header --to=iec --field 4-5 | numfmt --header --from-unit=1024 --to=iec --field 6-7 | column -t | egrep "[t]est|[P]ID"
                        %MEM  COMMAND          PID    MAJFL  MINFL  RSS   VSZ
                        0.2   test_alloc       27826  0      1003   4.8M  108M

                        Это показывает, что чуть более 100MiB памяти было выделено практически процессу-V irtual S i Z e( VSZ ), 
                        в то время как ~5MiB было выделено в резидентном наборе — R esident S et S ize (RSS ), i.e физическая память.

                (!) Таким образом, пока мы не читаем или не пишем в балласт, мы можем быть уверены, что он останется в куче только как виртуальное распределение.





// Распределенная трассировка
    Часто для решения сложных проблем и понимания слабых мест в микросервисной 
    архитектуре бывает недостаточно мониторинга её отдельных элементов. Тогда 
    необходимо получать информацию о взаимодействии между сервисами. Например, о 
    топологии запросов и задержках сети, об узких местах производительности, о 
    контексте расследуемых ошибок. Для решения подобных задач мы обращаемся к 
    распределённой трассировке. Распределённая трассировка — это процесс отслеживания 
    и сбора информации взаимодействиях внутри стека. По её итогу мы получаем путь, 
    время, которое занял каждый вызов, и задержку ответа.

    Зачем нужна распределённая трассировка:
        найти узкие места в производительности
        визуализировать последовательности вызовов
        собрать информацию для дальнейшего анализа

    Единица информации распределённой трассировки — span. Это описание рабочего 
    процесса, которое обычно содержит имя, время начала и окончания, уникальный ID
    и теги.
    
    OpenTracing, OpenCensus, OpenTelemetry
        OpenTracing библиотека, стандартизирующая процесс добавления распределённой 
        трассировки запросов в ваше приложение. Это слой абстракции над существующими 
        решениями, такими как Jaeger, Zipkin, Lightstep и другие. OpenCensus содержит
        библиотеки для нескольких языков, которые позволяют захватывать, обрабатывать 
        и перенаправлять метрики и трейсы. С недавнего времени OpenTracing и OpenCensus 
        слились в единый проект OpenTelemetry, имеющий обратную совместимость. 
        OpenTelemetry — это набор API, SDK, инструментов и интеграций для управления 
        данными телеметрии. OpenTelemetry предоставляет: единую, не зависящую от 
        производителя инструментальную библиотеку для каждого языка, сквозную реализацию
         для генерации, передачи, сбора, обработки и экспорта данных телеметрии, 
         полный контроль над данными с возможностью их параллельной отправки в разные 
         бэкенды. Обе библиотеки в Go используют контекст (context.Context) для хранения
         спанов с трассировочной информацией, благодаря чему очень легко создать новый 
         спан. Пример для OpenCensus:

        ctx, span := trace.StartSpan(ctx, "doWork")
        defer span.End()

    Jaeger
        Jaeger - это распределённая система отслеживания (трассировки), выпущенная 
        компанией Uber Technologies. Является реализацией стандарта OpenTracing.

        Jaeger был вдохновлён Dapper и OpenZipkin, написан на Go и является частью 
        CNCF (Cloud Native Computing Foundation).

        Архитектура (на примере прямой работы с БД):
        https://drive.google.com/file/d/1WuwpiIpx8t74IVXKyrKgr3ZUb8zZtG-S/view?usp=sharing
        Для БД Jaeger рекомендует Elasticsearch вместо Cassandra, поскольку у неё 
        ограниченная функциональность по поиску.

        Span
        Span - представляет собой логическую единицу в Jaeger, у которой есть имя
        операции, время начала операции и продолжительность. Span'ы могут быть 
        вложенными и упорядоченными для моделирования причинно-следственных связей.
        https://drive.google.com/file/d/1WuwpiIpx8t74IVXKyrKgr3ZUb8zZtG-S/view?usp=sharing

        Trace (Трассировка) - это путь данных / выполнения в системе, который можно 
        рассматривать как ориентированный ациклический граф span'ов.
        
        Взаимодействие с кодом
        Сервис (приложение) создает span'ы при получении новых запросов и прикрепляет
        контекстную информацию (идентификатор трассировки, идентификатор span'а и 
        мета-данные, которые определяются пользователем) к исходящим запросам. 
        С запросами распространяются только идентификаторы и мета-данные; все остальные 
        данные профилирования, такие как имя операции, время, теги и логи, не передаются. 
        Вместо этого они передаются из процесса в серверную часть Jaeger асинхронно в 
        фоновом режиме.

        Поскольку приложение обычно сильно нагружено, для уменьшения накладных расходов 
        применяется выборка (сэмплирование, sampling). По умолчанию собирается 
        только 0.1% trace'ов, но существуют и другие стратегии.

        UI, главное окно Jaeger:
        https://drive.google.com/file/d/1WuwpiIpx8t74IVXKyrKgr3ZUb8zZtG-S/view?usp=sharing
        
        Окно трейса (развернуто):
        https://drive.google.com/file/d/1WuwpiIpx8t74IVXKyrKgr3ZUb8zZtG-S/view?usp=sharing



// Покрытие кода тестами. Тестирование. (Testing)
    Пакет testing обеспечивает поддержку автоматического тестирования пакетов Go. 
    Он предназначен для использования совместно с командой "go test", которая автоматизирует выполнение любой функции формы

    //где Xxx не начинается со строчной буквы. Имя функции служит для идентификации процедуры тестирования.
    func TestXxx(*testing.T)
    
    Чтобы написать новый набор тестов, создайте файл, имя которого заканчивается _test.go и содержит функции TestXxx, 
    как описано здесь. Поместите файл в тот же пакет, что и тестируемый. Файл будет исключен из обычных сборок пакетов, 
    но будет включен при запуске команды "go test".

    Простая тестовая функция выглядит так:
    func TestAbs(t *testing.T) {
        got := Abs(-1)
        if got != 1 {
            t.Errorf("Abs(-1) = %d; want 1", got)
        }
    }

    % покрытия кода тестами в VS Code можно узнать так:
    ПКМ --> палитра команд (ctrl+shift+p) 
    и ввести cove... и выбрать "Go toggle test coverage"
    запуск из консоли теста (из директории): go test -run ''

    go test -v                                          // запуск теста
    go test -v -cover                                   // с учетом покрытия
               -json                                    // сохранение в json
               -run <TestFuncName/SubtestNameInFunc>    //   
    
    // построение отчета для следующей команды
    go test -coverprofile=cover.out                 // выведет отчет: coverage %

    // проверка покрытия кода тестами. Создастся файл html с результатами покрытия кода тестами
    go tool cover -html=cover.out -o comer.html     // используем файл отчета на предыдущем шаге




    
Основы HTTP

Обработка HTTP запросов

Как получить значение GET параметра myParam при POST-запросе в котором есть параметр с таким же именем в теле запроса (POST-параметрах)  ?
    [ok] r.URL.Query().Get("myParam")
    [x] r.FormValue("myParam") - Это был бы правильный ответ в случае, если у нас только GET-запрос. 
        Однако в данном случае у нас POST-запрос, а параметры, переданные в теле запроса имеют приоритет 
        над параметрами в урле. Т.е. вы получите значение POST-параметра , а не GET-параметра








Настройка Kubernetes (k8s)
    Как подключиться для выполнения заданий.

        Установить себе kubectl (Официальная документация)
        Проверяем, что kubectl готов к работе:

            # при успешном выполнении вы увидите версию установленного kubectl. 
            kubectl version --client

        3. В зависимости от вашей операционной системы помещаем конфиг, который мы
        пришлем вам, в нужную директорию:

            linux/macOS: ~/.kube/

            windows: %USERPROFILE%/.kube

        Важно! Конфиг должен иметь имя config и не иметь расширения

            cp ~/Downloads/<user>-kubeconfig ~/.kube/config

            ls -la ~/.kube/config

        4. Установим namespace:

            # Просмотр доступных namespace
            kubectl get ns

            # Установка namespace в конфиге
            kubectl config set-context --current --namespace=<namespace>

        5. Проверяем, что вам доступен ваш namespace:

            # Создадим тестовый deployment
            kubectl create deployment --image=nginx nginx-app
            # при успешном выполнении вы увидите: deployment.apps/nginx-app created

            # Удалим тестовый deployment
            kubectl delete deployment nginx-app
            # при успешном выполнении вы увидите: deployment.apps "nginx-app" deleted

        Deploy
        В рамках курса мы хотим максимально автоматизировать нашу работу. Для того, 
        чтобы не тратить время и силы на окружение и деплой, мы постараемся использовать
        CI инструменты.

        Для создания CI необходимо:
        1. В своей подгруппе создать токен с правами на чтение репозитория 
            (Gitlab->settings->repository->Deploy Tokens).

            Заполняем имя токена, может быть любым
            Выбираем read_repository
            Выбираем read_registry
            Выбираем read_package_registry

        2. Дальше полученный токен нужно применить в кластере. Нужно, чтобы текущий 
        контекст был кластера teta и вашего namespace.

            kubectl create secret docker-registry regcred --docker-server=registry.gitlab.com --docker-username=<Your new Deploy Token username> --docker-password=<Use this token as a password> --docker-email=<email>
            kubectl patch serviceaccount default -p '{"imagePullSecrets": [{"name": "regcred"}]}'

        3. Отлично! Мы готовы деплоить.
        4. Создадим Dockerfile в корнях каждого проекта:

            FROM golang:1.17.1-alpine as builder
            WORKDIR /build

            COPY . /build/
            RUN CGO_ENABLED=0 GOOS=linux go build -a -o auth ./cmd
            RUN go mod download

            # generate clean, final image for end users
            FROM alpine:3.11.3
            COPY --from=builder /build/auth /auth

            # executable
            ENTRYPOINT [ "/auth" ]

            auth нужно поменять на имя вашего приложения.

        5. Также в корнях проектов создаем файл .gitlab-ci.yml, который содержит 
        описания стадий СI:

            stages:
            - test
            - build
            - image
            - deploy

            test:
            image:
                name: golang:1.17.1-stretch
            stage: test
            script:
                - go test -v ./...

            build image:
            image:
                name: gcr.io/kaniko-project/executor:v1.6.0-debug
                entrypoint: [""]
            stage: build
            needs: []
            variables:
                CONTEXT: $CI_PROJECT_DIR
                DOCKERFILE: $CI_PROJECT_DIR/Dockerfile
                PREFIX: ""
            script:
                - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > /kaniko/.docker/config.json
                - /kaniko/executor --context $CONTEXT --dockerfile $DOCKERFILE --destination ${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME} --cache=true --cache-ttl=120h

            .image_deploy:
            image: 
                name: lachlanevenson/k8s-kubectl:v1.22.0
                entrypoint: [""]
            stage: deploy
            when: manual
            needs:
                - build image
            script:
                - export K8S_WORKLOAD_TYPE=deployment
                - export K8S_WORKLOAD_NAME=$CI_PROJECT_NAME
                - export K8S_CONTAINER_NAME=$CI_PROJECT_NAME
                - export K8S_NS=$(echo $CI_PROJECT_PATH | awk -F\/ '{print $(NF-1)}')
                - echo "Deploy $K8S_WORKLOAD_TYPE $K8S_WORKLOAD_NAME to namespace $K8S_NS"
                - kubectl create deployment $K8S_WORKLOAD_NAME --image=$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME -n ${K8S_NS} || echo deployment already exists
                - kubectl --record ${K8S_WORKLOAD_TYPE}.apps/${K8S_WORKLOAD_NAME} set image ${K8S_WORKLOAD_TYPE}.v1.apps/${K8S_WORKLOAD_NAME} ${K8S_CONTAINER_NAME}=$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME -n ${K8S_NS}
                - kubectl rollout restart ${K8S_WORKLOAD_TYPE} ${K8S_WORKLOAD_NAME} -n ${K8S_NS} 
                - kubectl rollout status ${K8S_WORKLOAD_TYPE} ${K8S_WORKLOAD_NAME} -n ${K8S_NS} --timeout=60s

            deploy staging:
            extends: .image_deploy
            when: always
            only:
                - main

            6. Делаем push и наблюдаем, как запустится CI.



// Swagger
    Для запуска генерации/обновления документации:
    swag init -g cmd/auth/main.go

    через ключ -d указываем папки для поиска аннотаций
    через запятую, причем первая папка должна ссылаться на главную аннотацию
    swag init -g main.go -d cmd,pkg/handler



GoMock
    go get github.com/golang/mock/mockgen
    перегенерировать моки
    go generate ./...


GO111MODULE 
    GO111MODULE это переменная среды, которая может быть установлена ​​при использовании
    go для изменения способа импорта пакетов Go. 
        GO111MODULE=on: требует наличие go.mod и заставит использовать модули Go, даже если проект находится в вашем GOPATH
        GO111MODULE=off: заставляет Go вести себя так, как GOPATH, даже за пределами GOPATH.
        GO111MODULE = auto - режим по умолчанию.  В этом режиме Go будет вести себя аналогично GO111MODULE = on, 
            когда вы находитесь за пределами GOPATH, аналогично GO111MODULE = off, когда вы находитесь внутри 
            GOPATH, даже если присутствует go.mod.

    Когда вы находитесь в GOPATH и хотите выполнить операцию, требующую модулей Go (например, go get), то нужно выполнить
        GO111MODULE=on go get github.com/golang/mock/tree/master/mockgen@v1.3.1
    
    GO111MODULE  может быть очень полезным для включения поведения модулей Go, вот ответ: потому что 
        GO111MODULE=on 
    позволяет выбрать версию. При GO111MODULE=off, go get получает последний commit от 
    мастера. С помощью модулей Go вы можете выбрать конкретную версию на основе тегов git. 

    Установка бинарников с GO111MODULE=on go get в Go>1.17 устарела. Вместо этого нужно использовать
        go install golang.org/x/tools/gopls@latest



go mod vendor + go build -mod=vendor
    Команда заставит go использовать файлы зависимостей из директории vendor/ вместо использования $GOPATH/pkg/mod



go.mod, go.sum
    Файл go.mod - это корень управления зависимостями в GoLang. Все модули, которые необходимы или будут использоваться в проекте, хранятся в файле go.mod.
    Для всех пакетов, которые мы собираемся импортировать / использовать в нашем проекте, будет создана запись этих модулей в go.mod. Наличие файла go.mod 
    экономит усилия по запуску команды go get для каждого зависимого модуля для успешного запуска проекта. (если вы хотите установить определенный пакет, 
    вы можете установить его с помощью команды go get, например go get go.mongodb.org/mongo-driver) 
    
    go mod init — создает новый модуль, инициализируя файл go.mod, описывающий модуль. Вначале он только добавит путь к модулю и версию Go в файл go.mod.

    После выполнения любой команды создания пакета, такой как go build, go test в первый раз, он будет устанавливать все пакеты с определенными версиями т.е. 
    которые являются последними на данный момент. Он также создаст файл go.sum, который поддерживает контрольную сумму, поэтому при повторном запуске проекта
    он не установит все пакеты снова. Он использует кеш, который хранится в каталоге $GOPATH/pkg/mod (каталог кеша модуля).

    go.sum - это сгенерированный файл, вам не нужно редактировать или изменять этот файл.




GO VET
    Как и многие команды, go vetработает со списком пакетов . Пакеты могут быть перечислены разными способами.
    Запуск go vet для всего проекта:
        go vet ./...

    Вы можете подтвердить список проверяемых пакетов, используя go listвместо:
        go list ./...


GOLINT
    Запуск go vet для всего проекта:
        golint ./...



https://habr.com/ru/company/otus/blog/586108/
Узнать, как Go управляет памятью, выделенной под стек горутины, можно взглянув на ассемблерный код Go с помощью команды: 
    go build -gcflags -S main.go

Директивы компилятора го ?
//go:nosplit

//go:embed data.json        - запишет содержимое файла data.json записывать в переменную (можно еще в файловую систему)
var jsonBytes []byte



// Обновление версий пакетов
    Вы можете использовать go get -u или go get -u=patch для обновления зависимостей до последней минорной версии или патча соответственно.
    https://habr.com/ru/company/otus/blog/503918/

    $ go get -u  git.wildberries.ru/oer/tokenizer@v0.2.2
    go: downloading git.wildberries.ru/oer/tokenizer v0.2.2
    go get: upgraded git.wildberries.ru/oer/tokenizer v0.1.9 => v0.2.2


//  вопросы из курса го slurm.io
    ? кросскомпиляция и build теги
    ? Docker SDK для Go
    ? Работа с докером из Go
    ? Паттерны kubernetes:
        -health probe\liveness probe
        -periodic job
        -daemon service
        -stateful service
        -service discover\service mesh
        -sidecar\adapter
        -controller\operator
    ? Операторы k8s:
        -что такое операторы k8s
        -назначение операторов
        -состав оператора (контроллер, индексер, kube API)
        -CRDs
        -Состав контроллера
        -Пишем свой контроллер для деплоймента
        -Пишем оператор с помощью kubebuilder
        -Собираем проект для ручных тестов в кластере
        -Обзор ginkgo (пишем тесты), обзор основных фреймворков для создания операторов, kubeclient готового http-сервера


