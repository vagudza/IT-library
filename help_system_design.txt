Вопросы для интервьювера на собеседовании System Design

1. Понять задачу и определить масштаб решения
- Какие возможности будем реализовывать?
- Сколько пользователей у нашего продукта?
- Как скоро планируется наращивание мощностей? Какой масштаб планируется через 3 месяца, полгода, год?
- Как выглядит технологический стек компании? Какие существующие сервисы можно применить для упрощения архитектуры (биллинг, авторизация, админка...)?

2. Предложить общее решение и получить согласие
3. Глубокое погружение в проектирование



System Design Interview (Заметки из доклада А. Поломодова из Тинькова)
1) Название, контекст, требования (функциональные/нефункциональные)
2) Формализация задачи: функциональность, главные архитектурные характеристики, вопросы про сайзинг (users, requests, объем данных для хранения и срок хранения...)
    Функциональные требования - Use Cases (UML), User Stories, Happy path, corner cases, jobs to be done - ожидания от системы
    Нефункциональные требования - например, консистентность очень важна (в сервисе бронирования отелей важно не продать те номера, которые уже забронированы)

    !изучить! 
    Architecture Tradeoff analysis method
    Вигерс "Software Requirements Third Edition"
    "Software Architecture for busy developers"

    Результат: понимание задачи, формализация текстом если ее нет. Вычисление средней и пиковой RPS из исходных данных

3) Границы системы, обрабатываемые сценарии, публичный API 
    Границы системы: важно выбрать способ интеграции системы с другими системами - 4 вида: 
        - через файлы (дампы, например)
        - базы данных 
        - API
        - Messaging

    Если выбрал API, то какой подход? REST, RPC, GraphQL, AsyncAPI...
    После выбора подхода нужно описать контракт

    !изучить! 
    System Context Diagram (c4 model)
    Сети и протоколы - OSI, UDP, TCP/IP, DNS, HTTPs 1/2/3, Websockets...
    Балансировщики нагрузки - Nginx, HaProxy
    Tannenbaum "Computer Networks"
    Hohpe "Enterprise Integration Patterns"

    Результат: верхнеуровневая модель С4 и REST api контракты (эндпоинт, тип запроса, тело запроса)

4) Потоки данных и компоненты системы. Итеративная проработка (happy path, нагрузка и нефункциональные требования, corner cases - когда части системы отваливаются)
    Основные потоки и компоненты системы (важно спрашивать, чтобы не уйти в детали):
    - Happy Path - основной поток работы
    - Exceptional flows 
    - Научиться определять read/write path для системы с учетом архитектурных характеристик (CQRS?)

    ! важно спроектировать эндпоинты с описанием что и как передаем
    ! описать модели данных, передаваемых по конкретным эндпоинтам

    !изучить! 
    IDEF0/DFD/BPMN диаграммы
    Kleppmann "Designing data-intensive Applications" (проектирование новостной ленты приводится в книге)

    Результат: дополнение модели C4, можно приступать к наброску схемы дизайна

5) Концептуальная схема готова: прописаны публичные API, компоненты системы определены до классов систем (key-value, rdbms, column family...). 
    Расписаны модели данных для обмена. Важно:
    Разделять рабочие нагрузки: stateful/stateless
    Связывать между собой компоненты (stateful/stateless). Stateless - легко масштабировать
    Проектирование модель данных
    Выбрать классы для stateful компонентов (RDBMS - реляционные БД, NoSQL по основным типам: key-value, Document-orientired, column-orientired, Graph)

    !изучить!
    DDD - как делить систему на части и конкретно виды subdomain и bounded context
    Моделирование ER Diagram, Class Diagrams
    12-Factor app
    Какие базы данных бывают и их границы применимости
    Как работают оркестраторы рабочих нагрузок (k8s)
    "Software Architecture: The Hard parts"
    "k8s patterns"

    Результат: схема компонентов системы с указанием связей. Описана модель данных (схема таблиц БД) 

6) Выбор конкретных технологий + расчет под нагрузку
    Реальная схема и желаемые архитектурные характеристики
    - выбрать конкретных представителей систем из перечисленных в концептуальной схеме
    - проектировать систему с учетом ее развития (logs, monitoring, migrations) и доменов отказа 
    - масштабировать stateless компоненты (в k8s - Horisontal Pod Autoscale, Vertical Pod Autoscale)
    - масштабировать stateful компоненты (
        масштабирование по чтению - replication, ослабления по Consistency
        масштабирование по записи - Партиционирование и Шардинг, важно чтобы ключ шардирования не требовал поиска по разным шардам
        )

    !изучить!
    "Building Secure and Reliable Systems" от Google
    "Database Internals" - когда бд становятся распределенными
    "Distrubuted Systems" Танненбаум (устаревшие системы)

    Результат: схема дополнена конкретными технологиями, аргументирован их выбор

Советы для успешного прохождения интервью:
- Помнить о времени
- Не начинать проектировать сразу
- Делиться своими размышлениями 
- Проявлять самостоятельность в проектировании - вести интервью
- Реагировать на наводящие вопросы и уточнения
- Говорить уверенно о том, что знаешь, не знаешь - лучше не утверждать
- Подготовить вопросы к интервьюверу, если для них останется время (например, а как в компании решаются архитектурные вопросы)




CQRS pattern:
Раздление запросов на чтение и на запись:
              /-->command--> [Write DB] (Tables)
user -> UI-->                     V  (Eventual Consistency)
              \-->query-->   [Read DB] (multiread view)



Транзакции, охватывающие множество физических систем или компьютеров в сети, называются попросту распределенными транзакциями. В мире микросервисов транзакция 
распределяется между множеством сервисов, которые вызываются в некоторой последовательности для завершения всей транзакции.

Обработка распределенных транзакций в микросервисной архитектуре:
- Двухфазный коммит - стандартизированный протокол, который обеспечивает реализацию фиксации базы данных в ситуации, 
когда операция фиксации должна быть разбита на две отдельные части. В распределенной транзакции требуется специальный объект, известный как координатор. 
    Как следует из его названия, координатор организует действия и синхронизацию между распределенными серверами. Двухфазная фиксация реализуется следующим образом:
    В распределенной транзакции требуется специальный объект, известный как координатор. Как следует из его названия, координатор организует действия и синхронизацию 
    между распределенными серверами. Двухфазная фиксация реализуется следующим образом:
    Фаза 1 - Каждый сервер, которому необходимо зафиксировать данные, записывает свои записи данных в журнал. Если сервер неудачен, он отвечает сообщением об ошибке. 
    В случае успеха сервер отвечает сообщением OK.
    Фаза 2 - Эта фаза начинается после того, как все участники ответят ОК. Затем координатор отправляет сигнал каждому серверу с инструкциями по фиксации. 
    После фиксации каждый записывает коммит как часть своей записи журнала для справки и отправляет координатору сообщение о том, что его фиксация была успешно 
    реализована. В случае сбоя сервера координатор отправляет всем серверам инструкции для отката транзакции. После отката серверов каждый отправляет отзыв, что
    это было выполнено.

    Преимущества
        Такой подход гарантирует атомарность транзакции. Транзакция завершится либо в том случае, когда оба микросервиса сработают успешно, либо в случае, когда 
        микросервисы не внесут никаких изменений.
        Во-вторых, данный подход позволяет изолировать чтение от записи, так как изменения в объектах не видны до тех пор, пока координатор транзакций не 
        зафиксирует эти изменения.
        Данный подход представляет собой синхронный вызов, при котором клиент будет уведомлен об успехе или неудаче.

    Недостатки
        Не бывает ничего совершенного; двухфазные фиксации протекают довольно медленно по сравнению с операциями над одним микросервисом. Они сильно зависят 
        от координатора. транзакций, что может значительно замедлять работу системы в период высокой загруженности.
        Другой серьезный недостаток заключается в блокировке строк базы данных. Блокировка может стать узким местом, затрудняющим производительность, причем, 
        может возникнуть взаимная блокировка, где две транзакции намертво стопорят друг друга.
        Однако некоторые реализации участников, такие как базы данных NoSQL и брокер сообщений, не поддерживают эту модель.


- Согласованность в конечном счете и компенсация / SAGA.
    Согласованность в конечном счете (eventual consistency): каждый сервис публикует событие всякий раз, когда обновляет свои данные. Другие сервисы подписываются на события. 
    При получении события сервис обновляет свои данные.

    При таком подходе распределенная транзакция выполняется как совокупность асинхронных локальных транзакций на соответствующих микросервисах. Микросервисы обмениваются 
    информацией через шину событий.
    Сага — это последовательность транзакций, которая обновляет каждую службу и публикует сообщение или событие для активации следующего шага транзакции. Если шаг 
    завершается неудачно, сага выполняет компенсирующие транзакции, которые противодействуют предыдущим транзакциям.

    Существует два распространенных подхода к реализации сага: хореография и оркестрация. 
        1 Хореография (events через шину Message Broker) — это способ координации саг, где участники обмениваются событиями без централизованной точки контроля. 
            При использовании хореографии каждая локальная транзакция публикует события домена, которые активируют локальные транзакции в других службах.
            Преимущества
                Подходит для простых рабочих процессов, для которых требуется мало участников и не требуется логика координации.
                Не требует дополнительной реализации и обслуживания службы.
                Не представляет единой точки отказа, так как обязанности распределяются между участниками саги.

            Недостатки
                Рабочий процесс может запутать при добавлении новых шагов, так как трудно отслеживать, какие участники саги слушают какие команды.
                Существует риск циклической зависимости между участниками саги, потому что они должны использовать команды друг друга.
                Тестирование интеграции сложно, так как для имитации транзакции должны быть запущены все службы.

        2 Оркестрация
            Оркестрация — это способ координации саг, в котором централизованный контроллер сообщает участникам саги, какие локальные транзакции следует выполнять. 
            Оркестратор саги обрабатывает все транзакции и сообщает участникам, какие операции следует выполнить на основе событий. Оркестратор выполняет запросы сага, 
            сохраняет и интерпретирует состояния каждой задачи, а также обрабатывает восстановление сбоев с помощью компенсирующих транзакций.  

    Преимущества Саги
        Хорошо подходит для сложных рабочих процессов с участием большого количества участников или новых участников, добавленных с течением времени.
        Подходит, когда есть контроль над каждым участником процесса, и контроль над потоком действий.
        Не вводит циклических зависимостей, так как оркестратор в одностороннем порядке зависит от участников саги.
        Участникам Saga не нужно знать о командах для других участников. Четкое разделение задач упрощает бизнес-логику.

    Недостатки Саги
        Для дополнительной сложности проектирования требуется реализация логики координации.
        Существует дополнительная точка отказа, так как оркестратор управляет полным рабочим процессом.

    v2
    Преимущества
        Серьезное преимущество такого подхода заключается в том, что каждый микросервис сосредотачивается лишь на собственной атомарной транзакции. Работа микросервисов 
        не блокируется, если на работу другого сервиса требуется сравнительно много времени. Это также означает, что не требуется блокировать и базу данных. 
        При помощи такого подхода можно обеспечить хорошую масштабируемость системы при работе под высокой нагрузкой, поскольку предлагаемое решение асинхронное 
        и основано на работе с событиями.

    Недостатки
        Основной недостаток этого подхода заключается в том, что здесь не обеспечивается изоляция при чтении. Таким образом, в вышеприведенном примере клиент увидит, 
        что что заказ был создан, но уже через секунду заказ будет удален в ходе компенсирующей транзакции. Кроме того, когда увеличивается количество микросервисов, 
        усложняется их отладка и поддержка.


    Первая альтернатива предложенному подходу обработки распределенных транзакций в микросервисной архитектуре (2PC/Saga) – вообще отказаться от распределенных транзакций. Если 
    создается новое приложение, начинайте с монолитной архитектуры, как описано в MonolithFirst у Мартина Фаулера. Процитирую его.
        "Более распространен подход, когда система создается в виде монолита, после чего по краям от нее постепенно начинают отсекаться микросервисы. При таком подходе 
        в сердце микросервисной архитектуры остается крупное монолитное ядро, но большинство новых разработок приходится на микросервисы, а монолит остается относительно
        нетронутым." — Мартин Фаулер

    Если необходимо обновить данные сразу в двух местах в результате одного события, то подход с согласованностью в конечном счете/ SAGA предпочтителен при обработке 
    распределенных транзакций по сравнению с двухфазным подходом. Основная причина в том, что двухфазный подход в распределенной среде не масштабируется. При использовании 
    согласованности в конечном счете также возникает свой набор проблем, например, как атомарно обновлять базу данных и порождать событие. Переходя к такой философии 
    разработки, необходимо изменить ее восприятие как с точки зрения разработчика, так и с точки зрения тестировщика.


CAP теорема

    Consistency (согласованность данных) — во всех узлах в один момент времени данные одинаковые (БД или ее реплика).
    Availability (доступность) — в любой момент времени при обращении к БД мы хотим чтобы она всегда отвечала нам (24 на 7).
    Partition tolerance (устойчивость к разделению) — разбиение большой БД на несколько мелких не нарушает нашу работу никаким образом.
    CAP теорема говорит нам о том, что в любой реализации распределенных вычислений возможно обеспечить лишь 2 из этих 3 свойств!


    ACID

Теперь давайте вспомним что такое ACID из понятия реляционных БД.

    Atomicity — атомарность гарантирует, что каждый запрос в транзакции будет выполнен успешно, либо в случае ошибки вообще
     не будет выполнен. Т.е. транзакция выполняется либо полностью вся, либо нет. Частичного выполнения быть не может.
    Consistency — консистентность (согласованность) даёт гарантию того, что все данные будут целостны.
    Isolation — изолированность гарантирует, что все транзакции будут выполняться изолированно и последовательно друг за 
    другом, но для пользователя это будет выглядеть будто бы транзакции выполняются параллельно.
    Durability — устойчивость к ошибкам гарантирует о том, что любые изменения, внесённые транзакцией, останутся навсегда
     и не может быть потери данных, если транзакция прошла успешно.



Кратко о блокировках в БД

Блокировка - в реляционных базах данных это установка метки на запись, что запись заблокирована для изменений.
Существует два вида блокировок - оптимистичная и пессимистичная.
Оптимистичная блокировка - При оптимистичной блокировке на базе данных реальной блокировки не происходит. Вместо этого используется следующий подход - если во время 
выполнения транзакции она изменяет данные, которые были изменены после её начала, то транзакция прерывается с исключением. Использование оптимистичных блокировок позволяет 
избежать взаимных блокировок (dead-lock). Для реализации оптимистичной блокировки часто используется версионирование данных - в таблицу добавляется колонка, которая 
хранит текущую версию. При выполнении update в запросе в секции where передается версия данных, которая была забрана на изменение. Если update вернул 0 изменённых 
строк, значит данные были уже изменены и транзакцию необходимо запускать заново. Вместо версии можно хранить время последнего изменения данных.

Пессимистичная блокировка - При пессимистичной блокировке для записи ставится эксклюзивная блокировка на уровне базы данных, запрещая таким образом доступ к данным из 
других транзакций. Существует несколько видов пессимистичных блокировок:
    блокировка при чтении
    блокировка при записи

При блокировке при чтении запись блокируется когда она запрашивается из базы данных. Недостаток метода в том, что таким образом можно заблокировать даже те данные, 
которые не изменяются в рамках текущей транзакции.
При блокировке при записи блокировка даных происходит при их обновлении в базе данных до конца текущей транзакции.
Блокировка с данных снимается либо при коммите, либо при откате транзакции.

Сравнение оптимистичных и пессимистичных блокировок
При разработке программного обеспечения необходимо выбирать стратегию блокировок данных. При этом следует учитывать следующее:
    Если ситуация обновления одних и тех же данных в один момент времени относительно редка, то выгоднее использовать оптимистичную блокировку. В этом случае не будут 
        происходить дорогая операция блокировки ресурсов.
    Если же возможность возникновения ситуации обновления одних и тех же данных достаточно высока, то лучше использовать пессимистичную блокировку, это снизит количество 
        прерванных транзакций.
    Также следует учитывать, что при оптимистичной блокировке в случае прерывания транзакции её нужно запускать заново.



MVCC (англ. multiversion concurrency control — управление параллельным доступом посредством многоверсионности) — один из механизмов СУБД для обеспечения 
параллельного доступа к базам данных, заключающийся в предоставлении каждому пользователю так называемого «снимка» базы, обладающего тем свойством, что 
вносимые пользователем изменения невидимы другим пользователям до момента фиксации транзакции. Этот способ управления позволяет добиться того, что пишущие 
транзакции не блокируют читающих, и читающие транзакции не блокируют пишущих. 

MVCC (Multiversion Concurrency Control, Многоверсионное управление конкурентным доступом). Это означает, что каждый SQL-оператор видит снимок 
данных (версию базы данных) на определённый момент времени, вне зависимости от текущего состояния данных.
Это защищает операторы от несогласованности данных, возможной, если другие конкурирующие транзакции внесут изменения в те же строки данных, и обеспечивает 
тем самым изоляцию транзакций для каждого сеанса баз данных. MVCC, отходя от методик блокирования, принятых в традиционных СУБД, снижает уровень конфликтов 
блокировок и таким образом обеспечивает более высокую производительность в многопользовательской среде.

Основное преимущество использования модели MVCC по сравнению с блокированием заключается в том, что блокировки MVCC, полученные для чтения данных, не 
конфликтуют с блокировками, полученными для записи, и поэтому чтение никогда не мешает записи, а запись чтению. PostgreSQL гарантирует это даже для самого 
строгого уровня изоляции транзакций, используя инновационный уровень изоляции SSI (Serializable Snapshot Isolation, Сериализуемая изоляция снимков).

Для приложений, которым в принципе не нужна полная изоляция транзакций и которые предпочитают явно определять точки конфликтов, в PostgreSQL также есть 
средства блокировки на уровне таблиц и строк. Однако при правильном использовании MVCC обычно обеспечивает лучшую производительность, чем блокировки. 
Кроме этого, приложения могут использовать рекомендательные блокировки, не привязанные к какой-либо одной транзакции.