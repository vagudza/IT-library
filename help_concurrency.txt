КОНКУРЕНТНОЕ ПРОГРАММИРОВАНИЕ
    Проблема конкурентного программирования - непредсказуемость этапов выполнения кода и синхронизация доступа к данным
    Также не все алгоритмы можно распараллелить очевидным образом.

    Параллельность VS конкурентность
            Параллельность - возможность выполнять несколько потоков одновременно (работают несколько потоков одновременно)
                Пример - обслуживание нескольких клиентов одновременно в магазине с несколькими кассами
            Конкурентность - возможность передавать управление другому потоку в процессе выполнения (работает только один поток в единицу времени) 
                Пример - очередь в кабинет врача.

    Процесс - выполнение программы в ОС
        У каждого процесса:
            - свои ресурсы
            - своя память 
            - свои регистры

    Поток выполнения (ОС) - наименьшая единица обработки, исполнение которой может быть назначено ядром операционной системы. 
        Реализация потоков выполнения и процессов в разных операционных системах отличается друг от друга, но в большинстве случаев поток 
        выполнения находится внутри процесса. Несколько потоков выполнения могут существовать в рамках одного и того же процесса и совместно 
        использовать ресурсы, такие как память, тогда как процессы не разделяют этих ресурсов. В частности, потоки выполнения разделяют 
        последовательность инструкций процесса и его контекст - значения переменных, которые они имеют в любой момент времени.
        Переключение потоков занимает около 12k операций процессора

    Горутина - легковесный поток выполнения кода
        Переключение горутин занимает около 2.4k операций
        У каждой горутины:
            - общие ресурсы
            - общая память
            - общий системный стек
            - общие регистры

    Рантайм в Go - библиотека, она линкуется ко всему. Даже в простом исполняемом файле Hello-world (10Мб) есть шедулер для горутин,
        управление количеством потоков и т.д. 
        
    Шедулер Go в рантайме создает для каждого процессора ИЛИ ядра ИЛИ потока Hyper-Treading
        G - горутины, создаются по необходимости, как минимум одна для main. Управляет G - шедулер Go, а не планировщик ОС
            G перемещаются между потоками ОС, каждый из которых прикреплен к P, то G перемещаются и между P
        M - реальный поток ОС для рантайма Go. M - создается по числу виртуальных процессоров P. Есть функция и переменная среды, позволяющая менять 
            это значение
        P - виртуальный процессор (название структуры) - представляет каждое виртуальное ядро или поток Hyper-Treading
            Для каждого из этих процессоров создается поток M (поток ОС). Служит для выполнения потоков ОС. M прикрепляется к P

    Переключение горутин G выполняется в следующем случае:
        1 запуск новой горутины
        2 сборка мусора
        3 операция синхронизации
        4 системный вызов    

    Горутина - структура, которая выполняет переданную функцию. Самый тяжелый по памяти элемент структуры - stack (2 Kb), который выделяется
    по ее созданию. Stack горутины может увеличиваться, если потребуется. 
    У стека есть максимальный размер 
        1 Gb для 64 битных ОС 
        250Мб для 32 битных ОС
