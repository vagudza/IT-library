// HTML modules guide:
<!-- 
    {{ if gt .Var 10 }}      |    if Obj.Var>10
    ...
    {{ else }}
    ...
    {{ end }}

    lt <
    gt >
    ne !=
    eq =


    {{ range .Hobbies }}
    <p><b>{{ . }}</b><p>
    {{ end }}
-->

Компиляция:

https://metanit.com/go/tutorial/5.1.php
Данный файл также принадлежит пакету main. Файлов может и быть и больше. 
Теперь скомпилируем из этих файлов программу. Для этого перейдем в консоли к папке проекта и выполним команду:
go build -o main.exe factorial.go main.go
Флаг -o указывает, как будет называться выходной файл - в данном случае main.exe. 
Затем идут все компилируемые файлы. После выполнения этой команды будет создан файл main.exe

Теперь рассмотрим другую ситуацию, когда файлы нашей программы разделены по разным пакетам.
Определим в папке проекта каталог computation. 
Затем в каталог computation добавим следующий файл factorial.go:
	
package computation
 
func Factorial(n int) int {
     
    var result = 1
    for i:=1; i <= n; i++{
        result *= i
    }
    return result
}

Код файла factorial.go принадлежит пакету computation. 
Важно отметить, что название функции начинается с заглавной буквы. 
Благодаря этому данная функция будет видна в других пакетах.


Импорт пакетов в Go
И чтобы использовать функцию factorial, надо импортировать этот пакет в файле main.go:
package main
import (
    "fmt"
    "./computation"
)
 
func main() {
     
    fmt.Println(computation.Factorial(4))
    fmt.Println(computation.Factorial(5))
}

Компиляция и выполнение программы осуществляется также как и ранее без необходимости указания всех файлов из других пакетов:
>go run main.go








.................................................................
.................................................................
............................DATABASE.............................
.................................................................
.................................................................
// example of row adding
result, err := db.Exec("insert into productdb.Products (model, company, price) values (?, ?, ?)", 
        "iPhone X", "Apple", 72000)
if err != nil{
    panic(err)
}
fmt.Println(result.LastInsertId())  // id добавленного объекта
fmt.Println(result.RowsAffected())  // количество затронутых строк






.................................................................
.................................................................
...........................GO TUTORIAL...........................
.................................................................
.................................................................
// ПЕРЕМЕННЫЕ
    // Принятый стиль - camelCase

    // значение по умолчанию
    var num0 int

    // значение при инициализации
    var num1 int = 1

    // пропуск типа
    var num2 = 20

    // короткое объявление переменной (возможно только внутри функции)
    num3 := 0
    num3 += 1
    num3++                      // НО ++num3 - НЕТ В GO

    //объявление нескольких переменных и их инициализация
    var a,b,c = 10, 20, 30

    // Если инициализатор присутствует, тип можно не указывать;  переменная примет тип инициализатора
    var c, python, java = true, 3.6, "no!"

    // краткое объявление для нескольких переменных возможно, если хотя бы одна из этих переменных - новая
    a, newVAR := 2, 34

    Общая форма объявления переменной в Go
    // var name type = expression
    указанное выше объявление создает переменную определенного типа, 
    придает ему имя и устанавливает его начальное значение. 
    Либо type, либо = expression могут быть опущены, но не оба. Например:
    var x int = 1
    var a int
    var b, c, d = 3.14, "stackoverflow", true

    var i int
    var U, V, W float64
    var k = 0
    var x, y float32 = -1, -2
    var (
        i       int
        u, v, s = 2.0, 3.0, "bar"
    )
    var re, im = complexSqrt(-1)

    := называется short variable declaration, который принимает форму
    name := expression
    Обратите внимание: 
    := является объявлением, тогда как = является присваиванием
    В отличие от обычных объявлений переменных, краткое объявление переменных может
    повторно объявлять переменные при условии, что они были изначально объявлены ранее
    в том же блоке (или списках параметров, если блок является телом функции) с тем же типом 
    и по крайней мере одной из непустых переменных.
    Как следствие, повторное объявление может появиться только в кратком объявлении с 
    несколькими переменными.  Повторное объявление не вводит новую переменную;
    он просто присваивает новое значение оригиналу.

    Краткие объявления переменных могут появляться только внутри функций.  
    В некоторых контекстах, таких как инициализаторы для операторов «if», «for» или «switch»,
    они могут использоваться для объявления локальных временных переменных.

    Правильно:
    func main() {
        c := 0              // аналог   var c = 0     или     var с int = 0
        i, j := 0, 10       // аналог   var c, d = 0, 1
    }

    // 50 оттенков (habr): Неиспользуемые переменные
    package main
    import "fmt"

    var gvar int // not an error

    func main() {  
        var one int   // ошибка, неиспользуемая переменная
        two := 2      // ошибка, неиспользуемая переменная
        var three int // ошибка UNUSED, даже несмотря на присваивание значения 3 в следующей строке
        three = 3

        func(unused string) {	// не ошибка - объявили и не используем
            fmt.Println("Unused arg. No compile error")
        }("what?")
    }

    // 50 оттенков (habr): Случайное сокрытие переменных
    func main() {  
        x := 1
        fmt.Println(x)     // выводит 1
        {
            fmt.Println(x) // выводит 1
            x := 2
            fmt.Println(x) // выводит 2
        }
        fmt.Println(x)     // выводит 1 (плохо, если нужно было 2)
    }

    !!! При делении стоит быть внимательным, так как если в операции участвуют два целых числа,
    то результат деления будет округляться до целого числа, даже если результат присваивается переменной типа float32/float64:
    var m float32 = 10 / 4          // 2
    var m float32 = 10 / 4.0        // 2.5

    math.Trunc(math.Pi)         // 3 - отбрасываем дробную часть



// ТИПЫ ДАННЫХ
    // int - платформозависимый тип, 32/64
    var i int = 10

    // оператор смещения влево — перемещает бит влево на ко-во позиций, заданное в правом операнде
    var bigInt uint64 = 1<<64-1     // 18446744073709551615


    GOLANG                                                   POSTGRES
    uint8  : 0 to 255 
    uint16 : 0 to 65535 
    uint32 : 0 to 4294967295 
    uint64 : 0 to 18446744073709551615 
    int8   : -128 to 127 
    int16  : -32768 to 32767                                 smallserial (2 байта): 1..32767,   smallint=int2 (2 байта): -32768..32767                                    
    int32  : -2147483648 to 2147483647                       serial (4 байта, автоинкр.): 1..2147483647,    integer=int=int4 (4 байта): -2147483648..2147483647
    int64  : -9223372036854775808 to 9223372036854775807     bigserial (8 байта, автоинкр.): 1..9223372036854775807     bigint=int8 (8 байт) -9223372036854775808..9223372036854775807


    bool, int8/uint8 take 1 byte
    int16, uint16 - 2 bytes
    int32, uint32, float32 - 4 bytes
    int64, uint64, float64, pointer - 8 bytes
    string - 16 bytes (2 alignments of 8 bytes)
    any slice takes 24 bytes (3 alignments of 8 bytes). So []bool, [][][]string are the same (do not forget to reread the citation I added in the beginning)
    array of length n takes n * type it takes of bytes.


    // float32, float64
    var pi float32 = 3.14
    var e = 2.423

    // bool
    var b bool      // false - по умолчанию
    
    // complex64, complex128
    var c complex128 = 1.1 + 7.12i

    // пустая строка по умолчанию
    var str string

    // со спец. символами
    var hello string = "Hi, world \n\t"

    // без спец. символов
    var hello string = `Hi, world \n\t`

    // UTF-8 поддерживается из коробки, можно писать китайские иероглифы
    hi := '钱'

    // одинарные кавычки используются для символов байт (байт - алиас для uint8)
    var rawBinary byte = '\x27'

    // rune (uint32) для utf-8 символов
    var someRune rune = '钱'

    // конкатенация строк (СТРОКИ НЕИЗМЕНЯЕМЫ)
    helloWorld := "Привет, мир"
    andGoodMorning := helloWorld + " и доброе утро"

    // длина строки:
    byteLen := len(andGoodMorning)                      // 45 байт
    // если строка содержит символы UTF-8, то один символ может занимать более одного байта. Тогда для подсчета количества символов:
    symbols := utf8.RuneCountInString(andGoodMorning)   // 25 символов

    // Константы
    const pi = 3.14
    
    const (
        hello = "привет"
        e = 2.7
    )
    
    const (
        zero = iota         // iota - автоинкремент для констант
        _                   // пустая константа 2, пропуск iota
        three               // 3
    )

    const (
        _   = iota                              // пропускаем первое значение
        KB uint64 = 1 << (10 * iota)            // 1024
        MB                                      // 1048576
    )

    const (
        a = iota                // 0
        b = iota * 2            // 2
        c                       // 4
        d                       // 6
    )

    // iota - Счетчик, начинающийся с нуля, Увеличивается на 1 после каждой строки, Используется только с постоянным
    
    const (
        // нетипизированная константа
        year = 2017
        // типизированная константа
        yearTyped int = 2017
    )

    func main(){
        var month int32 = 13
        fmt.Println(month + year)       // ok
        fmt.Println(month + year)       // разные типы - int32 и int - ошибка
    }


    // Определение собственного типа
    type UserID int
    
    func main(){
        idx := 1
        var uid UserID = 42
        
        uid = idx   // Ошибка!! - cannot use idx (type int) as type UserID in assignment
        
        myID := UserID(idx)     // Приведение типов
        
        // разные типы не совместимы idx - int, 
    }

    // Указатели - тип данных
    d := new(int)       // *d == 0 - заполнит нулем

            // FAQ task21 WB-L1:
            /*
                // определяем сущности: кардридер, карта памяти и компьютер
                MyCardReader := CardReader{}
                // определяем объем карты в "конструкторе"
                MyMemoryCard := NewMemoryCard(64)
                MyComputer := Computer{}

                // подключаем к компьютеру кардридер через USB
                MyComputer.ConnectUSBDevice(MyCardReader)           // тут ошибка, нужен указатель на MyCardReader
                // вставляем карту памяти в кардридер
                MyCardReader.InsertMemoryCard(MyMemoryCard)
                // передаем данные на карту памяти
                MyComputer.SendDataToUSBDevice()

                Важное замечание по багу (исправлен):
                1 шаг: инициализация ПК, карты памяти и кардридера (объекты)
                подключаем к компьютеру кардридер (передаем как значение, а не как указатель !!!)
                    MyComputer.ConnectUSBDevice(MyCardReader)

                2 шаг: подключение карты памяти в кардридер. Здесь передается по ссылке на созданный объект
                    MyCardReader.InsertMemoryCard(&MyMemoryCard)

                3 шаг: отправляем данные с компьютера: тогда при передаче данных на карту памяти произойдет ошибка.
                Это так, потому что на шаге 1 передали копию КардРидера, без подключения карты памяти. Соответственно,
                при записи произойдет паника. Решение: необходимо передавать КардРидер по ссылке, поскольку
                внешнее изменение его состояния отразится в объекте Компьютер
            */

    // указатели: Указатель содержит адрес памяти значения. Тип * T - это указатель на значение T.
    var p *int
    // Оператор & генерирует указатель на свой операнд.
    i := 42
    p = &i
    fmt.Println(*p)     // 42, а само значение p может быть, например, 0xc000018030
    *p = 21             // set i through the pointer - *p привязано по адресу к i,
    fmt.Println(i)      // see the new value of i - соответственно, i равно 21

    s := make([]int, 20) // Выделение единого блока памяти под 20 int-ов.
    s[3] = 7             // Присвоить значение одному из них.

    answer := 42
    fmt.Println(&answer)        // 0xc000001232 - указатель (оператор адреса)

    // adress - Указатель типа *int
    address := &answer
    fmt.Println(*address)       // 42

    fmt.Printf("address это %T\n", address)

    // Звездочка в *int значит, что это тип указателя. В данном случае он может указать на другую переменную типа int.
    canada := "Canada"
    
    var home *string
    fmt.Printf("home is a %T\n", home) // Выводит:  home is a *string
    
    home = &canada
    // Звездочка перед типом обозначает тип указателя,
    // а звездочка перед названием переменной нужна для указания на значение, к которому отсылается указатель.
    fmt.Println(*home) // Выводит: Canada

    Example:
        result = new(int)

    is equivalent to:
        var temp int   // declare an int type variable
        var result *int //  declare a pointer to int
        result = &temp 



// ПЕРЕМЕННЫЕ, СОСТАВНЫЕ ТИПЫ ДАННЫХ
    // Массив - набор данных одного типа. Массивы разной длины имеют разные типы (Например, [1]int и [2]int - разные типы)
    // Инициализация значениями по умолчанию
    var a [3]int    // [0,0,0]
    fmt.Printf("a short %v\n", a)
    fmt.Printf("a full %#v\n", a)

    // В Go Программа может получить доступ к отдельным символам, но не может редактировать саму строку.
    hugeString := "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
	justString := hugeString[0:10]                                    // s = Lorem ipsu
	fmt.Printf("type s is %T, len=%d\n", justString, len(justString)) // type s is string, len=10
	hugeString = "New value of string"                                // изменим исходную строку
	fmt.Println(justString)                                           // s - не изменится, s = "Lorem ipsu"
    
    const size = 2
    var a1[2] string
    var a2[2 * size] bool
    
    var sizeNew := 3
    var a3[sizeNew] string  // ошибка - sizeNew - переменная! А должна быть константа или числовой литерал
    
    // определение размера при объявлении
    a4 := [...]int{1,3,65,7}

    // отличие массива от среза
    a := [...]{1,2,3,4,5,6,7,8}     // массив
    b := [8]{1,2,3,4,5,6,7,8}       // массив
    c := []{1,2,3,4,5,6,7,8}        // срез



    // СРЕЗЫ (СЛАЙСЫ): подмножество массива. Слайс = ссылка! на исходные данные (можно изменять, передавая в функции)
    primes := [6]int{2, 3, 5, 7, 11, 13}    // МАССИВ
    var s []int = primes[1:4]               // СРЕЗ МАССИВА [3 5 7]
    s[0] = 1234


	primes := [6]int{2, 3, 5, 7, 11, 13} // МАССИВ
	var s1 []int = primes[1:4]           // СРЕЗ МАССИВА [3 5 7]
	s1[0] = 1234                         // Изменяем значение среза - изменяем значение массива (!)
	fmt.Println(primes)                  // primes = [2 1234 5 7 11 13]
	primes[2] = 99
	fmt.Println(s1)       // s1 = [1234 99 7] - изменяем значение массива - изменяем значение среза от этого массива
	var s2 []int = s1[:2] //
	fmt.Println(s2)       // s2 =[1234 99] - срез от среза
	s2[0] = 1             // изменяя срез от среза, изменения отразятся на исходном срезе и массиве
	fmt.Println(primes)   // primes = [2 1 99 7 11 13]
	fmt.Println(s1)       // s1 = [1 99 7]
	fmt.Println(s2)       // s2 = [1 99]


    // 50 оттенков (habr): можем менять в функции, передавая слайс как параметр.
    func main() {  
        x := []int{1,2,3}

        func(arr []int) {
            arr[0] = 7
            fmt.Println(arr) // выводит [7 2 3]
        }(x)

        fmt.Println(x) // выводит [7 2 3]
    }

    Срез можно рассматривать как ссылку на массив. В Go размер каждого массива фиксирован, и размер не может быть изменен
    произвольно. Срезы могут обеспечивать требования к динамическому росту и сжатию для массивов, но они не хранят никаких данных.

    /*
    * Это объявление массива
    */
    var a [5] int // Указываем только длину, элемент инициализируется значением по умолчанию 0
    var a [5]int{1,2,3,4,5}
    
    /* 
    * Это объявление среза: объявить массив без длины
    */
    // Метод 1: прямая инициализация
    var s [] int                // Объявить нулевой срез с длиной и емкостью 0
    var s [] int {1,2,3,4,5}    // Создаем массив длиной 5 одновременно
    // Метод 2: Используйте функцию make () для создания среза: var имя переменной = make ([] тип переменной, длина, емкость)
    var s = make([]int, 0, 5)
    // Разделение массива: var имя переменной [] тип переменной = arr [low, high], low и high - это индексы массива.
    var arr = [5]int{1,2,3,4,5}
    var slice []int = arr[1:4] // [2,3,4]

    Длина среза - это количество содержащихся в нем элементов.
    Емкость среза - это число от его первого элемента до конца нижележащего элемента массива.
    Длина и емкость среза s могут быть выражены какlen(s) с участием cap(s) Чтобы получить это.

    s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} // [0 1 2 3 4 5 6 7 8 9] len=10,cap=10
    s1 := s[0:5] // [0 1 2 3 4] len=5,cap=10
    s2 := s[5:] // [5 6 7 8 9] len=5,cap=5
    
    func main() {
        arr := [5]int{1,2,3,4,5} // [1 2 3 4 5]
        fmt.Println(arr)        // [1 2 3 4 5]
        
        s1 := arr[0:3] // [1 2 3]
        printSlice(s1)          // len=3 cap=5 0xc000082030 [1 2 3]
        s1 = append(s1, 6)
        printSlice(s1)          // len=4 cap=5 0xc000082030 [1 2 3 6]
        fmt.Println(arr)        // !! [1 2 3 6 5] Можно видеть, что емкость и адрес указателя слайса не изменились после добавления элемента, но базовый массив изменился, и 4, соответствующее нижнему индексу 3, стало 6
    }
    
    func printSlice(s []int) {
        fmt.Printf("len=%d cap=%d %p %v\n", len(s), cap(s), s, s)
    }
    
    // Срез не хранит никаких данных, он просто описывает раздел базового массива.
    // Другие срезы, которые используют тот же базовый массив, увидят эти изменения.
    // Изменение элементов среза изменяет соответствующие элементы его базового массива!!!
    fmt.Println(primes)                 // 2, 1234, 5, 7, 11, 13 - замена элемента в базовом массиве

    // Создание пользовательского типа
    type MySlice []int

    func (sl *MySlice) Add(val int) {
        *sl = append(*sl, val)
    }
    
    func (sl *MySlice) Count() int {
        return len(*sl)
    }

    // Преобразование обычного слайса к типу MySlice
    s1 := MySlice([]int{1, 2})
    s1.Add(3)


    s1 := []int{1,2,3,4,5,6}
    // цикл по слайсу - вариант 1 (не удобный)
    idx := 0
    for idx < len(s1) {
        fmt.Println(idx, s1[idx])
        idx++
    }

    // цикл по слайсу - вариант 2 (цикл с инициализацией и условием - объявляем индекс, условие и автоинкремент)
    for i:=0; i<len(s1); i++ {
        fmt.Println(s1[i])
    }

    // цикл по слайсу c range - вариант 3.1
    for idx := range(s1) {
        fmt.Println(s1[idx])
    }

    // цикл по слайсу c range - вариант 3.2
    for idx, val := range(s1) {
        fmt.Println(val, idx)
    }

    var a [10]int
    // срезы, эквивалентные a:
    a[0:10]
    a[:10]
    a[0:]
    a[:]

    a = a[:4]       // len 4, cap 10 - срез 
    len(a)      // 10  Длина среза - это количество содержащихся в нем элементов. 
    cap(a)      // 10 Емкость среза - это количество элементов в базовом массиве, считая от первого элемента в срезе.

    buf := []int{1,2,3,4,5}
    newBuf := buf[:]
    
    // при добавлении в newBuf еще одного элемента СЛАЙС ДОЛЖЕН РАСШИРИТЬСЯ ВДВОЕ (capacity - удвоится)
    newBuf = append(newBuf, 6)      // len(newBuf) == 6, cap(newBuf) == 10 (5*2=10)
    
    // тогда создастся другая область памяти и туда скопируется срез newBuf (БУДЕТ ССЫЛАТЬСЯ НА ДРУГУЮ ОБЛАСТЬ ПАМЯТИ)
    // ТАКИМ ОБРАЗОМ, ПРИ ИЗМЕНЕНИИ newBuf:
    newBuf[0] = 1000    // !!!ИЗМЕНЕНИЯ В БАЗОВОМ МАССИВЕ buf НЕ ПРОИЗОЙДУТ: buf == [1,2,3,4,5], newBuf = [1000,2,3,4,5,6]
    
    // добавление другого слайса
    otherBuf := make([]int, 3)      // Функция make выделяет обнуленный массив и возвращает slice, который ссылается на этот массив.
    buf = append(buf, otherBuf...)
    
    // Копирование
    buf := []int{1, 2, 3, 4, 5, 6}
    var emptyBuf []int              // len 0, cap 0
    
    // НЕПРАВИЛЬНОЕ КОПИРОВАНИЕ
    copied := copy(emptyBuf, buf)   // при копированиии в слайс длины 0 - ничего не скопируется
    fmt.Println(copied, emptyBuf)   // 0 []
    
    // ПРАВИЛЬНОЕ КОПИРОВАНИЕ
    newBuf := make([]int, len(buf))
    copied1 := copy(newBuf, buf)
    fmt.Println(copied1, newBuf)    // 6 [1 2 3 4 5 6]

    // можно копировать в часть существующего слайса
    ints = []int{1,2,3,4}
    copy(ints[1:3], []int{5,6})     // ints = [1,5,6,4]

    !! Нулевое значение среза равно nil
    var s []int
    fmt.Println(s, len(s), cap(s))      // [] 0 0 
    if s == nil {
        fmt.Println("nil!")             // напечатает nil
    }

    // Создание матрицы:
    package main

    import "fmt"

    func main() {  
        x := 2
        y := 4

        table := make([][]int,x)
        for i:= range table {
            table[i] = make([]int,y)
        }
        fmt.Println(table)              // [[0 0 0 0] [0 0 0 0]]
    }



    // MAP (КАРТЫ) - хеш-таблица, отображение, ассоциативный массив. Map позволяет по ключу быстро получить значение
    // В качестве ключа может выступать любая сравниваемая структура данных.
    // Ключи в Мапе лежат В РЭНДОМНОМ ПОРЯДКЕ
    // Если ключа в Мапе нет - вернет значение по умолчанию (например, для map[string]int вернет int)

    (!) Типы карт (map) являются ссылочными типами, такими как указатели или срезы (slice), и поэтому значение m выше равно nil; 
    оно не указывает на инициализированную карту
    Это значит, можно определять функции, которые возвращают не *map[T]T, а map[T]T

    func createSet(arr []int) map[int]bool {
        set := make(map[int]bool)
        for _, val := range arr {
            set[val] = true
        }
        return set
    }


    // Инициализация при создании
    var user map[string]string = map[string]string{
        "name": "Vasiliy",
        "lastName": "Romanov",
    }

    // 50 оттенков (habr): Важно инициалиировать карту:
    var m map[string]int
    m["one"] = 1                // !!! ошибка runtime panic

    Нулевая карта (nil map) ведет себя как пустая карта при чтении, но попытки записи в нулевую карту вызовут панику во время выполнения
    (runtime panic). Чтобы инициализировать карту, используйте встроенную функцию make
    // сразу с нужной емкостью
    profile := make(map[string]string, 10)

    // 50 оттенков (habr): Ёмкость хеш-таблиц: Можно устанавливать ёмкость при создании хеш-таблиц, но нельзя применять к ним функцию cap()
    func main() {  
        m := make(map[string]int, 99)        // в отличие от make(слайс), make(map) может содержать только один параметр (длины и емкости нет, есть емкость) 
        fmt.Println(cap(m))                  // ошибка
        fmt.Println(len(m))                  // НО len(m) - не ошибка
    }

    // Удаление по ключу из карты
    delete(map, "key")

    profile := map[int]string{1:"Test1", 2:"Test2"}
    // Итерации по карте:
    // только по ключам
    for key := range profile {
        fmt.Println(key)
    }

    // или по ключам и по значению
    for key, val := range profile {
        fmt.Println(key, val)
    }

    // или так: 
    for _, val := range profile {
        fmt.Println(val)
    }

    // проверка на существование ключа:
    name, isNameExist := user["middleName"]     // isNameExist - bool

    /*Пример кода динамического списка (карты)*/ https://golang-blog.blogspot.com/2020/01/map-golang.html
    type Node struct {
        Next  *Node
        Value interface{}
    }
    var first *Node

    visited := make(map[*Node]bool)
    for n := first; n != nil; n = n.Next {
        if visited[n] {
            fmt.Println("cycle detected")
            break
        }
        visited[n] = true
        fmt.Println(n.Value)
    }



// УПРАВЛЯЮЩИЕ КОНСТРУКЦИИ
    // условие с блоком инициализации
    if a := foo(); a > 10 {
        b := a / 2
    }

    // множественные if else:
    if cond == 1 {
        fmt.Println("cond is 1")
    } else if cond == 2{
        fmt.Println("cond is 2")
    }

    // SWITCH CASE. Для перехода к следующему кейсу (без проверки условия в case) можно использовать ключевое слово fallthrough.
    strVal := "name"
    switch strVal {
        case "name":
            fallthrough                     //!!! необходимо, чтобы провалиться в следующее условие
        case "test", "lastName":
            // some code
        case foo(strVal) > 1 || bar (strVal) < 10:  // несколько условий
            // some code
        default:
            // some code
    }
    
    // пример (выведет 1 2):
        switch 1 {
            case 1:
                fmt.Println(1)
            case 2:
                fmt.Println(2)
        }

    // Пример (выведет: 1 2) 
        switch 1 {
            case 1:
                fmt.Println(1)
                fallthrough         (!)  при использовании fallthrough ставить в конце тела case
            case 2:
                fmt.Println(2)
        }


    // SWITCH без выражения (эквивалентно switch true) - Эту форму можно использовать вместо многострочных операторов if/else для сокращения кода.
    switch {
    case now.Hour() < 12:
        fmt.Println("AM")

    default:
        fmt.Println("PM")
    }

    // МЕТКА (см. команду break Loop - завершить внешний цикл, а не SWITCH)
        func main() {
            fmt.Println(1)
            goto End
            fmt.Println(2)
        End:
            fmt.Println(3)
        }
        Вывод:
            // 1
            // 3


    // пример:
    Loop:
        for key, val := range mapVal {
            switch {
                case key == "lastName":
                    break
                    println("dont print this")
                case key == "firstName" && val == "Vasiliy":
                    println("switch - break loop there")
                    break Loop                  // прерываем и switch и for (!)
            }
        }

        Область видимости метки - это тело функции, в которой она объявлена, и исключает тело любой вложенной функции.
        ЗАПРЕЩЕНО:
                func() {
                    fmt.Println(“Nested function”)
                    goto End
                }()
            End:

        ! метки не конфликтуют с переменными идентификаторами:
        МОЖНО:
            x := 1
                goto x
            x:
                fmt.Println(x)


    // ЦИКЛЫ
	
        // цикл, инвертирующий слайс без использования вспомогательного слайса
		for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {
			words[i], words[j] = words[j], words[i]
		}
	

    // цикл с условием и блоком инициализации
    sum := 0
    for i := 0; i < 10; i++ {
        if i == 1 {
            continue
        }
        sum += i
    }
    fmt.Println(sum)    

    // цикл без условия 
    for {
        fmt.Println("1")
        break
    }

    // цикл без условия 2
    isRun := true
    for isRun {
        fmt.Println("1")
        isRun = false
    }
    
    // Операторы init и post необязательны
    for ; sum < 1000; {
        sum += sum
    }
    fmt.Println(sum)    // 1024

    // Цикл while определяется через for:
    sum := 1
    for sum < 1000 {
        sum += sum
    }
    fmt.Println(sum)    // 1024


    // бесконечный цикл
    for {
        }

    // Циклы по строке (СТРОКА = СЛАЙС БАЙТов)
    s := "Hello 钱 мир!"
    for pos, char := range s {
        fmt.Printf("%#U at pos %d\n", char, pos)
    }

    // вывод:
    U+0048 'H' at pos 0
    U+0065 'e' at pos 1
    U+006C 'l' at pos 2
    U+006C 'l' at pos 3
    U+006F 'o' at pos 4
    U+0020 ' ' at pos 5         // pos4-pos5 - 1 символ - 1 байт (позиция)
    U+94B1 '钱' at pos 6        // pos6-pos9 - 1 иероглиф - 3 позиции
    U+0020 ' ' at pos 9         
    U+043C 'м' at pos 10        // pos10-pos12 - 1 русская буква - 2 позиции 
    U+0438 'и' at pos 12
    U+0440 'р' at pos 14
    U+0021 '!' at pos 16

    // область видимости
    // Как и for, оператор if может начинаться с короткого оператора, который выполняется перед условием.
    // Переменные, объявленные оператором, находятся в области видимости только до конца if.
    func pow(x, n, lim float64) float64 {
        if v := math.Pow(x, n); v < lim {
            return v
        }
        return lim
    }

    // оператор switch. Выражение os := "test"; вычисляется внутри switch
    switch os := "test"; os {
        case "test":
            fmt.Println("1")
        case "linux":
            fmt.Println("Linux.")
        default:
            fmt.Printf("default")
    }

    // switch без условия - это то же самое, что и переключатель true
    t := time.Now()
    switch {
        case t.Hour() < 12:
            fmt.Println("Good morning!")
        case t.Hour() < 17:
            fmt.Println("Good afternoon.")
        default:
            fmt.Println("Good evening.")
    }   

    // BREAK
    Обычно break без дополнительной метки завершает самый внутренний for, switch или select оператор
    break Оператор не может выходить за границы функции: 
    
    
    ОШИБКА: break is not in a loop
    
        func f() {
            break
        }
        
        func main() {
            for i := 0; i < 10; i++ {
                f()
            }
        }

    ОШИБКА: invalid break label FirstLoop, поскольку метка связана с отсутствием включения for цикла 
        FirstLoop:
            for i := 0; i < 10; i++ {
            }
            for i := 0; i < 10; i++ {
                break FirstLoop
            }

    ПРАВИЛЬНО:
        OuterLoop:
            for i := 0; i < 10; i++ {
                for j := 0; j < 10; j++ {
                    fmt.Printf(“i=%v, j=%v\n”, i, j)
                    break OuterLoop
                }
            }   

        // выведет i=0, j=0

    ПРАВИЛЬНО:
    SwitchStatement:
        switch 1 {
            case 1:
                fmt.Println(1)
                for i := 0; i < 10; i++ {
                    break SwitchStatement
                }
                fmt.Println(2)
        }
        fmt.Println(3)

        // выведет 1 3


    // CONTINUE
        Он работает аналогично оператору break, но вместо остановки начинает следующую итерацию и может использоваться только для циклов:
            OuterLoop:
                for i := 0; i < 3; i++ {
                    for j := 0; j < 3; j++ {
                        fmt.Printf(“i=%v, j=%v\n”, i, j)
                        continue OuterLoop
                    }
                }> ./bin/sandbox
            i=0, j=0
            i=1, j=0
            i=2, j=0

    // GOTO 
        goto может перемещать элемент управления только в пределах одной и той же функции.  
        Поскольку можно перенести элемент управления вперед, есть два дополнительных правила:
            1) любое объявление переменной не может быть пропущено, поэтому переменная попадает в область видимости:

            ОШИБКА: goto Done jumps over declaration of v at…
                goto Done
                    v := 0
                Done:
                    fmt.Println(v)
            
            2) goto не может перейти в другой блок:

            ОШИБКА: goto Block jumps into block starting at …
                goto Block
                {
                Block:
                    v := 0
                    fmt.Println(v)
                }

        // еще пример
        func main() {
            i := 0
            Start:
                fmt.Println(i)
                if i > 2 {
                    goto End
                } else {
                    i += 1
                    goto Start
                }
            End:            (!) пустой оператор, он разрешен
        }



// ФУНКЦИИ - основной инструмент для декомпозиции вашей программы на более простые блоки
    // 1 обычное объявление. 
    func foo(y string) int {
        return 1
    }

    // 2 Много параметров. Много результатов
    func swap(x, y string) (string, string) {
        // Функция может возвращать любое количество результатов.
        return y, x
    }

    // 3 Именованный результат
                        // возвращаемые значения. Несколько возвращаемых результатов
                        // ВСЕ !!ИМЕНОВАННЫЕ!! РЕЗУЛЬТАТЫ СРАЗУ ИНИЦИАЛИЗИРУЮТСЯ ЗНАЧЕНИЯМИ ПО УМОЛЧАНИЮ (см. пример 4 ниже)
    func split(sum int) (x, y int) {
        x = sum * 4 / 9
        y = sum - x
        
        // возврат без указания переменных - вернуться переменные x, y - "nacked return" - что возвращать - указано после параметров функции (!)
        return
    }

    // 4 Вариативная функция (ВНИМАНИЕ НА возвращаемое значение result int - т.к. оно инициализировано по умолчанию нулем, 
    // то result удобно использовать в качестве сумматора без явной инициализации нулем)
    func sum(in ...int) (result int) {
        fmt.Printf("in = %#v \n", in)
        for _, val := range in {
            result += val           // result не инициализировано нулем
        }
        return
    }

    Для объявления вариативной функции используется многоточие (...) с последним параметром
    func terraform(prefix string, worlds ...string) []string {
        newWorlds := make([]string, len(worlds)) // Создает новый срез вместо прямого изменения worlds
    
        for i := range worlds {
            newWorlds[i] = prefix + " " + worlds[i]
        }
        return newWorlds
    }

    Параметр worlds является срезом строк, что содержит ноль или более аргументов, передаваемых в terraform:
    twoWorlds := terraform("Нью", "Венера", "Марс")
    fmt.Println(twoWorlds) // Выводит: [Нью Венера Нью Марс]

    Для передачи среза вместо множества аргументов, расширьте срез через многоточие:!!!!
    planets := []string{"Венера", "Марс", "Юпитер"}
    newPlanets := terraform("Нью", planets...) //!!!!!!!! РАСПАКОВКА СЛАЙСА В ОДИНОЧНЫЕ аргументы
    fmt.Println(newPlanets) // Выводит: [Нью Венера Нью Марс Нью Юпитер]



// Троеточие ...
    Три случая использования многоточия (...) в Go:
    1 Для подсчета компилятором Go количества элементов композитного литера для массива;
        a := [...]int{1,2,3,4,5,6,7,8}
    
    2 Заставить последний параметр вариативной функции зафиксировать ноль или большее число аргументов в качестве среза;
        func sum(worlds ...int) { // some code }        // передача слайса как вариативного параметра (распаковка слайса)

    3 Расширить элементы среза в аргументы, передаваемые функции.
        otherBuf := make([]int, 3)
        buf = append(buf, otherBuf...)          // добавление другого слайса

        sum(a)      // ошибка - функция принимает 0 или более int, а передали []int
        sum(a...)   // верно



// ФУНКЦИИ КАК ОБЪЕКТ ПЕРВОГО КЛАССА:
    1) можем присваивать функцию в какую-то переменную
    2) принимать функцию как аргумент в другую функцию
    3) возвращать функцию как результат работы другой функции
    4) функция может быть полем некторой структуры

    // обычная функция 
    func doNothing() {
        fmt.Print("---")
    }

    func main() {
        // анонимная функция, которая объявляется и вызывается
        func (in string){
            fmt.Print(in)
        }("test")

        // присваивание анонимной функции в некоторую переменную
        printer := func(in string) {
            fmt.Print(in)
        }
        printer("функция - как переменная")

        // опредеяем тип функции
        type strFuncType func(string)

        // функция принимает параметр callback - который является функцией типа strFuncType
        // колбеки - нужны, например, когда необходимо выполнить функцию по завершению какой-то работы
        // или в зависимости от разных условий имеют разную логику
        worker := func(callback strFuncType) {
            callback("функция printer - как колбек") // внутри этой функции, вызываем ту функцию, которую передали в параметрах
        }
        worker(printer)

        // ЗАМЫКАНИЯ - функции, которые обращаются к переменным, которые были созданы вне ее объявления
        prefixer := func (prefix string) strFuncType {
            return func(in string) {    // возвращаем замыкание. 
                fmt.Printf("[%s] %s\n", prefix, in)
            }
        }
        succesLogger := prefixer("SUCCESS")
        succesLogger("expected behaviour")

        Один из способов использования замыкания — функция, возвращающая другую функцию, 
        которая при вызове генерирует некую последовательность чисел. Например, следующим образом мы могли бы сгенерировать все четные числа:
        http://golang-book.ru/chapter-07-functions.html

        makeEvenGenerator возвращает функцию, которая генерирует чётные числа. Каждый раз, когда она вызывается, к переменной i
        добавляется 2, но в отличие от обычных локальных переменных её значение (!) сохраняется между вызовами.

        func makeEvenGenerator() func() uint {
            i := uint(0)
            return func() (ret uint) {
                ret = i
                i += 2
                return
            }
        }
        func main() {
            nextEven := makeEvenGenerator()
            fmt.Println(nextEven()) // 0
            fmt.Println(nextEven()) // 2
            fmt.Println(nextEven()) // 4
        }
    }




// ОТЛОЖЕННОЕ ВЫПОЛНЕНИЕ И ОБРАБОТКА ПАНИКИ
    // Оператор defer откладывает выполнение функции до возврата из окружающей функции.
    func main() {
        defer fmt.Println("world")
        fmt.Println("hello")
    }

    // вывод "hello\n MY \nworld"
    func main() {
        defer fmt.Println("world")
        defer fmt.Println(" MY ")         // несколько defer выполняется в порядке, обратном их объявления
        fmt.Println("hello")
    }


    // порядок вызовов функций в объявлении defer (v.1)
    func getSomeVars() string {
        fmt.Println("IN get some vars func")
        return "return from getSomeVars"
    }

    // !!! Если defer объявлен после return, он не выполнится (программа ниже ничего не выведет)
    func main() {
        if true {
            return
        }
        defer fmt.Println("world")
        fmt.Println("hello")
    }


    func main() {
        defer fmt.Println("defer 1")
        defer fmt.Println(getSomeVars())    // !!! аргументы вложенных функций вычисляются при объявлении блока defer!!!
                                            // (не когда функция будет вызвана, а при объявлении)
        fmt.Println("Hello, playground")
    }
    
    // вывод:
    IN get some vars func                   // выполнение функции fmt.Println(), которая вычисляет свой аргумент
    Hello, playground                       // выполнение некоторой полезной работы внутри main()
    return from getSomeVars                 // нижний defer - вывод результата функции getSomeVars
    defer 1                                 // верхний defer


    // порядок вызовов функций в объявлении defer (v.2)
    func main() {
        defer fmt.Println("defer 1")
        defer func() {
            fmt.Println(getSomeVars())
        }()
        fmt.Println("Hello, playground")
    }

    // вывод:   
    Hello, playground                       // выполнение некоторой полезной работы внутри main()
    IN get some vars func                   // нижний defer - работа функции getSomeVars
    return from getSomeVars                 // нижний defer - вывод результата функции getSomeVars
    defer 1                                 // верхний defer


    // panic() - встроенная функция, останавливающая выполнение программы
    // recover() - встроенная функция, возвращающая ошибку, которую бросила паника

    func deferTest() {
        defer func(){
            if err := recover(); err != nil {
                fmt.Println("panic happend:", err)
            }
        }()

        fmt.Println("some useful work")
        panic("something bad happend")
        return
    }

    func main() {
        deferTest()
        return
    }

    вывод:
    some useful work
    panic happend: something bad happend

    // плохая практика: panic внутри блока восстановления
    func deferTest() {
        defer func(){
            if err := recover(); err != nil {
                fmt.Println("panic happend 1:", err)
            }
        }()
        
        defer func(){
            if err := recover(); err != nil {
                fmt.Println("panic happend 2:", err)
                panic("second panic")
            }
        }()

        fmt.Println("some useful work")
        panic("something bad happend")
        return
    }
    вывод:
    some useful work
    panic happend 2: something bad happend
    panic happend 1: second panic



// СТРУКТУРЫ И их МЕТОДЫ. Структуры - сущности, объединенные для логического удобства.
    // Полями структуры может быть любой тип в go, даже функция (как объект первого класса), либо другая структура 
    
    type Vertex struct {
        X int
        Y int
    }

    // объявление экземпляра стурктуры Vertex{1, 2}
    func main() {
        // полное объявление структуры:
        var ver Vertex = Vertex{
            X: 1,                       // можем опустить некоторые поля, тогда они примут значение по умолчанию
        }

        // короткое объявление структуры (обязательно указать все параметры, т.к. они без явного объявления):
        v := Vertex{1, 2}
        ver1 := Vertex{1}               // Ошибка: too few values in Vertex{...}
        ver2 := Vertex{X:1}             // так можно
        
        p := &v                         // p - указатель на экземпляр структуры
        p.X = 19                        // что эквивалентно (*p).X = 19
        fmt.Println(v)                  // {19 2}
    }


    // определяем структруры
    var (
        v1 = Vertex{1, 2}  // has type Vertex   // {1 2} 
        v2 = Vertex{X: 1}  // Y:0 is implicit   // {1 0} - X - определили, Y - нет
        v3 = Vertex{}      // X:0 and Y:0       // {0 0} - создание "экземпляра" структуры, но с дефолтными значениями полей
        p  = &Vertex{1, 2} // has type *Vertex  // &{1 2} - тип *Vertex
    )

    // встраивание структур
    type Person struct {
        Id int
        Name string
        Adress string
    }

    type Account struct {
        Id int
        Name string
        Cleaner func(string) string
        Owner Person
        Person          // встраиваем структуру в структуру. Теперь поля Person являются частью структуры Account
                        // при обращении к полю Name (которе есть и в Account и в Person) - обратимся к полю Name верхнего уровня (Account.Name)
    }

    func main() {
        var acc Account = Account {
            Id: 1,
            Name: "Vasiliy",
            Person: Person {
                Name: "Baсилий",
                Adress: "Москва",
            }, 
        }

        fmt.Println(acc.Name)               // "Vasiliy", а не "Василий"
        fmt.Println(acc.Person.Name)        // "Василий"
    }


    // Методы структур. Метод - функция, которая привязана к определенному типу данных.
    type Person struct {
        Id int
        Name string
    }

    // в метод передается копия типа. Метод не изменит оригинальной структуры, для которой вызван метод
    func (p Person) UpdateName(name string){
        p.Name = name
    }

    //  в метод передается адрес на тип. Метод изменит оригинальной структуры, для которой вызван метод
    func (p *Person) SetName(name string){
        p.Name = name
    }

    func main() {
        pers: = Person{1, "Vasiliy"}
        pers.SetName("Vasiliy Rom")     // Компилятор автоматически преобразует к (&pers).SetName("Vasiliy Rom), т.к. в метод передается указатель
        pers := &Person{}               // эквивалентно pers := new(Vertex) 
    }


    // Добавим структуру Account
    type Account struct {
        Id int
        Name string
	    Person                  // имплементируем структуру Person в Account
    }

    // создадим метод Account с таким же именем, как в Person
    func (p *Account ) SetName(name string){
        p.Name = name
    }

    func main() {                             
        acc := Account{
            Id: 1,
            Name: "Василий",
            Person: Person {
                Id: 2,
                Name: "Vasily",
            },
        }
        acc.SetName("NEW NAME")
        fmt.Println(acc)                    // !!! {1 NEW NAME {2 Vasily}}

        acc.Person.SetName("Вася")
        fmt.Println(acc)                    // !!! {1 NEW NAME {2 Вася}}
    }


    // Пример: как передать ссылку на структуру B другой структуре A, так, чтобы при изменении структуры B, менялась структура A внутри B
            package main

            import (
                "fmt"
            )

            type A struct {
                bb *B 
            }

            func (a *A) set(bb *B) {
                a.bb = bb
                fmt.Println(bb.b)
            }

            func (a *A) get() {
                fmt.Println("a.bb.b =", a.bb.b)
            }


            type B struct {
                b int
            }

            func (b *B) changeB(){
                b.b = 99
            }

            func (b *B) get() {
                fmt.Println("B.b=", b.b)
            }


            func main() {
                bb := B{b:100}
                aa := A{}
                aa.set(&bb)
                
                bb.changeB()
                bb.get()
                aa.get()
                
                fmt.Println("Hello, playground")
            }

            // вывод
            100
            B.b= 99
            a.bb.b = 99
            Hello, playground



// ПАКЕТЫ И ОБЛАСТЬ ВИДИМОСТИ
    Go работает с так называемой системной переменной GOPATH.
    Это адрес директории, внутри которой
    должны находиться некоторые специализированные директории.
    Первая из них — это папка bin, в нее кладутся собранные бинарники, то есть либо .exe, либо l-файлы.
    В pkg кладутся временные объектные файлы, а src содержит исходники вашей программы. 

    Если переменная, структура, поле структуры,
    константа, функция начинается с заглавной буквы,
    это значит, что эта сущность экспортируемая,
    то есть она доступна для обращения из других пакетов.
    Если же она начинается со строчной, это значит,
    что эта сущность принадлежит только этому пакету. 

    Пакет состоит не из файла, а из директорий.
    То есть одна директория, person, это и есть пакет.
    Следовательно, все, что я объявлю в файле person.go,
    будет доступно и из файла func.go, потому что они составляют один пакет. 

    C:\Users\User\Go
    |----bin
    |----pkg
    |----src
        |----coursera
        |       |----visibility
        |       |       |----person
        |       |       |        |----person.go
        |       |       |        |----func.go
        |       |       |----main


    // файл person.go:
        package person

        var (
            Public = 1
            private = 0
        )

        type Person struct {
            Id      int
            Name    string          // можем обратиться из другого пакета
            secret  string          // приватное поле, можем обращаться только из функций этого пакета (включая методы этой структуры)
        }

    // import распространяется на файл, в котором он определен, а не на весь пакет (состящий из нескольких go-файлов)



// ИНТЕРФЕЙСЫ
    Интерфейс - это описание того, что может и должен уметь делать объект класса, который реализует этот интерфейс.
    Смысл интерфейса - в унификации работы с разнотипными объектами.
    В общем интерфейсы нужны, чтобы связать группу не связанных объектов, которые обязаны реализовать поведение того интерфейса,
    чтобы можно было взаимодействовать с ними через этот общий интерфейс.
    Главное отличие класса от интерфейса — в том, что класс состоит из интерфейса и реализации.

    В Go полиморфизм организован через интерфейсы (возможность функции принимать в себя аргументы различных типов)
    В Go, когда вы создаете структуру с методами, она не знает, какому интерфейсу она соответствует, то есть типизация неявная
    То есть вы передаете в метод, который принимает определенный интерфейс.
    А уже интерфейс описывает, что если мы хотим сюда попасть, там должны быть определенные методы.
    То есть вы можете передать в функцию ту структуру, даже если она не знает, что она реализует этот интерфейс

    
    https://thecode.media/oop-abstract/
    Абстракция — это когда мы сосредотачиваемся только на существенных для задачи деталях и игнорируем всё остальное. 
    В ООП абстракция означает, что для каждого объекта мы задаём минимальное количество методов, полей и описаний, которые
    позволят нам решить задачу. Чем меньше характеристик, тем лучше абстракция, но ключевые характеристики убирать нельзя.
    Чтобы работать с абстракциями, используют интерфейсы.

    // Интерфейс - как тип данных
    var a interface{} = "hello"     // анонимный интерфейс - а анонимная структура: var c struct{}
    a = 42
    a = 4.2
    и это будет работать!!! поскольку этот интерфейс может быть любым типом, реализующим 0 методов!!!!!!

    Приведение типов (!!! ТАКИМ СПОСОБОМ МОЖНО ПРИВОДИТЬ ТИПЫ ТОЛЬКО В ИНТЕРФЕЙСАХ):
    a := "hello"
    f, ok := a.(float32)
    fmt.Println(f, ok)  //0, false

    Интерфейс под капотом - это кортеж 
    type structHere struct {
        N1, N2 int
    }
    ...
    type InterfaceHere interface {
        Sum()   int
    }

    var os *structHere
    var i InterfaceHere
    i = os
    ({3,1}, *main.structName)

    где {3,1} - значение в структуре structHere
    *main.structName - тип интерфейса (в пакете main)

    // SWITCH type для определения, какой тип данных в интерефесе:
    var a interface{} = "hello"
    switch a.(type) {
        case int:
            fmt.Println("int")
        case string:
            fmt.Println("string")
        default:
            fmt.Printf("unknown type %T\n", a)
    }

    С помощью type мы можем переключиться на тип значения интерфейса.
    var data interface{} 
        data = 112523652346.23463246345
        switch mytype:= data.(type) { 
        case string: 
            fmt.Println("string")
        case bool: 
            fmt.Println("boolean") 
        default: 
            fmt.Printf("%T", mytype) 
        } 
    }

    // Пример 1.
    type Payer interface {
        Pay(int) error
    }

    type Wallet struct {
        Cash int
    }

    func (w *Wallet) Pay(amount int) error {
        if w.Cash < amount {
            return fmt.Errorf("Не хватает денег в кошельке")
        }
        w.Cash -= amount
        return nil
    }
    
    // Есть функция Buy, которая принимает в себя интерфейс «плательщик».
    // Она не знает уже, какая структура туда придет.
    // Ей просто важно, чтобы то, что придет в эту функцию,
    // обладало методом Pay. 
    func Buy(p Payer) {
        err := p.Pay(10)
        if err != nil {
            panic(err)
        }
        fmt.Printf("Спасибо за покупку через %T\n\n", p)
    }

    func main() {
        myWallet := &Wallet{Cash: 100}
        Buy(myWallet)                       // Спасибо за покупку через *main.Wallet
    }


    // Пример 2.
    // --------Интерфейс платильщика-----------
    type Payer interface {
        Pay(int) error
    }
    // --------Интерфейс платильщика-----------

    // --------Функция "купить"-----------
    func Buy(p Payer) {
        err := p.Pay(10)
        if err != nil {
            panic(err)
        }
        fmt.Printf("Спасибо за покупку через %T\n\n", p)
    }
    // --------Функция "купить"-----------

    // --------Кошелек-----------
    type Wallet struct {
        Cash int
    }

    func (w *Wallet) Pay(amount int) error {
        if w.Cash < amount {
            return fmt.Errorf("Не хватает денег в кошельке")
        }
        w.Cash -= amount
        return nil
    }
    // --------Кошелек-----------

    // --------Карточка-----------
    type Card struct {
        Balance int
        Number string
        CardholderID int
    }

    func (c *Card) Pay(amount int) error {
        if c.Balance < amount {
            return fmt.Errorf("Не хватает денег в кошельке")
        }
        c.Balance -= amount
        return nil
    }
    // --------Карточка-----------

    // --------Apple Pay-----------
    type ApplePay struct {
        Money int
        AppleID string
    }

    func (a *ApplePay) Pay(amount int) error {
        if a.Money < amount {
            return fmt.Errorf("Не хватает денег в кошельке")
        }
        a.Money -= amount
        return nil
    }
    // --------Apple Pay-----------

    func main() {
        var myMoney Payer
        myMoney = &Card{Balance:100, CardholderID: 12342314325, Number: 342323}
        Buy(myMoney)

        myMoney = &ApplePay{Money:9, AppleID: 12363456}
        Buy(myMoney)

        myMoney = &Wallet{Cash:90}
        Buy(myMoney)
    }

    // Но иногда нам бывает нужно
        не просто вызывать какие-то методы интерфейса,
        но и проверить, что в действительности нам пришло

    func Buy(p Payer) {
        switch p.(type) {
            case *Wallet:
                fmt.Println("Оплата наличными?")
            case *Card:
                // необходимо проверить владельца карты. Но из интерфейса нельзя обратиться к полям структуры, 
                // которая "лежит" под этим интерфейсом!!! Ведь у интерфейса нет поля "CardholderID".
                // Попробуем явно преобразовать к типу *Card
                plasticCard, ok := p.(*Card)
                if !ok {
                    fmt.Println("Не удалось преобразовать к типу *Card")
                }

                // Теперь в plasticCard у меня действительно лежит мой тип Card,
                // и я могу обратиться к его полям, это уже не интерфейс. 
                fmt.Println("Вставляйте карту,", plasticCard.CardholderID)
            default:
                fmt.Println("Что-то новое")
        }

        // Покупаем: у интерфейса есть метод Pay()
        err := p.Pay(10)
        if err != nil {
            panic(err)
        }
        fmt.Printf("Спасибо за покупку через %T\n\n", p)
    }

    func main() {
        myWallet = &Wallet{Cash:90}
        Buy(myWallet)

        var myMoney Payer
        myMoney = &Card{Balance:100, CardholderID: 12342314325, Number: 342323}
        Buy(myMoney)

        myMoney = &ApplePay{Money:9, AppleID: 12363456}
        Buy(myMoney)
    }

    // структура может удовлетворять интерфейсу, если:
        1) структура содержит встроенную(!) анонимную структуру (!!!), которая удовлетворяет данному интерфейсу!!!
        2) структура имеет все методы, которые требует данный интерфейс
    

    // Пустой интерфейс — это интерфейс,
    который может принять в себя вообще любую переменную,
    потому что у него нет никаких требований к реализации. 

    функция Printf() стандартной библиотеки не знает ничего про тип,
    который я только что определил.
    На самом деле функция Printf() принимает в себя пустой интерфейс.
    Поэтому мы туда можем передавать абсолютно любые параметры,
    одни за другими, она все из них выведет

    // Пример.
    func Buy(in interface{}) {
        var p Payer
        var ok bool
       
        // я хочу проверить, является ли то, что мне пришло, интерфейсом?
        Если не является, говорю, что нельзя.
        Ну а поскольку оно, если является,
        я уже присвоил переменную p плательщика, то я произвожу оплату. 

        if p, ok = in.(Payer); !ok {
            fmt.Println("%T не является платежным средством")
            return
        }
        
       // Покупаем: у интерфейса есть метод Pay()
        err := p.Pay(10)
        if err != nil {
            panic(err)
        }
        fmt.Printf("Спасибо за покупку через %T\n\n", p)
    }

    Что будет в переменной myVal если не получится преобразовать тип из пустого интерфейса ( ok == false )
    myVal, ok := emptyInterfaceVal.(int)
    Ответ - Значение по-умолчанию, для int-а это 0

    // Композиция интерфейсов
    type Payer interface {
        Pay(int) error
    }
    
    type Ringer interface {
        Ring(string) error
    }

    type NFCPhone interface {
        Payer                   // интерфейс образован композицией двух других
                                // интерфейсов: Плательщик и Звонилка - они встроены
        Ringer                  // а, если необходимо объявить, то используется Ring(string) error
                                // Не обязательно использовать только интерфейсы, вы можете один интерфейс встроить, а другой — объявить. 
    }

     func PayInMetroTurniket(phone NFCPhone) {
        err := phone.Pay(1)
        if err != nil {
            fmt.Printf("Ошибка при оплате %v\n\n", err)
            return
        }
        fmt.Printf("Турникет открыт через %T\n\n", phone)
    }

    func main() {
        myPhone := &Phone{Money: 9}
        // передал NFCPhone, который реализует и функцию Pay, и функцию Ring, звонить, он пройдет
        PayInMetroTurniket(myPhone)
    }


    // Написание программы уникализации (на вход - строки, на выходе - уникальные строки без повторений) 
    cat data.txt | go run main.go   - команда для чтения из внешнего файла
    
    Давайте немножко переделаем нашу программу, для того чтобы она была
    похожа на команду стандартной поставки GNU Coreutils uniq.
    Команда uniq принимает на вход отсортированный набор данных,
    и за счет этого она может сравнить, что если мы уже пришли на
    эту позицию, мы уже видели, это значит,
    что все, что до этого было, оно должно быть меньше. 
    
    package main

    import (
        "bufio",
        "fmt",
        "os"
    )

    // на входе в программу - отсортированные строки
    func main() {
        in := bufio.NewScanner(os.Stdin)
        var prev string
        
        for in.Scan() {
            txt := in.Text()
            if txt == prev {    // текущая и предыдущая строки равны? продолжаем считывать, не добавляя в ответ.
                continue
            }

            if txt < prev {
                panic()
            }

            prev = txt
            fmt.Println(txt)
        }
    }

    // Написание тестов. Файл main.go:
    package main

    import (
        "bufio",
        "fmt",
        "os",
        "io"
    )

    func uniq(reader io.Reader, output io.Output) error {
        in := bufio.NewScanner(reader)
        var prev string
        
        for in.Scan() {
            txt := in.Text()
            if txt == prev {    // текущая и предыдущая строки равны? продолжаем считывать, не добавляя в ответ.
                continue
            }

            if txt < prev {
                return fmt.Errorf("file not sorted")
            }

            prev = txt
            fmt.Fprintln(output, txt)
        }
        return nil
    }

    // на входе в программу - отсортированные строки
    func main() {
        err := uniq(os.Stdin, os.Stdout)
        if err != nil {
            panic(err.Error())
        }
    }

    // Написание тестов. Файл main_test.go:
    package main

    import (
        "string"
        "bytes"
        "testing"
    )

    var testOk = `1
    2
    3
    3
    4
    5`

    var testOk = `1
    2
    3
    4
    5
    `

    var testFail = `1
    2
    1
    `

    func TestOk(t *testing.T) {
        in := bufio.NewReader(strings.NewReader(testOk))
        out := new(bytes.Buffer)

        err := uniq(in, out)
        if err != nil {
            t.Errorf("Test for Ok failed")
        }
        
        result := out.String()
        if result != testOkResult {
            t.Errorf("test for OK Failed - results not match \n %v %v", result, testOkResult)
        }
    }

    // тесты для ошибки
    func TestForError(t *testing.T) {
        in := bufio.NewReader(strings.NewReader(testFail))
        out := new(bytes.Buffer)

        err := uniq(in, out)
        if err == nil {
            t.Errorf("Test for Ok failed - error: %v", err)
        }
    }

    // запуск тестов - go test -v



































// ФОРМАТИРОВАНИЕ СТРОК/ВЫВОДА %%%%%%%%%%%%%%%%%
    Для представления Юникода в Go используется тип rune, который иначе называется int32.
    byte является другим названием типа uint8. Он используется для бинарных данных, хотя byte может 
    использоваться для символа английского алфавита, определенного ASCII, более старого 128-символьного набора Юникод.

    Запоминать все Юникоды нет нужды, в Go есть символьный литерал. Просто поместите символ в одинарные кавычки: 'A'

    Строка форматирования представляет набор спецификаторов. Каждый спецификатор представляет набор символов, которые интерпретируются определенным образом и предваряются знаком процента %. Каждый спецификатор представляет определенный тип данных:

        %t: для вывода значений типа boolean (true или false)
        %b: для вывода целых чисел в двоичной системе
        %c: для вывода символов, представленных числовым кодом
        %d: для вывода целых чисел в десятичной системе
        %o: для вывода целых чисел в восьмеричной системе
        %q: для вывода символов в одинарных кавычках
        %x: для вывода целых чисел в шестнадцатиричной системе, буквенные символы числа имеют нижний регистр a-f
        %X: для вывода целых чисел в шестнадцатиричной системе, буквенные символы числа имеют верхний регистр A-F
        %U: для вывода символов в формате кодов Unicode, например, U+1234
        %e: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78
        %E: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456E+78
        %f: для вывода чисел с плавающей точкой, например, 123.456
        %F: то же самое, что и %f
        %g: для длинных чисел с плаващей точкой используется %e, для других - %f
        %G: для длинных чисел с плаващей точкой используется %E, для других - %F
        %s: для вывода строки
        %p: для вывода значения указателя - адреса в шестнадцатеричном представлении
        %v: Также можно применять универсальный спецификатор %v, который для типа boolean аналогичен %t,
            для целочисленных типов - %d, для чисел с плавающей точкой - %g, для строк - %s.
    %c
    Для отображения символов вместо их числовых значений можно использовать специальный символ %c вместе с Printf:
    fmt.Printf("%c%c%c%c\n", pi, alpha, omega, bang) 
    // Выводит: πάω!

    %x
    Более короткий способ создания презентабельного вывода для грязной строки - использовать %x (шестнадцатеричный)
    формат в fmt.Printf.  
    // bdb23dbc20e28c98

    %q      // https://golang-blog.blogspot.com/2019/09/string-byte-rune-character-golang.html
    Форма %q (в кавычках) будет экранировать любые непечатаемые последовательности байтов в строке, поэтому вывод будет однозначным.
    // "\xbd\xb2=\xbc ⌘"

    Если мы незнакомы или смущены странными значениями в строке, мы можем использовать "плюс" флаг к %q. 
    Этот флаг заставляет выходные данные экранировать не только непечатаемые последовательности, но также и любые байты,
    отличные от ASCII, при интерпретации UTF-8. В результате он предоставляет Unicode значения правильно отформатированного UTF-8,
    который представляет не-ASCII данные в строке:
    fmt.Printf("%+q\n", sample)
    // "\xbd\xb2=\xbc \u2318"

    %#U
    Вот пример, использующий еще один удобный формат Printf, %#U, который показывает значение Unicode кодовой точки и ее печатное представление:
    const nihongo = "日本語"
    for index, runeValue := range nihongo {
        fmt.Printf("%#U starts at byte position %d\n", runeValue, index)
    }
    U+65E5 '日' starts at byte position 0
    U+672C '本' starts at byte position 3
    U+8A9E '語' starts at byte position 6











// АЛГОРИТМЫ
    /*
    //Fibonacci Iterative
        func fibonachi(n int) int {
            var a, b int = 1, 1
            for i := 0; i < n; i++ {
                a, b = b, a+b
            }
            return a
        }
    */


    // работа с QueryString
        /*
        http://127.0.0.1:8000/fibonachi/1/8

        That means that I'd like to catch both /articles/123 and /articles/123?key=456 in the same handler.

        package main

        import (
            "fmt"
            "log"
            "net/http"

            "github.com/gorilla/mux"
        )

        var router = mux.NewRouter()

        func main() {
            router.Path("/articles/{id:[0-9]+}").Queries("key", "{key}").HandlerFunc(YourHandler).Name("YourHandler")
            router.Path("/articles/{id:[0-9]+}").HandlerFunc(YourHandler)

            if err := http.ListenAndServe(":9000", router); err != nil {
                log.Fatal(err)
            }
        }

        func YourHandler(w http.ResponseWriter, r *http.Request) {
            id := mux.Vars(r)["id"]
            key := r.FormValue("key")

            u, err := router.Get("YourHandler").URL("id", id, "key", key)
            if err != nil {
                http.Error(w, err.Error(), 500)
                return
            }

            // Output:
            // /articles/10?key=[key]
            w.Write([]byte(u.String()))
        }
        */



    // C GITHUB INFO
    go install mymath - компиляция пакета в директории
    go get -u … - чтобы обновить Ваши удаленные пакеты, при этом установятся все дополнительные зависимости .
    go - набор утилит, выполняемых из командной строки. Вы можете исполнить в терминале команду go, чтобы увидеть их


    // Принципы RESTful: https://www.codecademy.com/articles/what-is-rest
    -Разделение клиента и сервера (Используя интерфейс REST, разные клиенты обращаются к одним и тем же конечным 
    точкам REST, выполняют одни и те же действия и получают одинаковые ответы)
    -Системы, которые следуют парадигме REST, не имеют состояния, что означает, что серверу не нужно ничего знать
    о том, в каком состоянии находится клиент, и наоборот.  
    
    -Связь между клиентом и сервером
    REST требует, чтобы клиент сделал запрос к серверу, чтобы получить или изменить данные на сервере.  Запрос обычно состоит из:

        *HTTP-глагол, который определяет, какую операцию выполнять 
            Есть 4 основных HTTP-команды, которые мы используем в запросах для взаимодействия с ресурсами в системе REST:
            (GET-получить определенный ресурс по id | POST-создать новый ресурс |PUT - обновить |DELETE)

        *заголовок, который позволяет клиенту передавать информацию о запросе
        *путь к ресурсу
        *необязательное тело сообщения, содержащее данные

    -Заголовки и параметры Accept
        В заголовке запроса клиент отправляет тип контента, который он может получить от сервера.  
        Это называется полем Accept, и оно гарантирует, что сервер не отправляет данные, которые не могут быть
        поняты или обработаны клиентом.  Варианты типов контента - это типы MIME 
        Типы MIME, используемые для указания типов содержимого в поле Accept, состоят из типа и подтипа.  Они разделены косой чертой (/).
        Например, текстовый файл, содержащий HTML, будет указан с типом text / html.  
        Если бы этот текстовый файл содержал вместо этого CSS, он был бы указан как text / css.
        Общий текстовый файл будет обозначаться как text / plain.  Однако это значение по умолчанию, text / plain, не является универсальным.
        Если клиент ожидает text / css и получает text / plain, он не сможет распознать контент. Еще MIME-типы:

        image — image/png, image/jpeg, image/gif
        audio — audio/wav, audio/mpeg
        video — video/mp4, video/ogg
        application — application/json, application/pdf, application/xml, application/octet-stream

        GET /articles/23
        Accept: text/html, application/xhtml
        Поле заголовка Accept в этом случае говорит о том, что клиент примет содержимое в text / html или application / xhtml.

    -Пути
    Запросы должны содержать путь к ресурсу, над которым должна выполняться операция.  
    В RESTful API пути должны быть спроектированы так, чтобы помочь клиенту знать, что происходит.

    -Отправка ответов
    -В случаях, когда сервер отправляет полезные данные клиенту, 
    сервер должен включать тип содержимого в заголовок ответа. 
    Это поле заголовка типа содержимого предупреждает клиента о типе данных, 
    которые он отправляет в теле ответа.  Эти типы контента являются типами MIME, 
    как и в поле accept заголовка запроса.  
    Тип содержимого, который сервер отправляет обратно в ответе, должен быть одним из параметров,
    указанных клиентом в поле accept запроса.

    Например, когда клиент обращается к ресурсу с идентификатором 23 в ресурсе статей с этим запросом GET:
    GET /articles/23 HTTP/1.1
    Accept: text/html, application/xhtml
    
    Сервер может отправить обратно контент с заголовком ответа:
    HTTP/1.1 200 (OK)
    Content-Type: text/html

    -Коды ответов
        Ответы сервера содержат коды состояния, предупреждающие клиента об успешном выполнении операции.  
        Код состояния Значение
        200 (OK) Это стандартный ответ для успешных HTTP-запросов.
        201 (СОЗДАНО) Это стандартный ответ на HTTP-запрос, в результате которого элемент был успешно создан.
        204 (NO CONTENT) Это стандартный ответ для успешных HTTP-запросов, когда в теле ответа ничего не возвращается.
        400 (ПЛОХОЙ ЗАПРОС) Запрос не может быть обработан из-за неправильного синтаксиса запроса, чрезмерного размера или другой ошибки клиента.
        403 (ЗАПРЕЩЕНО) У клиента нет разрешения на доступ к этому ресурсу.
        404 (НЕ НАЙДЕН) В данный момент ресурс не может быть найден.  Возможно, он был удален или еще не существует.
        500 (ВНУТРЕННЯЯ ОШИБКА СЕРВЕРА) Общий ответ на непредвиденный сбой, если нет более конкретной информации.

    Для каждого HTTP-глагола есть ожидаемые коды состояния, которые сервер должен вернуть в случае успеха:
        GET - вернуть 200 (ОК)
        POST - возврат 201 (СОЗДАН)
        PUT - возврат 200 (ОК)
        УДАЛИТЬ - вернуть 204 (НЕТ КОНТЕНТА) Если операция завершилась неудачно, вернуть наиболее конкретный возможный код 
        состояния, соответствующий возникшей проблеме.


// ОБРАТИТЬ ВНИМАНИЕ (подводные камни) (+ см. статью Хабр https://habr.com/ru/company/mailru/blog/314804/)
    fmt.Scanf("%s", &row) // пробел считается разделителем, и при вводе строки "а в ц" сохранит только слово до пробела
    fmt.Println(row)

    Аналогично, до пробела считывает:
    var input string
    fmt.Scanln(&input)

    Используйте вместо этого
    myscanner := bufio.NewScanner(os.Stdin)
    myscanner.Scan()
    input := myscanner.Text()


    /* Task 5.  
        здесь цикл по blocks. block - копия экземпляра? 
            unknownGroupBlockFound := true
            for _, block := range blocks {
                if block.group == 0 {
                    block.group = groupID   // присваиваем 1
                    matrix[block.position.x][block.position.y].group = groupID  // даже тут присваиваем 1
                    head = block.position
                    fmt.Println("new HEAD (", head.x, head.y, ")", block.group, "matrix=", matrix[block.position.x][block.position.y], "groupId=", groupID, " the block=", block)
                    unknownGroupBlockFound = false
                    break
                }
            }
            // но почему-то в blocks эта единица не отображается в нужном экземпляре?!!!
    */
    // исправил на это и все заработало:
        unknownGroupBlockFound := true
        for i := 0; i < len(blocks); i++ {
            if blocks[i].group == 0 {
                blocks[i].group = groupID
                matrix[blocks[i].position.x][blocks[i].position.y].group = groupID
                head = blocks[i].position
                //fmt.Println("new HEAD (", head.x, head.y, ")", blocks[i].group, "matrix=", matrix[blocks[i].position.x][blocks[i].position.y], "groupId=", groupID, " the block=", blocks[i])
                unknownGroupBlockFound = false
                break
            }
        }









// АСИНХРОННОЕ ПРОГРАММИРОВАНИЕ
    Асинхронное программирование — это когда операции
    вашей программы выполняются не строго последовательно,
    а могут быть прерваны какими-то другими операциями вашей же программы.
    Самым известным примером асинхронного программирования является технология
    Ajax — асинхронный JavaScript и XML, когда во время
    запроса на сервер ваша страница не замораживается,
    а продолжает работать. 

    Context switch (Переключение контекста - дорогая операция - в кеше может и не быть запрашиваемых процессором данных):
        -Процессор выполняет только одну задачу одновременно
        -Планировщик задач переключает их
        -Для этого надо выгрузить одну задачу (тред, процесс) и загрузить другую
        -Для этого может потребоваться обращение к основной памяти

    подход к вытеснению одной программы другой,
    это называется вытесняющей многозадачностью

    // cgi-bin (тяжелая операция)
    -одно соединение - один процесс
    -если много запросов - упремся в память
    
    cgi-bin — на каждый запрос
    поднимается новая программа, создается новый процесс (!),
    это тяжелая операция, это нужно подключить довольно много памяти.
    Там выполняется какой-то запрос,
    и после этого программа убивается.
    Это может быть очень не эффективно,
    потому что при увеличении количества запросов мы
    начнем тратить много времени на создание и завершение
    процессов и можем банально упереться в количество оперативной памяти. 

    // worker pool
    Эволюцией этого подхода является worker pool,
    когда у нас есть некое количество процессов (!), которые не убиваются после
    завершения работы, а остаются в ожидании следующего запроса. 

    // мультитрединг
    Это значит, что мы уже создаем не целый процесс(!!) на один
    запрос или одно соединение, а всего лишь тред (!поток).
    Тред — это более легкая сущность, чем процесс.
    + Тред имеет доступ к памяти своего процесса, То есть
    вы можете переиспользовать какие-то соединения, например, к базе данных.
    + Тред занимает меньше памяти,
    но для процессора это тоже системный тред,
    он тоже выполняется процессором, его тоже нужно переключать context switch.
    
    Таким образом, за счет хотя бы экономии памяти
    мы можем обработать большее количество запросов.
    Также эволюцией тут является то,
    что мы можем создать worker pool и обрабатывать запросы,
    не плодя бесконечно новые треды,
    а распределять запросы по фиксированному количеству.
    Может быть, это как-то можно ускорить? 

    Основное время на современном web api уходит на
    ожидание внешних сервисов (запроса от какой-то удаленной базы данных, от какого-то веб-сервиса)

    // Неблокирующий ввод-вывод.
    Когда мы отправили запрос в базу данных,
    мы на этом не блокируемся, мы продолжаем (!) выполнять какие-то
    другие запросы, потому что процессор у нас бездействует.
    Таким образом, мы можем получить очень хорошую производительность. 
    Мы можем обрабатывать много запросов внутри одного треда

    Дело в том, что, поскольку у нас тред один,
    то мы никак не можем выполнять параллельно запросы.
    В случае с вытесняющей многозадачностью,
    когда тред блокируется, какой-то другой тред работает.
    В случае с кооперативной многозадачностью в этом случае, то мы должны
    дождаться окончания работы запроса № 1 для того,
    чтобы выполнять запрос № 2, и
    это может быть плохо,
    если у нас много операций на ЦПУ.
    Например, мы считаем какие-то хеши, занимаемся шифрованием либо
    архивированием, потому что это тяжелая процессорная операция, и нам будет не
    хватать того времени, которое мы проводим в ожидании ответов от базы данных.
    Нам будет не хватать времени для обработки всех операций, всех запросов.
    Соответственно, хочется как-то разнести это на несколько ядер,
    для того чтобы, пока один тред занят, мы могли выполнять что-то в другом треде.
    То есть размасштабироваться.
    И именно такой подход реализован в Go.
    Основан он на модели, которая называется communicating sequential processes
    от Тони Хоара, и оперируем мы в этом подходе
    такой сущностью, как горутина.
    Горутина — это аналог сопрограммы, когда в одном системном
    треде может выполняться несколько горутин, несколько сопрограмм.
    При этом особенностью является то,
    что наша горутина может начать выполняться на одном треде,
    потом уйти в ожидание данных из базы и продолжить выполняться в другом системном
    треде, потому что первый системный тред занят уже какой-то другой горутиной.
    Этот подход позволяет получить очень хорошую производительность,
    очень хорошую пропускную способность.
    Это является одним из ключевых особенностей языка
    Go и одной из самых сильных его сторон. 

    // ГОРУТИНЫ
    В официальной документации говорится, что «Горутина — это легковесный поток 
    выполнения». Горутины легче, чем потоки, поэтому управление ими сравнительно
    менее ресурсозатратно.

    Горутина (goroutine) — это функция, выполняющаяся конкурентно с другими горутинами в том же адресном пространстве.
    Запустить горутину очень просто:
    go normalFunc(args...)          // начнет выполняться асинхронно с вызвавшим ее кодом.
    
    Горутины очень легковесны. Практически все расходы — это создание стека,
    который очень невелик, хотя при необходимости может расти.

    В среднем можно рассчитывать примерно на 4,5kb на горутину. 
    То есть, например, имея 4Gb оперативной памяти, вы сможете 
    содержать около 800 тысяч работающих горутин.
    
    Горутины используются:   
    -Если нужна асинхронность. Например когда мы работаем с сетью, диском, базой данных, защищенным мьютексом ресурсом и т.п.
    -Если время выполнения функции достаточно велико (в зависимости от ситуации) и можно получить выигрыш,
    нагрузив другие ядра.

    https://habr.com/ru/post/141853/
    Каждая Машина работает в отдельном потоке и способна выполнять только одну
    Горутину в момент времени. Планировщик операционной системы, в которой 
    работает программа, переключает Машины. Число работающих Машин ограничено 
    переменной среды GOMAXPROCS или функцией runtime.GOMAXPROCS(n int). По 
    умолчанию оно равно 1. Обычно имеет смысл сделать его равным числу ядер.

    https://fooobar.com/questions/102728/what-exactly-does-runtimegosched-do
    При запуске программы Go без указания переменной среды runtime.GOMAXPROCS(n int), 
    Go goroutines запланированы для исполнения в одиночном потоке ОС. Однако, 
    чтобы программа казалась многопоточной (для чего предназначены goroutines, 
    не так ли?), Планировщик Go должен иногда переключать контекст выполнения, 
    поэтому каждый горутин может выполнять свою работу.

        func say(s string) {
            for i := 0; i < 5; i++ {
                runtime.Gosched()
                fmt.Println(s)
            }
        }

        func main() {
            go say("world")
            say("hello")
        }

        результат:  hello
                    world
                    hello
                    world
                    hello
                    world
                    hello
                    world

        но, если удалить runtime.Gosched(), то программа больше не выводит world
        результат:  hello
                    hello
                    hello
                    hello
                    hello



    когда переменная GOMAXPROCS не указана (по умолчанию = 1), в Run runtime 
    разрешено использовать
    только один поток, поэтому невозможно переключить контексты выполнения, в то 
    время как goroutine выполняет некоторую обычную работу, такую ​​как вычисления 
    или даже IO (который отображается на простые функции C). Контекст можно 
    переключать только тогда, когда используются примитивы Go concurrency, 
    например. когда вы включаете несколько chans или (это ваш случай), когда вы 
    явно указываете планировщику переключать контексты - для этого используется 
    runtime.Gosched.

    Итак, короче говоря, когда контекст выполнения в одном goroutine достигает 
    вызова Gosched, планировщику поручается переключить выполнение на другой 
    goroutine. В вашем случае есть два goroutines, main (который представляет 
    "основной" поток программы) и дополнительный, тот, который вы создали с 
    помощью go say. Если вы удалите вызов Gosched, контекст выполнения никогда 
    не будет перенесен с первой goroutine на второй, следовательно, для вас не 
    будет "мира". Когда присутствует Gosched, планировщик переносит выполнение 
    на каждой итерации цикла с первой горуты на вторую и наоборот, поэтому у вас 
    есть "hello" и "world" interleaved.

    это называется "совместная многозадачность": goroutines должен явно 
    передать управление другим goroutines. Подход, используемый в большинстве 
    современных ОС, называется "превентивной многозадачностью": потоки выполнения 
    не связаны с передачей управления; планировщик переключает контексты 
    выполнения прозрачно для них. Кооперативный подход часто используется для 
    реализации "зеленых потоков", то есть логических параллельных сопрограмм, 
    которые не отображают потоки 1:1 в ОС - это то, как реализовано время 
    выполнения и его goroutines.
        
    Когда переменная GOMAXPROCS установлена ​​на положительное число N, время 
    выполнения Go сможет создавать до N собственные потоки, по которым 
    запланированы все зеленые потоки. Собственная нить - это вид потока, 
    который создается операционной системой (потоки Windows, pthreads и т.д.).
    Это означает, что если N больше 1, возможно, что goroutines будут
    запланированы для выполнения в разных собственных потоках и, следовательно,
    будут выполняться параллельно (по крайней мере, до ваших возможностей
    компьютера: если ваша система основана на многоядерных процессор, вполне 
    вероятно, что эти потоки будут действительно параллельными, если у вашего
    процессора есть одно ядро, тогда превентивная многозадачность, реализованная 
    в потоках ОС, создаст видимость параллельного выполнения).

    func main() {
        runtime.GOMAXPROCS(2)
        go say("world")
        say("hello")
    }
    
    В этом случае вы можете наблюдать интересные результаты. Возможно, что вы 
    получите строки "hello" и "world", напечатанные чередующимися неравномерно,
    например:

    world
    world
    world
    world
    world
    hello
    hello
    hello
    hello
    hello

    или 

    hello
    hello
    hello
    hello
    hello

    Это может произойти, если goroutines планируют разделить потоки ОС. 
    Фактически, как работает превентивная многозадачность (или параллельная
    обработка в случае многоядерных систем): потоки параллельны, а их объединенный
    вывод является неопределенным. Кстати, вы можете оставить или удалить вызов
    Gosched, кажется, не имеет никакого эффекта, когда GOMAXPROCS больше 1.

    Похоже, что в новых версиях Go компилятора Go runtime заставляет goroutines
    выводить не только на использование примитивов concurrency, но и на системные 
    вызовы ОС. Это означает, что контекст выполнения может переключаться между 
    goroutines также на вызовы функций ввода-вывода. Следовательно, в последних 
    компиляторах Go можно наблюдать недетерминированное поведение, даже если 
    GOMAXPROCS не задано или установлено в 1.


    // https://habr.com/ru/post/141853/
    Исполнение горутины прерывается только тогда, когда она уже не может выполняться: то есть из-за системного 
    вызова или использования синхронизирующих объектов (операции с каналами, мьютексами и т.п.). 
    Не существует никаких квантов времени на работу горутины, после выполнения которых она бы заново возвращалась
    в очередь. Чтобы позволить планировщику сделать это, нужно самостоятельно вызвать runtime.Gosched().
    //
    for i:=0; i<10; i++ {
        go func() {
            for j:=0; j < 5; j++ {
                go func fmt.Println(j)
                runtime.Gosched()           // возможность передать управление другой горутине
            }
        }
    }

    На практике это в первую очередь означает, что иногда стоит использовать runtime.Gosched(), чтобы несколько
    долгоживущих горутин не остановили на существенное время работу всех других. С другой стороны, такие ситуации
    встречаются на практике довольно редко.

    Из горутины вы не можете вернуть никакое значение
    в основную программу, туда, где была вызвана эта горутина.
    Для этих целей используются каналы

    // Основная трудность при многопроцессорной разработке,
    то есть когда ваша программа использует несколько ядер процессоров или даже
    несколько процессоров, состоит в том, что вам нужно как-то их синхронизировать между
    собой и каким-то образом передавать данные между разными потоками.
    В Go для этих целей есть каналы. 



// СИНХРОНИЗИРУЮЩИЕ ОБЪЕКТЫ (каналы, мьютексы)
    // Каналы -  — это способ коммуникации между горутинами. Они используются, 
    когда вы хотите передать результаты, ошибки или другую информацию от одной
    горутины другой. Каналы бывают разных типов, например, канал типа int 
    получает целые числа, а канал типа error — ошибки, и т.д.

    ch1 := make(chan int)       // небуферизированный канал:
    
    Это значит, что, когда я кладу в канал какое-то значение,
    кто-то с другой стороны этого канала должен его прочитать.
    И если никто не читает, то горутина блокируется,
    до тех пор пока на той стороне не появится тот,
    кто вычтет это значение.
    К чему это можем привести?
    Привести это может к тому, что мы залочимся. 

    Но в случае если в deadlock попадут какие-то другие горутины
    внутри вашей программы, а другие горутины будут
    продолжать работать, которые будут выполнять совершенно другую работу,
    то может прийти ситуация, которая называется утечка горутин,
    то есть горутина залочилась и чего-то ждет, но никогда не дождется.
    Это приводит к утечке памяти (!)
    
    канал может принимать не одно значение,
    до того как он залочится, а несколько.
    Осуществляется это если мы укажем значение буфера для этого канала
    ch2 := make(chan int, 1)        // буферизированный канал

    // закрытие канала
    close(ch1)
    // если где-то происходит итерирование данных из канала:
    for i:= range ch1 {
        fmt.Println(i)
    }
    // и в другой горутине что-то писалось в канал, то произойдет deadlock, т.к. в цикле ждем сообщений в канале, 
    // но никто ничего уже писать туда не будет. Поэтому, необходимо вызывать close(ch1) в пишушей горутине, тогда 
    // цикл завершится

    // FAQ каналы:
    при попытке чтения из закрытого канала (!):
    -Происходит мгновенный возврат значения по-умолчанию для типа который находится в данном канале 
    и признака того что канал был закрыт
    
    при попытке записи в закрытый канал (!):
    -Происходит паника

    Когда может завершиться цикл по буферизированному каналу?
    -Когда канал будет закрыт при помощи функции close
    -При ручном прерывании цикла при помощи оператора break

    Что будет, если в буферизированный канал переполнить?
    func main() {
        c := make(chan int, 2)
        c <- 1
        c <- 2
        c <- 3
    }
    -произойдет deadlock (так как никто не читает с канала и не освобождает буфер)!

    А если заполнить буфер и выйти?
    func main() {
        c := make(chan int, 2)
        c <- 1
        c <- 2
        fmt.Println("Hello, playground")
    }
    -программа отработает нормально

    После закрытия канала вы не можете записать в него новые значения 
    (будет сбой при попытке), и любое чтение вернется сразу с нулевым значением для типа канала
    
    nil каналы:
        // deadlock
        var c chan int
        c <- 1

        // deadlock
        var c chan int
        fmt.Println(<-c)

        Если закрыть канал nil, произойдет сбой.
        // panic: close of nil channel
        var c chan int
        close(c)




    // Направление каналов
    Мы можем задать направление передачи сообщений в канале, сделав его только отправляющим или принимающим. 
    Например, мы можем изменить функцию pinger:

    func pinger(c chan<- string)        // можем только писать в канал

    и канал c будет только отправлять сообщение. Попытка получить сообщение из канала c вызовет ошибку компилирования. 
    Также мы можем изменить функцию printer:

    func printer(c <-chan string)       // можем только читать из канала

    Существуют и двунаправленные каналы, которые могут быть переданы в функцию, принимающую только принимающие или
    отправляющие каналы. Но только отправляющие или принимающие каналы не могут быть переданы в функцию, требующую двунаправленного канала!


    // буферизированный канал
    буферизированный канал с ёмкостью 1. Обычно каналы работают синхронно - каждая из сторон ждёт, когда другая сможет
    получить или передать сообщение. Но буферизованный канал работает асинхронно — получение или отправка сообщения не 
    заставляют стороны останавливаться. Но канал теряет пропускную способность, когда он занят, в данном случае, если мы 
    отправим в канал 1 сообщение, то мы не сможем отправить туда ещё одно до тех пор, пока первое не будет получено.

    c := make(chan int, 1)


    // Горутины, многопоточность, deadlocks
    !!! Важно не читать и не писать в один канал, созданный в одном потоке: deadlock
    НЕТ ДРУГИХ ПОТОКОВ, КОТОРЫЕ МОГЛИ БЫ ЗАПИСАТЬ В ЭТОТ КАНАЛ

    func main() {
        ch := make(chan string)
        sayHello(ch)    // ДЛЯ КОРРЕКТНОЙ РАБОТЫ ЭТОГО КОДА НЕОБХОДИМО функцию сделать горутиной: go sayHello(ch)
        <-ch        // считываем (все в одном потоке)
    }

    func sayHello(exit chan string) {
        fmt.Print("hello")
        exit <- "gg bb" // записываем (все в одном потоке)
    }

    // Закрытие канала:
    func main() {
        ch := make(chan string)
        go sayHello(ch)
        
        // работает до закрытия потока функцией close(ch)
        for i := range ch {
            fmt.Println(i)
        }
    }

    func sayHello(exit chan string) {
        for i := 0; i < 5; i++ {
            time.Sleep(100*time.Millisecond)
            exit <- i
        }
        close(exit)
    }


    // deadlock part 2!!!!!!!!


    func main() {
        c1 := make(chan int)
        c2 := make(chan int)
        c3 := make(chan int)


        // DEADLOCK! т.к. каналы инициализированы, в канал пишется значение, но его никто не читает (управление не дошло до горутины,
        // которая способна читать из c1). Решение: Перенести код после объявления и запуска горутин. Тогда в отдельном потоке 
        // из канала c1 будет ожидаться чтение, после чего в канал поступит значение
        // c1 <- 1


        go func() {
            for _, value := range []int{1, 4, 7} {
                <-c1
                fmt.Println(value)
                c2 <- 1
            }
        }()

        go func() {
            for _, value := range []int{2, 5, 8} {
                <-c2
                fmt.Println(value)
                c3 <- 1
            }

            //wg.Done()
        }()

        go func() {
            for _, value := range []int{3, 6, 9} {
                <-c3
                fmt.Println(value)
                c1 <- 1
            }

            //wg.Done()
        }()

        // А вот так работать будет!!!!
        c1 <- 1

        var input string
        fmt.Scanln(&input)
    }


// Мультиплексирование каналов через оператор select (SELECT в горутинах)
    Select тоже что и switch, но работает с каналами. Он случайно 
    выбирает готовый для взаимодействия канал.

    Оператор «break» завершает выполнение самого внутреннего оператора «for», «switch» или «select».

    L:
    for i < n {
        switch i {
        case 5:
            break L
        }
    }

    for {
        select {
        // select в бесконечном цикле ждет сообщения из канала. Следующая итерация цикла не выполняется, до тех пор,
        // пока в одном из каналов не появится сообщение
        case msg1 := <-c1:
            fmt.Println(msg1)
        case msg2 := <-c2:
            fmt.Println(msg2)
            // ИЛИ появляется сообщение (cases 1,2) ИЛИ выполняется case 3 с таймаутом 1с: time After создаёт канал, по которому посылаем метки времени с заданным интервалом.
        case <-time.After(time.Second):
        	fmt.Println("timeout")
            // дефолтное значение будет выполняться очень быстро: Выполняемые по умолчанию команды исполняются сразу же, если все каналы заняты.
            default:
            	fmt.Println("nothing ready")
        }
    }

    // FAQ
    (!) В случае, если результат есть нескольких каналах внутри select'а - какой из них будет выбран?
        Случайный 



    // Инструменты для многопроцессорного программирования
        // Таймер и таймаут

        У таймера есть канал, и в случае если мы будем использовать
        мультиплексор select, то мы можем поставить на
        чтение с этого канала, и как только наступит нужное время,
        там появится событие, и он сработает. 
        
        timer := time.NewTimer(1*time.Second)
        select {
            case <-timer.C:             // канал таймера
                fmt.Println("timer.C timeout happened")

            // У NewTimer есть короткое объявление,
                когда нам сразу же возвращается канал без 
                промежуточной переменной.
                Но у них есть небольшие особенности.
                Мы можем остановить timer от выполнения (!),
                а time.After мы остановить не можем (!), и пока он не выполнится,
                даже если мы завершили функцию, он не освободит ресурсы.
                Поэтому если вам нужно лучше контролировать расход ресурсов,
                расход памяти, пользуйтесь простым таймером и останавливайте его,
                когда вам это требуется. 

            case <-time.After(time.Minute):
                // пока не выстрелит - не соберется сборщиком мусора
                fmt.Println("timer.After timeout happened")

            case result := <-longSQLQuery():       
                // освобождает ресурс
                if !timer.Stop() {
                    <-timer.C
                }
                fmt.Println("operation result:", result)
        } 


        // Переодические события — это значит, что с определенным интервалом
        времени вам приходят события, и вы что-то делаете в это время.
        Делается это через конструкцию ticker,
        она тоже находится в пакете time, ее можно создать через NewTicker.
        Если вы читаете из канала, который предоставляет ticker,
        то вам возвращается время, когда было срабатывание. 

        // ждем 5 секунд, каждую секунду идет вывод
        ticker := time.NewTicker(time.Second)
        i := 0
        for tickTime := range ticker.C {
            i++
            fmt.Println("step", i, "time", tickTime)
            if i >= 5 {
                // надо останавливать
                ticker.Stop()
                break
            }
        }
        fmt.Println("total", i)


        // у тикера есть короткий alias,
        time.Tick, который Вам возвращает сразу канал,
        с которого вы можете читать, но у него есть особенность: он работает бесконечно,
        вы никак не можете его освободить (!). 
        
        c := time.Tick(time.Second)
        i = 0
        for tickTime := range c {
            i++
            fmt.Println("step", i, "time", tickTime)
            if i >= 5 {
                break
            }
        }

        // Его надо использовать тогда, когда вы точно не планируете его останавливать.
        Например, для сбора какого-то мониторинга с вашей программы,
        то есть который запускается каждую минуту, собирает метрики и куда-то их отсылает. 
        

        // AfterFunc, запускает функцию через определенный промежуток времени.
        Как результат выполнения этой функции,
        вам возвращается таймер, который Вы можете остановить,
        тем самым прервав выполнение этой функции. 

        timer := time.AfterFunc(1 * time.Second, func () { 
            fmt.Println("qq")
        })

        fmt.Scanln()
        timer.Stop()            // прерываем таймер
        fmt.Scanln()


    // CONEXT. (отмена асинхронных операций, передача контекста)
        Пакет context в Go полезен при взаимодействиях с API и медленными процессами, особенно в production-grade системах,
        которые занимаются веб-запросами. С его помощью можно уведомить горутины о необходимости завершить свою работу (!).
        
        Пакет context в go позволяет вам передавать данные в вашу программу в каком-то «контексте». 
        Контекст так же, как и таймаут, дедлайн или канал, сигнализирует прекращение работы и вызывает return. 

        (со MTS Stepik:)
        Пакет Context определяет тип context.Context, который содержит дедлайны, 
        сигналы отмены и другие значения для внешнего запроса через API и между 
        обрабатывающими запрос горутинами.

        Входящие запросы к серверу должны создавать контекст, а исходящие вызовы 
        к серверам должны принимать контекст. Цепочка вызовов функций между ними 
        должна распространять контекст, при необходимости заменяя его производным 
        контекстом, созданным с помощью WithCancel, WithDeadline, WithTimeout или
        WithValue. Когда контекст отменяется, все производные от него контексты 
        также отменяются.

        Функции WithCancel, WithDeadline и WithTimeout принимают родительский Context
        и возвращают производный дочерний Context и CancelFunc. Вызов CancelFunc 
        отменяет дочерний элемент и его дочерние элементы, удаляет ссылку родителя
        на дочерний элемент и останавливает все связанные таймеры, если они были. 
        Все дочерние контексты теперь могут быть уничтожены GC, если они перестали 
        использоваться в каких-либо горутинах и если GC посчитал необходимым 
        произвести такую очистку. Горутины, использующие контексты, должны следовать
        некоторым правилам, чтобы обеспечить согласованность интерфейсов между 
        пакетами и дать возможность использовать инструменты статического анализа 
        для проверки распространения контекста:

        1. Не храните контексты внутри структур. Вместо этого явно передайте контекст
        каждой функции, которая в нем нуждается. Контекст должен быть первым параметром,
        обычно называемым ctx

        func DoSomething(ctx context.Context, arg Arg) error {
            // ... use ctx ...
        }

        2. Не передавайте пустой контекст (nil), даже если это поддерживается функцией.
        Передайте context.TODO, если вы не уверены, какой контекст использовать.

        3. Используйте значения контекста только для данных окружения одного запроса,
        проходящего через горутины и API, а не для передачи дополнительных параметров
        функциям.

        Один и тот же контекст может быть передан функциям, работающим в разных горутинах. 
        Контексты безопасны для одновременного использования несколькими горутинами.
        Пример с отменой контекста:

        func httpDo(ctx context.Context, req *http.Request, f func(*http.Response, error) error) error {
            // Run the HTTP request in a goroutine and pass the response to f.
            c := make(chan error, 1)
            req = req.WithContext(ctx)
            go func() { c <- f(http.DefaultClient.Do(req)) }()
            select {
            case <-ctx.Done():
                <-c // Wait for f to return.
                return ctx.Err()
            case err := <-c:
                return err
            }
        }

        Функция httpDo запускает HTTP-запрос и обрабатывает его ответ в новой горутине. 
        Она отменяет запрос, если ctx.Done закрывается до завершения дочерней горутины.


        context.Background() ctx Context
        ctx, cancel := context.Background()
        Эта функция возвращает пустой контекст. Она должна использоваться только 
        на высоком уровне (в main или обработчике запросов высшего уровня). Он 
        может быть использован для получения других контекстов.


        context.TODO() ctx Context
        ctx, cancel := context.TODO()
        Эта функция также создает пустой контекст. И она тоже должна использоваться
        только на высоком уровне или когда вы не уверены, какой контекст использовать,
        или если в функции еще нет получения нужного контекста. Это значит, что вы
        планируете позже добавить контекст в функцию.


        context.WithValue(parent Context, key, val interface{}) Context
        ctx := context.WithValue(context.Background(), key, "test")
        Эта функция принимает контекст и возвращает производный от него контекст,
        в котором значение val связано с key и проходит через всё контекстное дерево.
        То есть, как только вы создадите контекст WithValue, любой производный контекст
        получит это значение. Не рекомендуется передавать критические параметры,
        используя значения контекста, вместо этого функции должны принимать их в 
        сигнатуре явным образом.


        context.WithCancel(parent Context) (ctx Context, cancel CancelFunc)
        ctx, cancel := context.WithDeadline(context.Background(), 
                time.Now().Add(2 * time.Second))
        Эта функция создает новый контекст из переданного ей родительского.
        Родителем может быть контекст background или контекст, переданный в
        качестве аргумента функции. Возвращается производный контекст и функция
        отмены. 
        (!) Вызывать функцию отмены контекста должна только та функция, которая
        его создает. (НИКОГДА не передавайте функцию отмены в другие функции)
        
        
        context.WithDeadline(parent Context, d time.Time) (ctx Context, cancel CancelFunc)
        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))
        Эта функция возвращает производный контекст от своего родителя, который 
        отменяется после дедлайна или вызова функции отмены. Например, вы можете
        создать контекст, который автоматически отменяется в определенное время 
        и передает это дальше в дочерние функции. Когда этот контекст отменяется 
        после дедлайна, все функции, у которых есть этот контекст, по уведомлению 
        должны закончить работу.


        context.WithTimeout(parent Context, timeout time.Duration) (ctx Context, cancel CancelFunc)
        ctx, cancel := context.WithTimeout(context.Background(), 2 * time.Second)
        Эта функция похожа на context.WithDeadline. Разница в том, что в качестве
        входных данных используется длительность времени. Эта функция возвращает
        производный контекст, который отменяется при вызове функции отмены или по
        истечении времени.

        https://habr.com/ru/company/nixys/blog/461723/


        Давайте посмотрим пример.
        Допустим, мы отправляем запросы на несколько разных серверов,
        при этом нам нужен только первый из них, и всех остальных мы не ждём

        
        func worker(ctx context.Context, workerNum int, out chan<- int) {
            // имитация некоторой работы:
            waitTime := time.Duration(rand.Intn(100) + 10) * time.Millisecond
            fmt.Println(workerNum, "sleep", waitTime)

            select {
                // БЕЗОПАСНО ИСПОЛЬЗОВАТЬ между неск. горутинами (ctx.Done)
                // либо завершаем горутину по сигналу от finish()
                case <- ctx.Done():
                return

                // либо по времени
                case <-time.After(waitTime):
                    fmt.Println("worker", workerNum, "done")
                    out <- workerNum
            }
        }
        
        func main() {
            // ВАРИАНТ 1. Завершение горутин по событию
                // ContextBackground — это такой базовый контекст
                ctx, finish := context.WithCancel(context.Background())
                
                result := make(chan int, 1)
                
                for i := 0; i <= 10; i++ {
                    go worker(ctx, i, result)
                }

                // Дожидаемся первого результата
                foundBy := <-result
                fmt.Println("result found by", foundBy)
            
                // вызов метода, полученного при создании ctx.WithCancel
                finish()
            

            // ВАРИАНТ 2. Завершение горутин по таймауту
                workTime := 50 * time.Millisecond

                ctx, finish = context.WithTimeout(context.Background(), workTime)
                result = make(chan int, 1)

                for i := 0; i <= 10; i++ {
                    go worker(ctx, i, result)
                }

                total := 0
                LOOP:
                    for {
                        select {
                            // когда таймер сработал, в канал <-ctx.Done() что-то посылается
                            case <-ctx.Done():
                                break LOOP
                            
                            case foundBy := <-result:
                                total++
                                fmt.Println("result found by", foundBy)
                        }
                    }

                 fmt.Println("total", total)
            time.Sleep(time.Second)
        }




    // АСИНХРОННОЕ ПОЛУЧЕНИЕ ДАННЫХ
        func getComments(){
            // !!! важно использовать буферизированный канал.
            // так как это даёт нам возможность записать хотя бы одно значение
            // в этот канал, не блокируясь. 
            // Если использовать небуферезированный канал, то горутина пытается
            // записать в канал синхронно, то есть ожидая с другой стороны чтение,
            // но оттуда уже никто не читает. И получится утечка горутин и,
            // как следствие, утечка памяти. 
            res := make(chan string, 1)

            go func(out chan<- string) {
                // долгая операция
                out <- "32 комментария"
            } (res)
            return result
        }

        func getPage() {
            // получаем канал
            resultCh := getComments()

            // какая-то длительная операция 
            ...

            result := <-resultCh
            fmt.Println(result)
        }


        (!) Утечка памяти происходит также когда буфер канала переполняется и 
        происходит блокировка на записи второго значения:
        func getComments() chan string {
            result := make(chan string, 1)
            go func(out chan<- string) {
                out <- "загрузка комментариев"
                out <- "32 комментария"
            }(result)
            return result
        }
        
        func getPage() {
            resultCh := getComments()
            // не читаем из полученного канала
            return
        }
    
    // ПУЛ ВОРКЕРОВ (POOL WORKERS)
    Мы можем создать сразу просто несколько горутин,
    которые будут читать из какого-то канала.
    И если нам приходит какая-то задача, мы просто будем писать ее в этот канал.
    А там воркеры уже дальше сами разберутся. 
    
    func startWorker(workerName int, in <-chan string) {
        for input := range in {
            // выполнение работы из пула
            fmt.Printf(workerNum)

            // Готовые к исполнению горутины выполняются в порядке очереди, то есть FIFO
             (First In, First Out). Исполнение горутины прерывается только тогда, когда 
             она уже не может выполняться: то есть из-за системного вызова или
             использования синхронизирующих объектов (операции с каналами, мьютексами и
             т.п.). Не существует никаких квантов времени на работу горутины, после
             выполнения которых она бы заново возвращалась в очередь. Чтобы позволить
             планировщику сделать это, нужно самостоятельно вызвать runtime.Gosched().
             На практике это в первую очередь означает, что иногда стоит использовать
             runtime.Gosched(), чтобы несколько долгоживущих горутин не остановили на 
             существенное время работу всех других. С другой стороны, такие ситуации
             встречаются на практике довольно редко (!)
            runtime.Gosched()
        }
        
        fmt.Printf("Воркер завершил работу!!")
    }

    func main() {
        // пул - как очередь заданий. буферизированный канал. Если небуферизированный - то deadlock
        // т.к. пишем, и в этот же момент никто не читает
        workerInput := make(chan string, 2)

        // создаем горутины
        for i := 0; i < 5; i++ {
            go startWorker(i, workerInput)
        }

        // воркеры сами разберутся - задача идет в канал. 
        // рендомная горутина принимает к работе
        months := []string{"a", "b", "c", "a", "b", "c"}
        for _, mName := range months {
            workerInput <- mName
        }

        // обязательно закрыть канал (пул воркеров) - иначе не дождемся окончания 
        // работы воркеров. Это может привести к дедлоку или утечки памяти
        close(workerInput)
    }


    // sync.Waitgroup - ожидание завршения работы
    каким образом можно дождаться окончания работы нескольких горутин,
    кроме использования каналов, конечно. Ранее использовали Scanln()

    Вызовы Add увеличивает счетчик на переданное число, а вызовы Done 
    уменьшают счетчик на единицу. Wait блокируется пока счетчик не станет 
    равным нулю.

    func startWorker(in int, wg *sync.WaitGroup) {
        // после выполнения задачи уменьшаем счетчик на 1
        defer wg.Done() 

        for j := 0; j < 3; j++ {
            fmt.Println(in, j)
            runtime.Gosched()
        }
    }

    func main() {
        // всегда по указателю создаем waitGroup
        wg := &sync.WaitGroup{}

        for i := 0; i < 3; i++ {
            // добавляем воркер
            wg.Add(1)
            // запускам горутину в том же блоке, где и добавляем wg.Add (!)
            go startWorker(i, wg)
        }

        // ожидаем, пока waiter.Done() не приведет счетчик к нулю
        wg.Wait()
    }


    // RATE-лимиты (ограничение по ресурсам)
    Довольно часто бывает так, что нам нужно каким-либо образом затормозить нашу
    программу, например, в зависимости от утилизации процессора,
    либо дисковой подсистемы, нам нужно уменьшить нагрузки на эти части.
    В Go мы можем организовать это, используя буферизированные каналы. 

    В примере ниже могут исполняться только 2 горутины. Горутины в цикле выводят 
    значения от 0 до iterationsNum на экран. 

    При варианте без модификации - 2 горутины занимают квоту и выводят значения 
    в некотором порядке (хаотично). При варианте с модификацией - передаем управление 
    от первых занявших квоту горутин на другие горутины. Итого на выходе имеем 
    "сбалансированное" выполнение работы (все горутины начинают свою задачу, и потом
    заканчивают. Без модификации - по-другому - первые занявшие 2 горутины выполняют свою
    задачу полностью и только потом выполняются остальные горутины по такому же принципу)

    Важно отметить, что с учетом модификации по-прежнему программа не выходи за 
    установленные rate-лимиты (выполнять 2 горутины максимум).

    const (
        iterationsNum = 6
        goroutinesNum = 5
        quotaLimit = 2              (!) ограничиваем ресурсы
    )
    
    
    func startWorker(in int, wg *sync.WaitGroup, quotaCh chan struct{}) {
        // берём свободный слот и блокируемся, до тех пор, пока не появится место
        quotaCh <- struct{}{} 

        // после выполнения задачи уменьшаем счетчик на 1
        defer wg.Done()

        for j := 0; j < iterationsNum; j++ {
            fmt.Printf(in, j)

            /* вариант модификации - можем возвращать квоту обратно на каждой второй итерации
                if j % 2 == 0 {
                    <-quotaCh       // возвращаем слот 
                    quotaCh <- struct{}{}
                }
            */
        }
        
        // возвращаем слот
        <-quotaCh 
    }
        
    func main() {
        wg := &sync.WaitGroup{}
        
        // Канал с квотой — это буферизированный канал,
        // где размер буфера как раз и является нашим лимитом
        // пустая структура не занимает никакого места
        quotaCh := make(chan struct{}, quotaLimit) 
        
        // создаем 5 горутин при квоте в 2
        for i := 0; i < goroutinesNum; i++ {
            wg.Add(1)

            // передаем канал с воркером в горутины
            go startWorker(i, wg, quotaCh)
        }

            time.Sleep(time.Millisecond)
            wg.Wait()
        }


    // СОСТОЯНИЕ ГОНКИ (Data race). Ситуация гонки на примере конкурентной записи в map
        map в Go — это конкурентно небезопасный тир данных,
        то есть обращаясь к нему из разных горутин, которые могут выполняться
        совершенно на разных процессорах, можно как раз словить это состояние гонки. 

    func main() {
        var counters = map[int]int{}
        for i := 0; i < 5; i++ {
            go func(counters map[int]int, th int) {
                for j := 0; j < 5; j++ {
                    // небезопасная запись в MAP
                    counters[th*10+j]++
                }
            }(counters, i)
        }
        fmt.Scanln()
        fmt.Println("counters result", counters)
    }

    // при запуске - fatal error: concurrent map writes
    
    Для того чтобы ловить похожие ошибки,
    в Go есть специальная директива при запуске программы или компиляции race
        go run -race race_1.go

    WARNING: DATA RACE

    // sync.Mutex для синхронизации данных (Мьютекс, Mutex)
    Mutex означает mutual exclusion(взаимное исключение) и является способом
    защиты critical section(критическая секция) вашей программы.

    Критическая секция — это область вашей программы, которая требует 
    эксклюзивного доступа к общему ресурсу. При нахождении в критической 
    секции двух (или более) потоков возникает состояние race(гонки). 
    Так же возможны проблемы взаимной блокировки(deadlock).

    mutex — это такой большой, «жирный» примитив,
    большая, «жирная» конструкция для синхронизации мощных кусков. 

    type counter struct{
        sync.Mutex
        count int
    }
    
    func (c *counter) Increment() {
        c.Lock()
        defer c.Unlock()            
        c.count++
    }
    
    вызываем Unlock в defer. Это очень распространенная идиома при 
    использовании Mutex, чтобы гарантировать, что вызов всегда произойдет,
    даже при панике. Несоблюдение этого требования может привести к deadlock
    вашей программы. Хотя defer и несет небольшие затраты.

    Mutex обеспечивает безопасный доступ к общим ресурсам.

    func main() {
        var counters = map[int]int{}
        // использовать по ссылке
        mu := &sync.Mutex{}
        
        for i := 0; i < 5; i++ {
            go func(counters map[int]int, th int, mu *sync.Mutex) {
                for j := 0; j < 5; j++ {
                    mu.Lock()
                    counters[th*10+j]++
                    mu.Unlock()
                }
            }(counters, i, mu)
        }
        
        fmt.Scanln()
    *    //mu.Lock()
        fmt.Println("counters result", counters)
    *    //mu.Unlock()
    }

    go run -race main.go:
    ...
    counters result map[0:1 1:1 2:1 3:1 4:1 10:1 11:1 12:1 13:1 14:1 20:1 21:1 22:1 23:1 24:1 30:1 31:1 32:1 33:1 34:1 40:1 41:1 42:1 43:1 44:1]
    Found 2 data race(s)

    Для решения нужно обращение к данным покрыть Lock() на мьютексе (раскоментить *)


    // RWMutex
        RWMutex концептуально то же самое, что и Mutex: он защищает доступ к
        памяти. Тем не менее, RWMutex дает вам немного больше контроля над памятью.
        Вы можете запросить блокировку для чтения, и в этом случае вам будет 
        предоставлен доступ, если блокировка не удерживается для записи.

        Это означает, что произвольное число читателей может удерживать блокировку
        читателя, пока ничто другое не удерживает блокировку писателя.

    // RWMutex - это блокировка взаимного исключения чтения / записи.  Блокировку может удерживать произвольное количество читателей
	// или один писатель.  Нулевое значение для RWMutex - это разблокированный мьютекс.
	// Другими словами, читателям не нужно ждать друг друга.  Им остается только дождаться писателей, удерживающих Lock.
	// Таким образом, sync.RWMutex предпочтительнее для данных, которые в основном читаются

        func (c *counter) CountV1() int {
            c.Lock()
            defer c.Unlock()
            return c.count
        }
        func (c *counter) CountV2() int {
            c.RLock()
            defer c.RUnlock()
            return c.count
        }

        CountV2 (в отличие от CountV1) не блокирует c.count если
        не было блокировок на запись.


    // Cond
        Условная переменная(condition variable) — примитив синхронизации, 
        обеспечивающий блокирование одного или нескольких потоков до момента
        поступления сигнала от другого потока о выполнении некоторого условия 
        или до истечения максимального промежутка времени ожидания.

        Сигнал не несет никакой информации, кроме факта, что произошло какое-то
        событие. Очень часто мы хотим подождать один из этих сигналов, 
        прежде чем продолжить выполнение. Один из наивных подходов состоит 
        в использовании бесконечного цикла:

        for conditionTrue() == false {
            time.Sleep(1 * time.Millisecond)
        }

        Но это довольно неэффективно, и вам нужно выяснить, как долго спать:
        слишком долго, и вы искусственно снижаете производительность; 
        слишком мало, и вы отнимаете слишком много процессорного времени. 
        Было бы лучше, если бы у процесса был какой-то способ эффективно спать,
        пока ему не будет дан сигнал проснуться и проверить его состояние.

        Такие задачи могут решать каналы или вариации 
        паттерна PubSub(Publisher-Subscriber).

        Но если у вас низкоуровневая библиотека, где необходим более 
        производительный код, тогда можно использовать тип sync.Cond.

        Предположим у нас есть некоторый общий ресурс в системе. 
        Одна группа процессов может изменять его состояния, а другая группа
        должна реагировать на эти изменения.

        type message struct {
            cond *sync.Cond
            msg  string
        }

        func main() {
            msg := message{
                cond: sync.NewCond(&sync.Mutex{}),
            }

            // запуск 3 goroutine, которые ждут сигнала
            for i := 1; i <= 3; i++ {
                go func(num int) {
                    for {
                        // При входе в Wait вызывается Unlock в Locker переменной Cond
                        msg.cond.L.Lock()
                        
                        // вызов Wait не просто блокирует, он приостанавливает текущую процедуру,
                        // позволяя другим процедурам запускаться.
                        msg.cond.Wait()

                        fmt.Printf("hello, i am worker%d. text:%s\n", num, msg.msg)
                        
                        // а при выходе из Wait вызывается Lock в Locker переменной Cond.
                        msg.cond.L.Unlock()
                    }
                }(i)
            }

            // читаем ввод из консоли и отправляем сигнал об изменении состояния.
            scanner := bufio.NewScanner(os.Stdin)
            fmt.Print("Enter text: ")
            
            for scanner.Scan() {

                msg.cond.L.Lock()
                msg.msg = scanner.Text()
                msg.cond.L.Unlock()

                // отправляет сигнал всем ожидающим goroutine
                msg.cond.Broadcast()
            }
        }
        

    // sync.Atomic
        Atomic быстрее мьютекса
        внутри мьютекса встроен atomic как более низкоуровневый примитив.
        В пакете atomic довольно много разных функций
        для атомарных
        операций со счетчиками либо для сравнения и замены. 
        
        // Пример программы со счетчиком, инкрементирующимся из 1000 горутин (состояние гонки).
        var totalOperations int32 = 0
        func inc() {
            totalOperations++
        }
        
        func main() {
            for i := 0; i < 1000; i++ {
                go inc()
            }
            
            time.Sleep(2 * time.Millisecond)
            
            // ождается 1000, но по факту будет меньше
            fmt.Println("total operation = ", totalOperations)
        }

        Изменим функцию inc(): 
            мы уже не инкрементируем счетчик напрямую,
            а используем функцию из пакета atomic
            Мы вызываем функцию AddInt32, куда передаем адрес нашей
            переменной и то значение, на которое мы хотим увеличить. 
        func inc() {
            atomic.AddInt32(&totalOperations, 1)    // автомарно
        }



    // STRING TO SLICE OF BYTE
    Иногда нам понадобится работать с бинарными данными. Чтобы преобразовать строку в набор байт (и наоборот), выполните следующие действия:
    arr := []byte("test")
    str := string([]byte{'t','e','s','t'})








// ФАЙЛЫ. Чтение из файла:
package main

import (
    "fmt"
    "io/ioutil"
)

func main() {
    bs, err := ioutil.ReadFile("test.txt")
    if err != nil {
        return
    }
    str := string(bs)
    fmt.Println(str)
}

// ФАЙЛЫ. Запись в файл
package main

import (
    "os"
)

func main() {
    file, err := os.Create("test.txt")
    if err != nil {
        // здесь перехватывается ошибка
        return
    }
    defer file.Close()

    file.WriteString("test")
}


// МЬЮТЕКСЫ
Когда мьютекс (m) заблокирован из одного процесса, любые попытки повторно блокировать его из других процессов
приведут к блокировке самих процессов до тех пор, пока мьютекс не будет разблокирован.
func main() {
    m := new(sync.Mutex)

    for i := 0; i < 10; i++ {
        go func(i int) {
            m.Lock()                    // Заблокировали в первом вызове горутины и моментально создали еще 9 горутин, которые при попытке
            // снова заблокировать мьютекс приведет к блокировке этих горутин до разблокировки мьютекса в первой запущенной горутине
            fmt.Println(i, "start")
            time.Sleep(time.Second)
            fmt.Println(i, "end")
            m.Unlock()
        }(i)
    }

    var input string
    fmt.Scanln(&input)
}




Например, можно перенаправить потоки из stdout и stderr в файлы на диске при запуске приложения
 из терминала следующим образом
go run ./cmd/web >>/tmp/info.log 2>>/tmp/error.log
 лучше записывать вывод в стандартные потоки и перенаправлять вывод в файл при запуске приложения из командной строки.
  Но, если вы не хотите этого делать, всегда можно открыть файл в Go и использовать его в качестве места назначения лога. Например:

f, err := os.OpenFile("info.log", os.O_RDWR|os.O_CREATE, 0666)
if err != nil {
    log.Fatal(err)
}
defer f.Close()

infoLog := log.New(f, "INFO\t", log.Ldate|log.Ltime)



Пакеты в Go (MTS Stepik):
    // fmt
        Основными задачами fmt являются:
            Формирование строкового представления и, возможно, вывод в исходящий поток данных
            Сканирование значений из входящего потока данных
            Форматирование сообщений об ошибках (fmt.Errorf)

        В функциях этого пакета используются спецификаторы преобразования:  %v, %t, %b и т.д.

            Старайтесь не использовать fmt.Print, Printf, Println для отладки приложений.



    // encoding
        Пакет encoding определяет интерфейсы, общие для других пакетов, которые 
        преобразуют данные в байтовые или текстовые представления и обратно. 
        Пакеты, которые проверяют эти интерфейсы, включают например encoding/json
        и encoding/xml. В результате однократная реализация интерфейса может 
        сделать тип полезным в нескольких форматах. Стандартные типы, реализующие 
        эти интерфейсы, включают time.Time и net.IP.

        encoding/json (Подробнее: https://go.dev/blog/json)
            Пакет encoding/json реализует кодирование и декодирование для формата 
            JSON, описанного в RFC7159.
            
        MARSHAL:
            func Marshal(v interface{}) ([]byte, error)
            Функция Marshal возвращает
                -слайс байт, содержащий текстовое представление в формате JSON
                 объекта, переданного в функцию
                -ошибку, если она встретилась в процессе преобразования

            Вот таблица соответствия между типами данных Golang и JSON`
                Golang 	  |  JSON
                __________|__________
                Boolean 	Boolean
                
                Floating 
                point,      Numbers
                integer, 
                и Number 	

                String      JSON strings в формате UTF-8
                            с заменой некорректных байт 
                            на Unicode runes
                Array 
                и slice 	JSON arrays, за исключением []byte,
                            который кодируется как строка в base64
                
                Struct 	    JSON object

                Для того, чтобы представить структуру как JSON, нужно использовать специальные
                теги:

                    // Это поле структуры будет представлено в JSON объекте как "myName"
                    Field int `json:"myName"`

                    // То же самое, что и в предыдущем примере, только если поле
                    // пустое, то его не будет в JSON объекте.
                    Field int `json:"myName,omitempty"`

                    // Если не указать название поля, то будет использовано имя по умолчанию - "Field"
                    Field int `json:",omitempty"`

                    // Поле будет проигнорировано при сериализации этой структуры.
                    Field int `json:"-"`

                    // Поле будет представлено с ключом "-"
                    Field int `json:"-,"`

                    // Если указать опцию string, то поле будет представлено как UTF-8 строка JSON.
                    Int64String int64 `json:",string"

            Обратите внимание, что поля должны быть публичными, то есть иметь имя
            начинающееся с буквы верхнего регистра! В противном случае они будут
            проигнорированы в процессе сериализации.

        UNMARSHAL:
            func Unmarshal(data []byte, v interface{}) error

            Функция Unmarshal разбирает предоставленный слайс байт data в объект, 
            переданный вторым аргументом. Возвращает ошибку, если она произошла 
            в процессе разбора данных. Обычно вторым объектом передается указатель
            на тот или иной объект.

            Если попытаться разобрать объект в интерфейс, то пакет будет
            использовать следующее соответствие типов JSON типам Golang:

                JSON 	    |    Golang
                ____________|_______________
                booleans 	        bool
                numbers 	        float64
                strings 	        string
                JSON arrays 	    []interface{}
                JSON objects 	    map[string]interface{}
                null 	            nil
        
    
        encoding/xml

            Пакет encoding/xml содержит средства, позволяющие разбирать данные 
            в формате XML 1.0, а также сериализовать данные в этот формат.
        
        MARSHAL:
            func Marshal(v interface{}) ([]byte, error)
            Функция Marshal возвращает
                -слайс байт, содержащий текстовое представление объекта v в 
                формате XML
                -ошибку, если она встретилась в процессе сериализации.


            Имя XML элемента будет выбрано из следующего списка в порядке важности:
                Тег поля XMLName, если данные это структура
                Значение поля XMLName типа xml.Name
                Значение тега поля
                Название поля структуры
                Название типа, который сериализуется

            Элемент XML для структуры содержит упорядоченные элементы для каждого
            из экспортируемых полей структуры, за исключением следующих:
                Поле с тегом "-" будет пропущено.
                Поле с тегом "name,attr" станет атрибутом с заданным именем 
                    в элементе XML
                Поле с тегом ",chardata" будет записано как символьные данные, 
                    а не XML элемент.
                Поле с тегом ",cdata" будет записано как символьные данные,
                    обернутые в один или несколько тегов , не как XML-элемент.
                Поле с тегом ",innerxml" будет записано дословно, без каких либо
                    преобразований.
                Поле с тегом ",comment" будет записано как XML комментарий, без
                    каких либо преобразований. Это поле не должно содержать
                    строку, содержащую "--" внутри себя.
                Поле с тегом, содержащим опцию "omitempty" будет пропущено, 
                    если оно содержит пустое значение. Пустые значения это false,
                    0, любой nil указатель или интерфейс, а также любые массивы, 
                    слайсы, отображения или строки нулевой длины.
                Анонимное поле структуры обрабатывается так, как если бы поля 
                    его значения были частью внешней структуры.
                Поле, содержащее структуру, которая имплементирует интерфейс
                    Marshaler, будет записано путем вызова его метода MarshalXML.
                Поле, содержащее структуру которая, имплементирует интерфейс 
                    encoding.TextMarshaler, будет записано путем вызова его 
                    MarshalText в виде текста.

            Если в поле используется тег a>b>c, то элемент c будет вложен 
            в родительские элементы a и b. Поля, которые отображаются рядом
            друг с другом и которые называют одного и того же родителя, будут
            заключены в один XML-элемент.

        UNMARSHAL:

        func Unmarshal(data []byte, v interface{}) error
        По аналогии с рассмотренным ранее пакетом json, функция xml.Unmarshal 
        разбирает предоставленный слайс байт data в объект, переданный вторым 
        аргументом.


    // io
    Пакет io предоставляет базовые интерфейсы для примитивов ввода-вывода.
    Обратите внимание, что поскольку эти интерфейсы и примитивы используют
    низкоуровневые операции с различными реализациями, не стоит предполагать, 
    что они безопасны для параллельного выполнения, конечно, если об ином явно 
    не сказано в документации.

    Интерфейсы:
        -Reader
            Сигнатура интерфейса Reader выглядит вот так:

            type Reader interface {
                Read(p []byte) (n int, err error)
            }

            Read считывает до len(p) байтов в слайс байт p. 
            Он возвращает количество прочитанных байтов и ошибку, 
            если она произошла в процессе чтения. Даже если Read 
            возвращает n < len(p) байт, он может использовать 
            все p байт в качестве пустого места во время вызова.
        
        -Writer
            Сигнатура интерфейса Writer выглядит вот так:

            type Writer interface {
                Write(p []byte) (n int, err error)
            }

            Write записывает len(p) байт из слайса байт p в базовый
            поток данных. Он возвращает количество байт, записанных
            из p и любую обнаруженную ошибку, которая привела 
            к преждевременной остановке записи. Write должна возвращать
            ненулевую ошибку, если она возвращает n < len(p) байт. 
            Write не должна изменять данные среза, даже временно.

        -Closer
            Интерфейс Closer закрывает поток данных, для которого определен.
            Он имеет следующую сигнатуру:

            type Closer interface {
                Close() error
            }

        -ReadWriteCloser
            Объединением троих выше рассмотренных интерфейсов 
            является ReadWriteCloser.

            type ReadWriteCloser interface {
                Reader
                Writer
                Closer
            }

        Функции
            В пакете содержится ряд полезных функция для работы с интерфейсами,
            описанными выше.
            
            -Copy
                func Copy(dst Writer, src Reader) (written int64, err error)

                Функция Copy копирует данные из объекта src в объект dst,
                используя для этого определенные в этих объектах 
                функции Read и Write соответственно; 
                Возвращает количество записанных байт и ошибку, 
                если она встретилась в процессе записи.
            
            -ReadAll
                func ReadAll(r Reader) ([]byte, error)

                Функция ReadAll читает все доступные данные из объекта r,
                который должен реализовать интерфейс Reader. Возвращает слайс 
                байт, содержащий данные и ошибку, если она встретилась в 
                процессе чтения.

                Пример того, как io.Writer используется при записи данных 
                в файл в Go:

                func main() {
                    f, err := os.OpenFile("/tmp/123.txt", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0600)
                    if err != nil {
                        panic(err)
                    }
                    defer f.Close()

                    n, err := f.Write([]byte("writing some data into a file"))
                    if err != nil {
                        panic(err)
                    }
                    fmt.Printf("wrote %d bytes", n)
                }

            os.File является реализацией интерфейса io.Writer, который используется
            для записи байтового среза в поток данных файла. Вот так определен 
            тип os.File.Write:

                func (f *File) Write(b []byte) (n int, err error)


    // time 
        Пакет time предоставляет возможности для измерения и отображения времени.
        Все расчёты, связанные с календарём, всегда предполагают 
        григорианский календарь без високосных секунд.
        
        Объект Time
            Объект Time является отображением момента времени с точностью 
            до наносекунды.
            Обычно объект Time передается как значение, а не как указатель. 
            Иными словами, если ваша функция принимает этот объект как один из своих 
            аргументов, то это должен быть time.Time, а не *time.Time.

            Можно сравнить экземпляры объекта, используя методы Before, After и Equal.
            Метод Sub вычитывает свой аргумент из исходного объекта и создает объект
            Duration (продолжительность). Метод Add прибавляет к объекту продолжительность
            и делает новый объект Time.
            Значением по умолчанию для объекта Time является January 1, year 1, 
            00:00:00.000000000 UTC. Вряд ли в реальном коде когда-либо встретится эта
            дата, тем не менее существует метод IsZero, который позволит определить 
            это точно.
        
        Layout
            В пакете time важной является константа Layout:
            01/02 03:04:05PM '06 -0700
            Дело в том, что она используется как для форматирования вывода объекта Time,
            так и для, например, разбора строки, содержащей преобразование даты в 
            объект Time. В более привычном для нас виде её можно представить вот так:
                
                Mon Jan 2 15:04:05 MST 2006

            На самом деле запомнить её достаточно просто. Если вы посмотрите на
            классическое представление, то увидите, что логика этой даты - это
            прибавлять +1 к предыдущему значению. Первый месяц, второе число, 
            три часа, четыре минуты и так далее. Сложность лишь в перепутанных на американский манер, с нашей точки зрения, месяце и дне.

            Вот примеры преобразования строки к объекту time.Time и наоборот:

            const longForm = "Jan 2, 2006 at 3:04pm (MST)"
            t, _ := time.Parse(longForm, "Feb 3, 2013 at 7:54pm (PST)")

            const shortForm = "2006-Jan-02"
            t, _ = time.Parse(shortForm, "2013-Feb-03")

            Здесь константы содержат шаблон, взятый из константы Layout, а вторым
            аргументом передаётся строка, которую требуется преобразовать в объект Time.

            Метод Format принимает шаблон и возвращает строку:
            fmt.Println("Unix format:", t.Format(time.UnixDate))
            fmt.Println("Custom format", t.Format("Jan 2, 2006 at 3:04pm (MST)"))

        Объект Duration
            Объект Duration представляет из себя разницу между двумя объектами Time
            с точностью до наносекунд в виде числа (int64).

            t0 := time.Now()
            // Прошло сколько-то времени
            t1 := time.Now()
            fmt.Print("Сколько времени прошло между t1 и t0", t1.Sub(t0))

            Duration можно получить путём разбора строки, содержащей его текстовое
            представление. Это достигается с помощью функции time.ParseDuration 
            К сожалению, здесь нет шаблонов, и можно использовать лишь следующие 
            заранее определенные значения: "ns", "us" или "µs", "ms", "s", "m", "h".

            Например:
            hours, _ := time.ParseDuration("10h")
            complex, _ := time.ParseDuration("1h10m10s")

            fmt.Println(hours) //10h0m0s
            fmt.Println(complex) //1h10m10s
            fmt.Printf("There are %.0f seconds in %v.\n", complex.Seconds(), 
                complex) //There are 4210 seconds in 1h10m10s.

        Конкурентность
            Пакет time также содержит ряд объектов и методов, которые применяются 
            при конкурентном программировании в Golang.

            Например,
                time.After
                time.Tick
                Тип Ticker
                Тип Timer

    
    net/http
        В любом даже маленьком проекте, использующем протокол HTTP для передачи данных,
        понадобится пакет net/http. В нем содержатся все самые необходимые реализации
        интерфейсов для работы с протоколами HTTP, HTTPS, создания запросов и обработки
        ответов, настройки клиентов и серверов. Знание абстракций этого пакета существенно
        упрощает разработку сетевых взаимодействий приложений.

        Оригинальная документация пакета достаточно обширна, поэтому для начала
        предлагаем ознакомиться только с некоторыми типами, которые используются 
        чаще всего:

            Transport   https://pkg.go.dev/net/http#Transport
            Server      https://pkg.go.dev/net/http#Server
            ServeMux    ...
            Handler
            Client
            Request
            Response

    
    
    errors
        Этот пакет реализует функции для управления ошибками.
        Функция New создает ошибки, единственным содержанием которых является
        текстовое сообщение.
        Функции Unwrap, Is и As работают с ошибками, которые могут оборачивать другие
        ошибки. Ошибка завершает другую ошибку, если ее тип имеет метод:

            Unwrap() error

        Простой способ создать обернутые ошибки - вызвать fmt.Errorf и применить 
        спецификатор преобразования %w к аргументу ошибки:

            errors.Unwrap(fmt.Errorf("... %w ...", ..., err, ...))

        Is последовательно разворачивает свой первый аргумент в поисках ошибки, 
        соответствующей второму и сообщает о том, нашла ли она совпадение. 
        Её следует использовать вместо простых проверок равенства. 
        
        Вместо

            if err == fs.ErrExist

        лучше сделать так:

            if errors.Is(err, fs.ErrExist)

        Потому что второе будет успешным, если err оборачивает fs.ErrExist.

        As разворачивает свой первый аргумент, последовательно ища ошибку, 
        которую можно присвоить второму аргументу-указателю. В случае успеха она 
        выполняет присвоение и возвращает значение true. В противном случае 
        возвращается false. Предпочтительнее вызвать As:

        var perr *fs.PathError
        if errors.As(err, &perr) {
            fmt.Println(perr.Path)
        }

        вместо

        if perr, ok := err.(*fs.PathError); ok {
            fmt.Println(perr.Path)
        }

        потому что второе будет успешным, если err оборачивает *fs.PathError.

        Пример:

        // MyError is an error implementation that includes a time and message.
        type MyError struct {
            When time.Time
            What string
        }

        func (e MyError) Error() string {
            return fmt.Sprintf("%v: %v", e.When, e.What)
        }

        func oops() error {
            return MyError{
                time.Date(1989, 3, 15, 22, 30, 0, 0, time.UTC),
                "the file system has gone away",
            }
        }

        func main() {
            if err := oops(); err != nil {
                fmt.Println(err)
            }
        }







МИКРОСЕРВИСЫ vs МОНОЛИТ

    Минусы монолтиа:
        Сложно разрабатывать разнородную функциональность.
        Сложно организовать работу разных команд.
        Каждое изменение требует полного переразвёртывания.
        Зависимость от постепенно устаревающего стека.
        Зависимость от единственного физического узла.
        Невозможно масштабировать функциональность отдельно.

    Плюсы микросервисов:
        Делает возможными непрерывную доставку и развертывание крупных, сложных систем.
        Код небольшой и простой в обслуживании.
        Независимое развертывание.
        Независимое масштабирование.
        Автономность команд разработки.
        Позволяет экспериментировать с технологиями.
        Лучшая изоляция неполадок.
    Минусы микросервисовЖ
        Сложно подобрать подходящее разбиение на сервисы.
        Сложность распределенных систем затрудняет разработку, тестирование и развертывание.
        Развертывание функциональности, охватывающей несколько сервисов, требует тщательной координации.
        Сложно определить момент, когда переход на микросервисы станет обоснованным.


Подробнее о JWT
    JSON Web Tokens — это открытый стандарт RFC 7519 для создания токенов доступа.
    JWT используется в передаче данных для аутентификации в клиент-серверных приложениях.
    В обычных небольших веб-приложениях легко идентифицировать пользователей с помощью 
    сессий, но в микросервисной архитектуре и при высокой нагрузке сессии становятся
    малопригодными для использования. С помощью JWT мы можем создать уникальный токен 
    для каждого аутентифицированного пользователя. Этот токен будет содержать необходимую
    информацию о пользователе и будет включён в заголовок последующего запроса к API. 
    Этот метод позволяет идентифицировать всех пользователей, которые выполняют 
    вызовы API.

    Давайте начнем с разбора самого JWT токена. Его содержимое представляет из себя 
    ascii-строку, благодаря чему, может быть использован в качестве значения куки. 
    По спецификации он содержит 3 блока: заголовки, набор кастомных полей (claims) 
    и подпись, которые разделены через точку. Набор полей (claims) содержит произвольные
    пары имя/значения, однако стоит учитывать, что стандарт JWT имеет несколько 
    зарезервированных имен. Первые два блока представлены в JSON-формате и 
    дополнительно закодированы в формат base64. Подпись же вычисляется на основе 
    первых двух блоков с помощью их хеширования по заданному в заголовке алгоритму, 
    используя секретный ключ. Этим ключом также должен обладать и сервер, который 
    впоследствии будет валидировать токен. Для валидации сервер выполняет тот же 
    алгоритм калькуляции хеша подписи, и если они совпадают, считает токен валидным


Утечки памяти (memory leaks)
    Утечки памяти (или давление памяти) могут принимать разные формы. Причина 
    возникновения утечек может крыться как в неверной реализации, так и в некорректном 
    проектировании системы.

    Важно выстроить систему, которая позволит сначала написать простой рабочий, но 
    неоптимизированный код, а уже затем улучшить производительность. Вот некоторые 
    распространённые примеры возникновения проблем с памятью:

        слишком большое количество выделений памяти, неверное представление данных
        интенсивное использование рефлексии или строк
        использование глобальных переменных
        «осиротевшие», бесконечные горутины


Профилирование
    Профилирование – это важная часть разработки и поддержки приложения. С его помощью
    можно найти узкие места, которые нагружают ЦПУ и оперативную память.

    В golang существует утилита go tool pprof, которая вместе с пакетом 
    "net/http/pprof" позволяет увидеть общую картину выполнения приложения.
    Встраивание профилировщика в приложение производится с помощью пакета 
    "net/http/pprof", который предоставляет набор профилей для анализа в виде 
    http-обработчиков (handler):

    import "net/http/pprof"

    <...>
        r := chi.NewRouter()
        r.Mount("/debug", Profiler())
    <...>

    func Profiler() http.Handler {
        r := chi.NewRouter()

        r.Get("/", func(w http.ResponseWriter, r *http.Request) {
        http.Redirect(w, r, r.RequestURI+"/pprof/", http.StatusMovedPermanently)
        })
        r.HandleFunc("/pprof", func(w http.ResponseWriter, r *http.Request) {
        http.Redirect(w, r, r.RequestURI+"/", http.StatusMovedPermanently)
        })

        // Получение списка всех профилей
        r.HandleFunc("/pprof/*", pprof.Index)
        // Отображение строки запуска (например: /go-observability-course/examples/caching/redis/__debug_bin)
        r.HandleFunc("/pprof/cmdline", pprof.Cmdline)
        // профиль ЦПУ, в query-параметрах можно указать seconds со значением времени в секундах для снимка (по-умолчанию 30с)
        r.HandleFunc("/pprof/profile", pprof.Profile)
        r.HandleFunc("/pprof/symbol", pprof.Symbol)
        // профиль для получения трассировки (последовательности инструкций) выполнения приложения за время seconds из query-параметров ( по-умолчанию 1с)
        r.HandleFunc("/pprof/trace", pprof.Trace)

        <...>

        return r
    }

    Запуск профиля ЦПУ
        Перед запуском go tool pprof нужно нагрузить программу.
        Сразу после предыдущей команды запускаем go tool pprof:

        go tool pprof http://localhost:9000/debug/pprof/profile\?seconds\=5
        Fetching profile over HTTP from http://localhost:9000/debug/pprof/profile?seconds=5
        Saved profile in /Users/nshibalov/pprof/pprof.samples.cpu.011.pb.gz
        Type: cpu
        Time: Aug 21, 2021 at 8:54pm (MSK)
        Duration: 5.20s, Total samples = 8.74s (168.15%)
        Entering interactive mode (type "help" for commands, "o" for options)
        (pprof)  

        В открывшемся приложении есть консоль. Для того чтобы увидеть граф вызовов, 
        надо выполнить команду web, после чего откроется браузер с графом:

        (pprof) web

        На данном графе видно название функций и время затраченное в них. Чтобы получить
        более детальную информацию, можно выполнить команду weblist с именем функции,
        например:

        (pprof) weblist GetUserArticles
        (pprof) 

        Ещё одна очень полезная команда top -cum. Она показывает функции, отсортированные
        по максимальному времени использования ЦПУ
    
    Запуск профиля аллокаций памяти
        go tool pprof http://localhost:9000/debug/pprof/heap
        Fetching profile over HTTP from http://localhost:9000/debug/pprof/heap
        Saved profile in /Users/nshibalov/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.003.pb.gz
        Type: inuse_space
        Time: Aug 21, 2021 at 9:29pm (MSK)
        Entering interactive mode (type "help" for commands, "o" for options)
        (pprof) web



Распределенная трассировка
    Часто для решения сложных проблем и понимания слабых мест в микросервисной 
    архитектуре бывает недостаточно мониторинга её отдельных элементов. Тогда 
    необходимо получать информацию о взаимодействии между сервисами. Например, о 
    топологии запросов и задержках сети, об узких местах производительности, о 
    контексте расследуемых ошибок. Для решения подобных задач мы обращаемся к 
    распределённой трассировке. Распределённая трассировка — это процесс отслеживания 
    и сбора информации взаимодействиях внутри стека. По её итогу мы получаем путь, 
    время, которое занял каждый вызов, и задержку ответа.

    Зачем нужна распределённая трассировка:
        найти узкие места в производительности
        визуализировать последовательности вызовов
        собрать информацию для дальнейшего анализа

    Единица информации распределённой трассировки — span. Это описание рабочего 
    процесса, которое обычно содержит имя, время начала и окончания, уникальный ID
    и теги.
    
    OpenTracing, OpenCensus, OpenTelemetry
        OpenTracing библиотека, стандартизирующая процесс добавления распределённой 
        трассировки запросов в ваше приложение. Это слой абстракции над существующими 
        решениями, такими как Jaeger, Zipkin, Lightstep и другие. OpenCensus содержит
        библиотеки для нескольких языков, которые позволяют захватывать, обрабатывать 
        и перенаправлять метрики и трейсы. С недавнего времени OpenTracing и OpenCensus 
        слились в единый проект OpenTelemetry, имеющий обратную совместимость. 
        OpenTelemetry — это набор API, SDK, инструментов и интеграций для управления 
        данными телеметрии. OpenTelemetry предоставляет: единую, не зависящую от 
        производителя инструментальную библиотеку для каждого языка, сквозную реализацию
         для генерации, передачи, сбора, обработки и экспорта данных телеметрии, 
         полный контроль над данными с возможностью их параллельной отправки в разные 
         бэкенды. Обе библиотеки в Go используют контекст (context.Context) для хранения
         спанов с трассировочной информацией, благодаря чему очень легко создать новый 
         спан. Пример для OpenCensus:

        ctx, span := trace.StartSpan(ctx, "doWork")
        defer span.End()

    Jaeger
        Jaeger - это распределённая система отслеживания (трассировки), выпущенная 
        компанией Uber Technologies. Является реализацией стандарта OpenTracing.

        Jaeger был вдохновлён Dapper и OpenZipkin, написан на Go и является частью 
        CNCF (Cloud Native Computing Foundation).

        Архитектура (на примере прямой работы с БД):
        https://drive.google.com/file/d/1WuwpiIpx8t74IVXKyrKgr3ZUb8zZtG-S/view?usp=sharing
        Для БД Jaeger рекомендует Elasticsearch вместо Cassandra, поскольку у неё 
        ограниченная функциональность по поиску.

        Span
        Span - представляет собой логическую единицу в Jaeger, у которой есть имя
        операции, время начала операции и продолжительность. Span'ы могут быть 
        вложенными и упорядоченными для моделирования причинно-следственных связей.
        https://drive.google.com/file/d/1WuwpiIpx8t74IVXKyrKgr3ZUb8zZtG-S/view?usp=sharing

        Trace (Трассировка) - это путь данных / выполнения в системе, который можно 
        рассматривать как ориентированный ациклический граф span'ов.
        
        Взаимодействие с кодом
        Сервис (приложение) создает span'ы при получении новых запросов и прикрепляет
        контекстную информацию (идентификатор трассировки, идентификатор span'а и 
        мета-данные, которые определяются пользователем) к исходящим запросам. 
        С запросами распространяются только идентификаторы и мета-данные; все остальные 
        данные профилирования, такие как имя операции, время, теги и логи, не передаются. 
        Вместо этого они передаются из процесса в серверную часть Jaeger асинхронно в 
        фоновом режиме.

        Поскольку приложение обычно сильно нагружено, для уменьшения накладных расходов 
        применяется выборка (сэмплирование, sampling). По умолчанию собирается 
        только 0.1% trace'ов, но существуют и другие стратегии.

        UI, главное окно Jaeger:
        https://drive.google.com/file/d/1WuwpiIpx8t74IVXKyrKgr3ZUb8zZtG-S/view?usp=sharing
        
        Окно трейса (развернуто):
        https://drive.google.com/file/d/1WuwpiIpx8t74IVXKyrKgr3ZUb8zZtG-S/view?usp=sharing



Настройка Kubernetes (k8s) MTS
    Как подключиться к CloudMTS для выполнения заданий.

        Установить себе kubectl (Официальная документация)
        Проверяем, что kubectl готов к работе:

            # при успешном выполнении вы увидите версию установленного kubectl. 
            kubectl version --client

        3. В зависимости от вашей операционной системы помещаем конфиг, который мы
        пришлем вам, в нужную директорию:

            linux/macOS: ~/.kube/

            windows: %USERPROFILE%/.kube

        Важно! Конфиг должен иметь имя config и не иметь расширения

            cp ~/Downloads/<user>-kubeconfig ~/.kube/config

            ls -la ~/.kube/config

        4. Установим namespace:

            # Просмотр доступных namespace
            kubectl get ns

            # Установка namespace в конфиге
            kubectl config set-context --current --namespace=<namespace>

        5. Проверяем, что вам доступен ваш namespace:

            # Создадим тестовый deployment
            kubectl create deployment --image=nginx nginx-app
            # при успешном выполнении вы увидите: deployment.apps/nginx-app created

            # Удалим тестовый deployment
            kubectl delete deployment nginx-app
            # при успешном выполнении вы увидите: deployment.apps "nginx-app" deleted

        Deploy
        В рамках курса мы хотим максимально автоматизировать нашу работу. Для того, 
        чтобы не тратить время и силы на окружение и деплой, мы постараемся использовать
        CI инструменты.

        Для создания CI необходимо:
        1. В своей подгруппе создать токен с правами на чтение репозитория 
            (Gitlab->settings->repository->Deploy Tokens).

            Заполняем имя токена, может быть любым
            Выбираем read_repository
            Выбираем read_registry
            Выбираем read_package_registry

        2. Дальше полученный токен нужно применить в кластере. Нужно, чтобы текущий 
        контекст был кластера teta и вашего namespace.

            kubectl create secret docker-registry regcred --docker-server=registry.gitlab.com --docker-username=<Your new Deploy Token username> --docker-password=<Use this token as a password> --docker-email=<email>
            kubectl patch serviceaccount default -p '{"imagePullSecrets": [{"name": "regcred"}]}'

        3. Отлично! Мы готовы деплоить.
        4. Создадим Dockerfile в корнях каждого проекта:

            FROM golang:1.17.1-alpine as builder
            WORKDIR /build

            COPY . /build/
            RUN CGO_ENABLED=0 GOOS=linux go build -a -o auth ./cmd
            RUN go mod download

            # generate clean, final image for end users
            FROM alpine:3.11.3
            COPY --from=builder /build/auth /auth

            # executable
            ENTRYPOINT [ "/auth" ]

            auth нужно поменять на имя вашего приложения.

        5. Также в корнях проектов создаем файл .gitlab-ci.yml, который содержит 
        описания стадий СI:

            stages:
            - test
            - build
            - image
            - deploy

            test:
            image:
                name: golang:1.17.1-stretch
            stage: test
            script:
                - go test -v ./...

            build image:
            image:
                name: gcr.io/kaniko-project/executor:v1.6.0-debug
                entrypoint: [""]
            stage: build
            needs: []
            variables:
                CONTEXT: $CI_PROJECT_DIR
                DOCKERFILE: $CI_PROJECT_DIR/Dockerfile
                PREFIX: ""
            script:
                - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > /kaniko/.docker/config.json
                - /kaniko/executor --context $CONTEXT --dockerfile $DOCKERFILE --destination ${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME} --cache=true --cache-ttl=120h

            .image_deploy:
            image: 
                name: lachlanevenson/k8s-kubectl:v1.22.0
                entrypoint: [""]
            stage: deploy
            when: manual
            needs:
                - build image
            script:
                - export K8S_WORKLOAD_TYPE=deployment
                - export K8S_WORKLOAD_NAME=$CI_PROJECT_NAME
                - export K8S_CONTAINER_NAME=$CI_PROJECT_NAME
                - export K8S_NS=$(echo $CI_PROJECT_PATH | awk -F\/ '{print $(NF-1)}')
                - echo "Deploy $K8S_WORKLOAD_TYPE $K8S_WORKLOAD_NAME to namespace $K8S_NS"
                - kubectl create deployment $K8S_WORKLOAD_NAME --image=$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME -n ${K8S_NS} || echo deployment already exists
                - kubectl --record ${K8S_WORKLOAD_TYPE}.apps/${K8S_WORKLOAD_NAME} set image ${K8S_WORKLOAD_TYPE}.v1.apps/${K8S_WORKLOAD_NAME} ${K8S_CONTAINER_NAME}=$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME -n ${K8S_NS}
                - kubectl rollout restart ${K8S_WORKLOAD_TYPE} ${K8S_WORKLOAD_NAME} -n ${K8S_NS} 
                - kubectl rollout status ${K8S_WORKLOAD_TYPE} ${K8S_WORKLOAD_NAME} -n ${K8S_NS} --timeout=60s

            deploy staging:
            extends: .image_deploy
            when: always
            only:
                - main

            6. Делаем push и наблюдаем, как запустится CI.
