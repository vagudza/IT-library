В последние десятилетия Сервис-ориентированная архитектура (SOA) сильно эволюционировала. 
Благодаря неэффективности прежних решений и развитию технологий сегодня мы пришли к микросервисной архитектуре.
Эволюция шла по классическому пути: сложные проблемы разбивались на более мелкие, простые в решении.


Что, по твоему, такое микросервисы?
    Микрослужба — это веб-служба, отвечающая за один элемент логики в некой предметной области. 
    Микрослужбы взаимодействуют друг с другом через простые сетевые протоколы, например REST, и совместно 
    выполняют некоторые действия, но при этом ни одна из них не имеет сведений о внутреннем устройстве других 
    служб. Такое согласованное взаимодействие между микрослужбами называется архитектурой микрослужб.

    Основной принцип микросервисной архитектуры — создание приложения путем разделения компонентов его бизнес-логики 
    на небольшие сервисы, которые можно развертывать и использовать независимо друг от друга.

    При таком подходе разработчики могут разделиться на небольшие команды и работать над разными службами, использовать 
    разные стеки технологий и независимо выполнять развертывание. Такое разделение интересов и независимая эксплуатация 
    позволяют использовать оптимизированные agile-подходы к разработке ПО, например непрерывную поставку и интеграцию.



Сэм Ньюман, автор Building Microservices, выделяет восемь принципов микросервисной архитектуры. Это:

    Проектирование сервисов вокруг бизнес-доменов
        Это может дать нам стабильные интерфейсы, высокосвязные и мало зависящие друг от друга модули кода, а также чётко определённые 
        разграниченные контексты.
    Культура автоматизации
        Это даст нам гораздо больше свободы, мы сможем развернуть больше модулей.
    Скрытие подробностей реализации
        Это позволяет сервисам развиваться независимо друг от друга.
    Полная децентрализация
        Децентрализуйте принятие решений и архитектурные концепции, предоставьте командам автономность, чтобы компания сама превратилась 
        в сложную адаптивную систему, способную быстро приспосабливаться к переменам.
    Независимое развёртывание
        Можно развёртывать новую версию сервиса, не меняя ничего другого.
    Сначала потребитель
        Сервис должен быть простым в использовании, в том числе другими сервисами.
    Изолирование сбоев
        Если один сервис падает, другие продолжают работать, это делает всю систему устойчивой к сбоям.
    Удобство мониторинга
        В системе много компонентов, поэтому трудно уследить за всем, что в ней происходит. Нам нужны сложные инструменты мониторинга, 
        позволяющие заглянуть в каждый уголок системы и отследить любую цепочку событий.





Монолиты VS микросервисы
    Микросервисное приложение представляет собой набор изолированных сервисов, каждый из которых имеет 
    свой источник данных (БД) и выполняет конкретную задачу (реализуют принцип единой ответственности SOLID)

    Микрослужбы разделяют крупные задачи, характерные для конкретного бизнеса, на несколько независимых баз кода. 
    Монолитная архитектура приложений является противоположностью микрослужб. Монолит — это единая база кода, в которой 
    объединены все бизнес-задачи. Использовать монолиты удобно на начальных этапах проектов для сокращения умственных 
    усилий по управлению кодом и облегчения развертывания. Это позволяет сразу выпускать все, что есть в монолитном приложении.

    Многие проекты начинаются как монолитные, а затем, по мере развития, переходят к архитектуре микрослужб. По мере добавления 
    в монолитный проект новых возможностей рано или поздно возникают сложности при работе нескольких разработчиков с единой базой 
    кода. Учащаются конфликты в коде и увеличивается риск того, что при обновлении одной возможности появятся баги в другой, 
    несвязанной возможности. Если такие нежелательные ситуации возникают, возможно, настало время обсудить переход на микрослужбы.
    Переходить с монолита на микросервис нужно тогда, когда этого требует текущая задача и текущее монолитное решение
    не удовлетворяет условиям задачи.


   

    Микросервисы общаются между собой по сети (http, grpc или другие протоколы), и само бизнес-приложение
    представляет собой набор микросервисов, взаимодействующих между собой. Каждый микросервис имеет 
    интерфейс (API), с помощью которого с ним взаимодействуют другие микросервисы.

    Микросервисы поддерживают горизонтальное масштабирование путем клонирования инстансов.



    Плюсы монолита:
        1 простота первоначальной разработки
        2 проще развертывать и мониторить
        3 бизнес логика вся в одном месте 
        4 поскольку вся обработка данных проводится в одном месте, в монолитных прилоениях менее 
        заментно влияние сетевых задержек

    Минусы монолтиа:
        1 приложение имеет единый, выбранный в начале разработки стек технологий, и изменить его
            крайне сложно
        2 невозможно масштабиовать отдельные части приложения - дл масштабирования необходимо 
            запускать дополнительные процессы со всем приложением
        3 по мере увеличения кодовой базы становится невозмоным полностью знать все части приложения
        4 появляются зависимости между отдельными частями приложений - внесение изменений в одни части
            может неожиданно затронуть другие
        5 при внесении изменений необходимо заново развертывать все приложение 
        6 при сбое в какой-либо части монолитного приложения все приложение выйдет из строя

        Сложно разрабатывать разнородную функциональность.
        Сложно организовать работу разных команд.
        Каждое изменение требует полного переразвёртывания.
        Зависимость от постепенно устаревающего стека (лучше сравнивать не по "модно-молодежно", а по 
        удовлетворению требованиям используемой либы. Стоит использовать наиболее эффективную, а не современную 
        технологию).
        Зависимость от единственного физического узла.
        Невозможно масштабировать функциональность отдельно.

    Плюсы микросервисов:
        1 независимая работа команд, что позволяет использовать наиболее подходящие для задачи инструменты
        2 в кодовой базе микросервиса проще разобраться, чем в кодовой базе монолитного приложения
        3 горизонтальное масштабирование - нам надо увеличить лишь число тех микросервисов, которые не справляются 
            с нагрузкой
        4 при внесении изменений в микросервис необходимо заново развернуть только его - остальные микросервисы не 
            будут затронуты (если не менялись контракты по обмену сообщениями между микросервисами)
        5 При выходе микросервиса из строя все остальные продолжат работать (хотя могу возвращать ошибки, если взаимодействуют 
            с вышедшим из строя микросервисом)
        6 Более пристальное внимание к качеству
        7 Независимость набора технологий, развёртывания и масштабируемости сервисов. 
        8 Стандартный, простой и надёжный канал связи (передача текста по HTTP через порт 80).
        9 Оптимизированный обмен сообщениями.
        10 Изолированность контекстов домена (Domain contexts). 
        11 Простота подключения и отключения сервисов.
        12 Позволяет экспериментировать с технологиями.
        13 Лучшая изоляция неполадок.
        14 Простота подключения и отключения сервисов.
        15 Синхронность обмена сообщениями помогает управлять производительностью системы.
        16 Полностью независимые и автономные сервисы.
        17 Бизнес-логика хранится только в сервисах.
        18 Позволяют компании превратиться в сложную адаптивную систему, состоящую из нескольких маленьких автономных частей/команд, 
        способную быстро адаптироваться к переменам. 

    
    Минусы микросервисов:
        !!! Высокая сложность эксплуатации:
            1 когда сервисов становится слишком много, может быть сложно найти, какой функционал уже 
                был реализован и какой микросервис можно переиспользовать
            2 микросервисные приложения сложнее разворачивать и мигрировать - необходимо распределять нагрузку 
                между ними, микросервисы должны находить другие, даже после того, как те перезапускаются,
                учитывать одновременное одновременное использование старых и новых структур данных
            3 сложнее мониторить все приложение в целом и отдельные бизнес-функции
            4 появляется дополнительная сетевая задержка при общении между микросервисами.
                Работоспособность сильно зависит от состояния сети.
            5 сложнее обеспечивать согласованность данных (ACID, Consistency), так как у каждого микросервиса может быть 
                своя база данных
            6 экспоненциально растущие расходы на инфраструктуру (отдельные расходы на комплект тестов, инструкции по развертыванию, инфраструктуру 
                хостинга, инструменты мониторинга и т. д.)
            7 развертывание функциональности, охватывающей несколько сервисов, требует тщательной координации

            Сложно подобрать подходящее разбиение на сервисы.
            Сложность распределенных систем затрудняет разработку, тестирование и развертывание.
            Сложно определить момент, когда переход на микросервисы станет обоснованным.
            
            Нужно много вложить в сильную DevOps-культуру.
            Использование многочисленных технологий и библиотек может выйти из-под контроля.
            Нужно аккуратно управлять изменениями входных/выходных API, потому что эти интерфейсы будут использовать многие приложения.
            Использование «согласованности в конечном счёте» (eventual consistency) может привести к серьёзным последствиям, которые нужно учитывать при разработке приложения, от бэкенда до UX.
            Тестирование усложняется, потому что изменения в интерфейсе могут непредсказуемо влиять на другие сервисы.



    Общение микросервисов
        GRPC - фреймворк для вызова удаленных процедур (Google)
        Grpc использует http2, в качестве транспорта и protobuf для сериализации данных
        Для нескольких параллельных запросов используется единственное TCP соединение.
        Запросы внутри соединения не блокируют друг друга.
        Protobuf в отличие, например, от JSON не имеет накладных расходов на синтаксис. А также передается в 
        бинарном виде, что сокращает итоговый размер сообщения

        -За счет http2 и protobuf быстрый и легковесный по сравнению с HTTP1, REST, JSON, XML и т.д.
        -Возможность потоковой передачи сообщений (grpc streaming)
        -Имеет один источник правды в виде proto-файла
        ...
        НО! для фронтенда все еще актуален REST. Лучшая практика - использовать OpenAPI

    Общение микросервисов: 2 phase commit
    ACID требование - изменение в одном экземпляре микросервиса, ... реализовать как атомарное
    Распределенная транзакция - это одновмерменная модификация ...





МОДЕЛИ РАСПРЕДЕЛЕННЫХ ВЫЧИСЛЕНИЙ
    MapReduce - модель распределённых вычислений, представленная компанией Google, используемая для параллельных 
    вычислений над очень большими, вплоть до нескольких петабайт, наборами данных в компьютерных кластерах.     

    MapReduce можно по праву назвать главной технологией Big Data, т.к. она изначально ориентирована на параллельные 
    вычисления в распределенных кластерах. Суть MapReduce состоит в разделении информационного массива на части, 
    параллельной обработки каждой части на отдельном узле и финального объединения всех результатов.   

    Программы, использующие MapReduce, автоматически распараллеливаются и исполняются на распределенных узлах кластера, 
    при этом исполнительная система сама заботится о деталях реализации (разбиение входных данных на части, разделение 
    задач по узлам кластера, обработка сбоев и сообщение между распределенными компьютерами). 

    Работа MapReduce состоит из двух шагов: Map и Reduce, названных так по аналогии с одноименными функциями высшего 
    порядка, map и reduce.
        -На Map-шаге происходит предварительная обработка входных данных. Для этого один из компьютеров (называемый главным 
        узлом — master node) получает входные данные задачи, разделяет их на части и передает другим компьютерам (рабочим 
        узлам — worker node) для предварительной обработки.

        -На Reduce-шаге происходит свёртка предварительно обработанных данных. Главный узел получает ответы от рабочих узлов 
        и на их основе формирует результат — решение задачи, которая изначально формулировалась. 



TODO: 
    алгоритмы обеспечения консистентности такие как Paxos или Raft
    распределенная транзакция (https://habr.com/ru/companies/otus/articles/516720/)
    механизмов обеспечения распределенных транзакций: двухфазный коммит или сагу
    Один из лучших способов решить проблему распределенных транзакций между микросервисами — это полностью их избежать.


    CAP теорема

    Consistency (согласованность данных) — во всех узлах в один момент времени данные одинаковые (БД или ее реплика).
    Availability (доступность) — в любой момент времени при обращении к БД мы хотим чтобы она всегда отвечала нам (24 на 7).
    Partition tolerance (устойчивость к разделению) — разбиение большой БД на несколько мелких не нарушает нашу работу никаким образом.
    CAP теорема говорит нам о том, что в любой реализации распределенных вычислений возможно обеспечить лишь 2 из этих 3 свойств!


    ACID

Теперь давайте вспомним что такое ACID из понятия реляционных БД.

    Atomicity — атомарность гарантирует, что каждый запрос в транзакции будет выполнен успешно, либо в случае ошибки вообще
     не будет выполнен. Т.е. транзакция выполняется либо полностью вся, либо нет. Частичного выполнения быть не может.
    Consistency — консистентность (согласованность) даёт гарантию того, что все данные будут целостны.
    Isolation — изолированность гарантирует, что все транзакции будут выполняться изолированно и последовательно друг за 
    другом, но для пользователя это будет выглядеть будто бы транзакции выполняются параллельно.
    Durability — устойчивость к ошибкам гарантирует о том, что любые изменения, внесённые транзакцией, останутся навсегда
     и не может быть потери данных, если транзакция прошла успешно.

     https://medium.com/@kirill.sereda/saga-pattern-2daad957966e
     https://microservices.io/patterns/data/saga.html
